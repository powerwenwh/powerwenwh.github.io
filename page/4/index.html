<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"wenwenhuan.gitee.io","root":"/","images":"/images","scheme":"Gemini","darkmode":true,"version":"8.8.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>
<meta property="og:type" content="website">
<meta property="og:title" content="Wenhuan Blog">
<meta property="og:url" content="https://wenwenhuan.gitee.io/page/4/index.html">
<meta property="og:site_name" content="Wenhuan Blog">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="温文焕">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://wenwenhuan.gitee.io/page/4/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/4/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Wenhuan Blog</title>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Wenhuan Blog</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">即使天无雨 我亦留此地</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">温文焕</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">64</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://wenwenhuan.gitee.io/2021/04/12/OS/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="温文焕">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wenhuan Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/04/12/OS/" class="post-title-link" itemprop="url">操作系统常用知识点</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-04-12 23:11:00" itemprop="dateCreated datePublished" datetime="2021-04-12T23:11:00+08:00">2021-04-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2021-05-12 12:05:54" itemprop="dateModified" datetime="2021-05-12T12:05:54+08:00">2021-05-12</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><h3 id="进程和线程是什么的最新答法"><a href="#进程和线程是什么的最新答法" class="headerlink" title="进程和线程是什么的最新答法"></a>进程和线程是什么的最新答法</h3><p>进程：指在系统中正在运行的一个应用程序；程序一旦运行就是进程；进程——资源分配的最小单位。</p>
<p>线程：系统分配处理器时间资源的基本单元，或者说进程之内独立执行的一个单元执行流。线程——程序执行的最小单位。</p>
<h3 id="进程基本介绍"><a href="#进程基本介绍" class="headerlink" title="进程基本介绍"></a>进程基本介绍</h3><p>进程是程序执行时的一个实例，<strong>是系统进行资源分配的基本单位</strong>。所有与该进程有关的资源，都被记录在进程控制块(PCB)中。以表示该进程拥有这些资源或正在使用它们。另外，进程也是抢占处理机的调度单位，它拥有一个完整的虚拟地址空间。当进程发生调度时，<strong>不同的进程拥有不同的虚拟地址空间</strong>，而同一进程内的不同线程共享同一地址空间。</p>
<p><strong>程序运行时系统就会创建一个进程，并为它分配资源，然后把该进程放入进程就绪队列</strong>，进程调度器选中它的时候就会为它分配CPU时间，程序开始真正运行。</p>
<h4 id="记不住就这怎么答："><a href="#记不住就这怎么答：" class="headerlink" title="记不住就这怎么答："></a>记不住就这怎么答：</h4><blockquote>
<p>进程是<strong>是系统进行资源分配的基本单位</strong>，<strong>进程拥有自己的虚拟地址空间</strong>，<strong>程序运行时系统就会创建一个进程，并为它分配资源，然后把该进程放入进程就绪队列</strong>。</p>
</blockquote>
<h3 id="线程基本介绍"><a href="#线程基本介绍" class="headerlink" title="线程基本介绍"></a>线程基本介绍</h3><p>线程，有时也被称为轻量级进程，是程序执行流的最小单元，是进程中的一个实体，<strong>是被系统独立调度和分派的基本单位</strong>。与进程不同，线程与资源分配无关，线程自己不拥有系统资源，它属于某一个进程，并与进程内的其他线程一起共享进程的资源。线程只由相关堆栈（系统栈或用户栈）寄存器和线程控制表TCB组成。</p>
<p><strong>它是进程的一个执行流</strong>，</p>
<h4 id="记不住就这怎么答：-1"><a href="#记不住就这怎么答：-1" class="headerlink" title="记不住就这怎么答："></a>记不住就这怎么答：</h4><blockquote>
<p><strong>线程是进程的一个执行流</strong>，<strong>是CPU调度和分派的基本单位</strong>，<strong>线程间共享进程的所有资源</strong>。</p>
</blockquote>
<h3 id="进程与线程的区别"><a href="#进程与线程的区别" class="headerlink" title="进程与线程的区别"></a>进程与线程的区别</h3><p>地址空间：线程共享本进程的地址空间，而进程之间是独立的地址空间。</p>
<p>切换：</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/coder-programming/p/10595804.html">https://www.cnblogs.com/coder-programming/p/10595804.html</a></p>
<p>根本区别：进程是操作系统资源分配的基本单位，而线程是任务调度和执行的基本单位</p>
<p>在<strong>开销</strong>方面：每个进程都有独立的代码和数据空间（程序上下文），程序之间的切换会有较大的开销；线程可以看做轻量级的进程，同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器（PC），线程之间切换的开销小。</p>
<p><strong>所处环境</strong>：在操作系统中能同时运行多个进程（程序）；而在同一个进程（程序）中有多个线程同时执行（通过CPU调度，在每个时间片中只有一个线程执行）</p>
<p><strong>内存分配方面</strong>：系统在运行的时候会为每个进程分配不同的内存空间；而对线程而言，除了CPU外，系统不会为线程分配内存（线程所使用的资源来自其所属进程的资源），线程组之间只能共享资源。</p>
<p>包含关系：没有线程的进程可以看做是单线程的，如果一个进程内有多个线程，则执行过程不是一条线的，而是多条线（线程）共同完成的；线程是进程的一部分，所以线程也被称为轻权进程或者轻量级进程。</p>
<h3 id="进程的五种基本状态"><a href="#进程的五种基本状态" class="headerlink" title="进程的五种基本状态"></a>进程的五种基本状态</h3><img src="/2021/04/12/OS/image-20210415081219424.png" class="" title="image-20210415081219424">

<ul>
<li>创建状态：进程在创建时需要申请一个空白PCB，向其中填写控制和管理进程的信息，完成资源分配。如果创建工作无法完成，比如资源无法满足，就无法被调度运行，把此时进程所处状态称为创建状态</li>
<li>就绪状态：进程已经准备好，已分配到所需资源，只要分配到CPU就能够立即运行</li>
<li>执行状态：进程处于就绪状态被调度后，进程进入执行状态</li>
<li>阻塞状态：正在执行的进程由于某些事件（I/O请求，申请缓存区失败）而暂时无法运行，进程受到阻塞。在满足请求时进入就绪状态等待系统调用</li>
<li>终止状态：进程结束，或出现错误，或被系统终止，进入终止状态。无法再执行</li>
</ul>
<h3 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/gatieme/article/details/50908749">https://blog.csdn.net/gatieme/article/details/50908749</a></p>
<ol>
<li>管道（pipe）,流管道(s_pipe)和有名管道（FIFO）</li>
<li>信号（signal）</li>
<li>消息队列</li>
<li>共享内存</li>
<li>信号量</li>
<li>套接字（socket)</li>
</ol>
<h2 id="计算机内存模型"><a href="#计算机内存模型" class="headerlink" title="计算机内存模型"></a>计算机内存模型</h2><h2 id="为什么要有内存模型"><a href="#为什么要有内存模型" class="headerlink" title="为什么要有内存模型"></a>为什么要有内存模型</h2><p>在介绍Java内存模型之前，先来看一下到底什么是计算机内存模型，然后再来看Java内存模型在计算机内存模型的基础上做了哪些事情。要说计算机的内存模型，就要说一下一段古老的历史，看一下为什么要有内存模型。</p>
<p><strong>内存模型，英文名Memory Model，他是一个很老的老古董了。他是与计算机硬件有关的一个概念。那么我先给你介绍下他和硬件到底有啥关系。</strong></p>
<h3 id="CPU和缓存一致性"><a href="#CPU和缓存一致性" class="headerlink" title="CPU和缓存一致性"></a>CPU和缓存一致性</h3><p>我们应该都知道，计算机在执行程序的时候，每条指令都是在CPU中执行的，而执行的时候，又免不了要和数据打交道。而计算机上面的数据，是存放在主存当中的，也就是计算机的物理内存啦。</p>
<p>刚开始，还相安无事的，但是随着CPU技术的发展，CPU的执行速度越来越快。而由于内存的技术并没有太大的变化，所以从内存中读取和写入数据的过程和CPU的执行速度比起来差距就会越来越大,这就导致CPU每次操作内存都要耗费很多等待时间。</p>
<blockquote>
<p>这就像一家创业公司，刚开始，创始人和员工之间工作关系其乐融融，但是随着创始人的能力和野心越来越大，逐渐和员工之间出现了差距，普通员工原来越跟不上CEO的脚步。老板的每一个命令，传到到基层员工之后，由于基层员工的理解能力、执行能力的欠缺，就会耗费很多时间。这也就无形中拖慢了整家公司的工作效率。</p>
</blockquote>
<p>可是，不能因为内存的读写速度慢，就不发展CPU技术了吧，总不能让内存成为计算机处理的瓶颈吧。</p>
<p>所以，人们想出来了一个好的办法，就是在CPU和内存之间增加高速缓存。缓存的概念大家都知道，就是保存一份数据拷贝。他的特点是速度快，内存小，并且昂贵。</p>
<p>那么，程序的执行过程就变成了：</p>
<p><strong>当程序在运行过程中，会将运算需要的数据从主存复制一份到CPU的高速缓存当中，那么CPU进行计算时就可以直接从它的高速缓存读取数据和向其中写入数据，当运算结束之后，再将高速缓存中的数据刷新到主存当中。</strong></p>
<blockquote>
<p>之后，这家公司开始设立中层管理人员，管理人员直接归CEO领导，领导有什么指示，直接告诉管理人员，然后就可以去做自己的事情了。管理人员负责去协调底层员工的工作。因为管理人员是了解手下的人员以及自己负责的事情的。所以，大多数时候，公司的各种决策，通知等，CEO只要和管理人员之间沟通就够了。</p>
</blockquote>
<p>而随着CPU能力的不断提升，一层缓存就慢慢的无法满足要求了，就逐渐的衍生出多级缓存。</p>
<p>按照数据读取顺序和与CPU结合的紧密程度，CPU缓存可以分为一级缓存（L1），二级缓存（L3），部分高端CPU还具有三级缓存（L3），每一级缓存中所储存的全部数据都是下一级缓存的一部分。</p>
<p>这三种缓存的技术难度和制造成本是相对递减的，所以其容量也是相对递增的。</p>
<p>那么，在有了多级缓存之后，程序的执行就变成了：</p>
<p><strong>当CPU要读取一个数据时，首先从一级缓存中查找，如果没有找到再从二级缓存中查找，如果还是没有就从三级缓存或内存中查找。</strong></p>
<blockquote>
<p>随着公司越来越大，老板要管的事情越来越多，公司的管理部门开始改革，开始出现高层，中层，底层等管理者。一级一级之间逐层管理。</p>
</blockquote>
<p>单核CPU只含有一套L1，L2，L3缓存；如果CPU含有多个核心，即多核CPU，则每个核心都含有一套L1（甚至和L2）缓存，而共享L3（或者和L2）缓存。</p>
<blockquote>
<p>公司也分很多种，有些公司只有一个大Boss，他一个人说了算。但是有些公司有比如联席总经理、合伙人等机制。</p>
<p>单核CPU就像一家公司只有一个老板，所有命令都来自于他，那么就只需要一套管理班底就够了。</p>
<p>多核CPU就像一家公司是由多个合伙人共同创办的，那么，就需要给每个合伙人都设立一套供自己直接领导的高层管理人员，多个合伙人共享使用的是公司的底层员工。</p>
<p>还有的公司，不断壮大，开始差分出各个子公司。各个子公司就是多个CPU了，互相之前没有共用的资源。互不影响。</p>
</blockquote>
<p>下图为一个单CPU双核的缓存结构。</p>
<img src="/2021/04/12/OS/image-20210415081321290.png" class="" title="image-20210415081321290">

<p>随着计算机能力不断提升，开始支持多线程。那么问题就来了。我们分别来分析下单线程、多线程在单核CPU、多核CPU中的影响。</p>
<p><strong>单线程。</strong>cpu核心的缓存只被一个线程访问。缓存独占，不会出现访问冲突等问题。</p>
<p><strong>单核CPU，多线程。</strong>进程中的多个线程会同时访问进程中的共享数据，CPU将某块内存加载到缓存后，不同线程在访问相同的物理地址的时候，都会映射到相同的缓存位置，这样即使发生线程的切换，缓存仍然不会失效。但由于任何时刻只能有一个线程在执行，因此不会出现缓存访问冲突。</p>
<p><strong>多核CPU，多线程。</strong>每个核都至少有一个L1 缓存。多个线程访问进程中的某个共享内存，且这多个线程分别在不同的核心上执行，则每个核心都会在各自的caehe中保留一份共享内存的缓冲。由于多核是可以并行的，可能会出现多个线程同时写各自的缓存的情况，而各自的cache之间的数据就有可能不同。</p>
<p>在CPU和主存之间增加缓存，在多线程场景下就可能存在<strong>缓存一致性问题</strong>，也就是说，在多核CPU中，每个核的自己的缓存中，关于同一个数据的缓存内容可能不一致。</p>
<blockquote>
<p>如果这家公司的命令都是串行下发的话，那么就没有任何问题。</p>
<p>如果这家公司的命令都是并行下发的话，并且这些命令都是由同一个CEO下发的，这种机制是也没有什么问题。因为他的命令执行者只有一套管理体系。</p>
<p>如果这家公司的命令都是并行下发的话，并且这些命令是由多个合伙人下发的，这就有问题了。因为每个合伙人只会把命令下达给自己直属的管理人员，而多个管理人员管理的底层员工可能是公用的。</p>
<p>比如，合伙人1要辞退员工a，合伙人2要给员工a升职，升职后的话他再被辞退需要多个合伙人开会决议。两个合伙人分别把命令下发给了自己的管理人员。合伙人1命令下达后，管理人员a在辞退了员工后，他就知道这个员工被开除了。而合伙人2的管理人员2这时候在没得到消息之前，还认为员工a是在职的，他就欣然的接收了合伙人给他的升职a的命令。</p>
</blockquote>
<img src="/2021/04/12/OS/image-20210415081258412.png" class="" title="image-20210415081258412">

<h3 id="处理器优化和指令重排"><a href="#处理器优化和指令重排" class="headerlink" title="处理器优化和指令重排"></a>处理器优化和指令重排</h3><p>上面提到在在CPU和主存之间增加缓存，在多线程场景下会存在<strong>缓存一致性问题</strong>。除了这种情况，还有一种硬件问题也比较重要。那就是为了使处理器内部的运算单元能够尽量的被充分利用，处理器可能会对输入代码进行乱序执行处理。这就是<strong>处理器优化</strong>。</p>
<p>除了现在很多流行的处理器会对代码进行优化乱序处理，很多编程语言的编译器也会有类似的优化，比如Java虚拟机的即时编译器（JIT）也会做<strong>指令重排</strong>。</p>
<p>可想而知，如果任由处理器优化和编译器对指令重排的话，就可能导致各种各样的问题。</p>
<blockquote>
<p>关于员工组织调整的情况，如果允许人事部在接到多个命令后进行随意拆分乱序执行或者重排的话，那么对于这个员工以及这家公司的影响是非常大的。</p>
</blockquote>
<h2 id="并发编程的问题"><a href="#并发编程的问题" class="headerlink" title="并发编程的问题"></a>并发编程的问题</h2><p>前面说的和硬件有关的概念你可能听得有点蒙，还不知道他到底和软件有啥关系。但是关于并发编程的问题你应该有所了解，比如原子性问题，可见性问题和有序性问题。</p>
<p>其实，原子性问题，可见性问题和有序性问题。是人们抽象定义出来的。而这个抽象的底层问题就是前面提到的缓存一致性问题、处理器优化问题和指令重排问题等。</p>
<p>这里简单回顾下这三个问题，并不准备深入展开，感兴趣的读者可以自行学习。我们说，并发编程，为了保证数据的安全，需要满足以下三个特性：</p>
<p><strong>原子性</strong>是指在一个操作中就是cpu不可以在中途暂停然后再调度，既不被中断操作，要不执行完成，要不就不执行。</p>
<p><strong>可见性</strong>是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。</p>
<p><strong>有序性</strong>即程序执行的顺序按照代码的先后顺序执行。</p>
<p>有没有发现，<strong>缓存一致性问题</strong>其实就是<strong>可见性问题</strong>。而<strong>处理器优化</strong>是可以导致<strong>原子性问题</strong>的。<strong>指令重排</strong>即会导致<strong>有序性问题</strong>。所以，后文将不再提起硬件层面的那些概念，而是直接使用大家熟悉的原子性、可见性和有序性。</p>
<h2 id="什么是内存模型"><a href="#什么是内存模型" class="headerlink" title="什么是内存模型"></a>什么是内存模型</h2><p>前面提到的，缓存一致性问题、处理器器优化的指令重排问题是硬件的不断升级导致的。那么，有没有什么机制可以很好的解决上面的这些问题呢？</p>
<p>最简单直接的做法就是废除处理器和处理器的优化技术、废除CPU缓存，让CPU直接和主存交互。但是，这么做虽然可以保证多线程下的并发问题。但是，这就有点因噎废食了。</p>
<p>所以，为了保证并发编程中可以满足原子性、可见性及有序性。有一个重要的概念，那就是——内存模型。</p>
<p><u><strong>为了保证共享内存的正确性（可见性、有序性、原子性），内存模型定义了共享内存系统中多线程程序读写操作行为的规范。</strong></u>通过这些规则来规范对内存的读写操作，从而保证指令执行的正确性。它与处理器有关、与缓存有关、与并发有关、与编译器也有关。他解决了CPU多级缓存、处理器优化、指令重排等导致的内存访问问题，保证了并发场景下的一致性、原子性和有序性。</p>
<p>内存模型解决并发问题主要采用两种方式：<strong>限制处理器优化</strong>和<strong>使用内存屏障</strong>。本文就不深入底层原理来展开介绍了，感兴趣的朋友可以自行学习。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://wenwenhuan.gitee.io/2021/04/12/%E7%BA%A2%E9%BB%91%E6%A0%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="温文焕">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wenhuan Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/04/12/%E7%BA%A2%E9%BB%91%E6%A0%91/" class="post-title-link" itemprop="url">红黑树</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-04-12 23:11:00" itemprop="dateCreated datePublished" datetime="2021-04-12T23:11:00+08:00">2021-04-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2021-04-13 13:54:14" itemprop="dateModified" datetime="2021-04-13T13:54:14+08:00">2021-04-13</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h2><p>红黑树是每个节点都带有<em>颜色</em>属性的二叉查找树，颜色为<em>红色</em>或<em>黑色</em>。在二叉查找树强制一般要求以外，对于任何有效的红黑树我们增加了如下的额外要求：</p>
<ol>
<li>节点是红色或黑色。</li>
<li>根是黑色。</li>
<li>所有叶子都是黑色（叶子是NIL节点）。</li>
<li>每个红色节点必须有两个黑色的子节点。（从每个叶子到根的所有路径上不能有两个连续的红色节点。）</li>
<li>从任一节点到其每个叶子的所有<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%81%93%E8%B7%AF_(%E5%9B%BE%E8%AE%BA)">简单路径</a>都包含相同数目的黑色节点。</li>
</ol>
<p><img src="450px-Red-black_tree_example.svg.png"></p>
<p>这些约束确保了红黑树的关键特性：<strong>从根到叶子的最长的可能路径不多于最短的可能路径的两倍长</strong>。结果是这个树大致上是平衡的。因为操作比如插入、删除和查找某个值的最坏情况时间都要求与树的高度成比例，这个在高度上的理论上限允许红黑树在最坏情况下都是高效的，而不同于普通的<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91">二叉查找树</a>。</p>
<p>要知道为什么这些性质确保了这个结果，注意到性质4导致了路径不能有两个毗连的红色节点就足够了。最短的可能路径都是黑色节点，最长的可能路径有交替的红色和黑色节点。因为根据性质5所有最长的路径都有相同数目的黑色节点，这就表明了没有路径能多于任何其他路径的两倍长。</p>
<p>在很多树数据结构的表示中，一个节点有可能只有一个子节点，而叶子节点包含数据。用这种范例表示红黑树是可能的，但是这会改变一些性质并使算法复杂。为此，本文中我们使用”nil叶子”或”空（null）叶子”，如上图所示，它不包含数据而只充当树在此结束的指示。这些节点在绘图中经常被省略，导致了这些树好像同上述原则相矛盾，而实际上不是这样。与此有关的结论是所有节点都有两个子节点，尽管其中的一个或两个可能是空叶子。</p>
<h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><p>因为每一个红黑树也是一个特化的<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91">二叉查找树</a>，因此红黑树上的只读操作与普通<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91">二叉查找树</a>上的只读操作相同。然而，在红黑树上进行插入操作和删除操作会导致不再符合红黑树的性质。恢复红黑树的性质需要少量（O(log n)）的颜色变更（实际是非常快速的）和不超过三次<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%A0%91%E6%97%8B%E8%BD%AC">树旋转</a>（对于插入操作是两次）。虽然插入和删除很复杂，但操作时间仍可以保持为O(log n)次。</p>
<h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p>共5种可能</p>
<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>共6种可能</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://wenwenhuan.gitee.io/2021/04/12/%E8%AE%A1%E7%BD%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="温文焕">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wenhuan Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/04/12/%E8%AE%A1%E7%BD%91/" class="post-title-link" itemprop="url">计算机网络常用知识点</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-04-12 23:11:00" itemprop="dateCreated datePublished" datetime="2021-04-12T23:11:00+08:00">2021-04-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2021-05-12 12:06:46" itemprop="dateModified" datetime="2021-05-12T12:06:46+08:00">2021-05-12</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="OSI-TCP-IP-五层协议的体系结构，各层协议"><a href="#OSI-TCP-IP-五层协议的体系结构，各层协议" class="headerlink" title="OSI,TCP/IP,五层协议的体系结构，各层协议"></a>OSI,TCP/IP,五层协议的体系结构，各层协议</h2><hr>
<p>OSI分层（7层）：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。</p>
<p><strong>TCP/IP分层（4层）：网络接口层、网际层、运输层、应用层。</strong></p>
<p>五层协议：物理层、数据链路层、网络层、运输层、应用层。</p>
<p><strong>TCP/IP协议族：</strong></p>
<ul>
<li>应用层：HTTP，SMTP，DNS,RTP</li>
<li>运输层：TCP,UDP</li>
<li>网际层：IP</li>
</ul>
<p><strong>HTTP协议：</strong> 超文本传输协议，是一个属于应用层的面向对象的协议，由于其简捷、快速的方式，适用于分布式超媒体信息系统。</p>
<h2 id="TCP三次握手和四次挥手的全过程"><a href="#TCP三次握手和四次挥手的全过程" class="headerlink" title="TCP三次握手和四次挥手的全过程"></a>TCP三次握手和四次挥手的全过程</h2><hr>
<img src="/2021/04/12/%E8%AE%A1%E7%BD%91/image-20210415220355775.png" class="" title="image-20210415220355775">

<h4 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a><strong>三次握手</strong></h4><ul>
<li><p>第一次握手：客户端给服务端发一个 SYN 报文，并指明客户端的初始化序列号 ISN(c)。此时客户端处于 <code>SYN_SEND</code> 状态。</p>
<p>首部的同步位SYN=1，初始序号seq=x，SYN=1的报文段不能携带数据，但要消耗掉一个序号。</p>
</li>
<li><p>第二次握手：服务器收到客户端的 SYN 报文之后，会以自己的 SYN 报文作为应答，并且也是指定了自己的初始化序列号 ISN(s)。同时会把客户端的 ISN + 1 作为ACK 的值，表示自己已经收到了客户端的 SYN，此时服务器处于 <code>SYN_RCVD</code> 的状态。</p>
<p>在确认报文段中SYN=1，ACK=1，确认号ack=x+1，初始序号seq=y。</p>
</li>
<li><p>第三次握手：客户端收到 SYN 报文之后，会发送一个 ACK 报文，当然，也是一样把服务器的 ISN + 1 作为 ACK 的值，表示已经收到了服务端的 SYN 报文，此时客户端处于 <code>ESTABLISHED</code> 状态。服务器收到 ACK 报文之后，也处于 <code>ESTABLISHED</code> 状态，此时，双方已建立起了连接。</p>
<p>确认报文段ACK=1，确认号ack=y+1，序号seq=x+1（初始为seq=x，第二个报文段所以要+1），ACK报文段可以携带数据，不携带数据则不消耗序号。</p>
</li>
</ul>
<p><strong>状态整理</strong>：</p>
<ul>
<li>客户端：关闭（CLOSE）、同步已发送（SYN-SEND）、已建立连接（ESTABLISHED）</li>
<li>服务器：关闭（CLOSE）、收听（LISTEN）、同步收到（SYN-RCVD）、已建立连接（ESTABLISHED）</li>
</ul>
<h4 id="为什么需要三次握手，两次不行吗？"><a href="#为什么需要三次握手，两次不行吗？" class="headerlink" title="为什么需要三次握手，两次不行吗？"></a>为什么需要三次握手，两次不行吗？</h4><p>关键字：<strong>客户端重传</strong>。<strong>第一次握手</strong>可能是一次<strong>失效的握手</strong>，<strong>第三次握手</strong>是对第一次握手的<strong>确认</strong>。</p>
<p>假如两次，也就是客户端一发送，服务端就建立连接。那么假如客户端发送两次，因为第一次滞留，那么客户端相当于建立了两次连接，但实际上第一次已经是无效的了。</p>
<p>如客户端发出连接请求，但因连接请求报文丢失而未收到确认，于是客户端再重传一次连接请求。后来收到了确认，建立了连接。数据传输完毕后，就释放了连接，客户端共发出了两个连接请求报文段，其中第一个丢失，第二个到达了服务端，但是第一个丢失的报文段只是在<strong>某些网络结点长时间滞留了，延误到连接释放以后的某个时间才到达服务端</strong>，此时服务端误认为客户端又发出一次新的连接请求，于是就向客户端发出确认报文段，同意建立连接，不采用三次握手，只要服务端发出确认，就建立新的连接了，此时客户端忽略服务端发来的确认，也不发送数据，则服务端一致等待客户端发送数据，浪费资源。</p>
<h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><img src="/2021/04/12/%E8%AE%A1%E7%BD%91/image-20210415220422325.png" class="" title="image-20210415220422325">

<h4 id="四次挥手的过程如下："><a href="#四次挥手的过程如下：" class="headerlink" title="四次挥手的过程如下："></a>四次挥手的过程如下：</h4><ul>
<li><p>第一次挥手：客户端发送一个 FIN 报文，报文中会指定一个序列号。此时客户端处于 <code>FIN_WAIT1</code> 状态。 即发出<strong>连接释放报文段</strong>（FIN=1，序号seq=u），并停止再发送数据，主动关闭TCP连接，进入FIN_WAIT1（终止等待1）状态，等待服务端的确认。</p>
</li>
<li><p>第二次挥手：服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序列号值 +1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 <code>CLOSE_WAIT</code> 状态。 即服务端收到连接释放报文段后即发出<strong>确认报文段</strong>（ACK=1，确认号ack=u+1，序号seq=v），服务端进入CLOSE_WAIT（关闭等待）状态，此时的TCP处于<strong>半关闭状态</strong>，客户端到服务端的连接释放。客户端收到服务端的确认后，进入FIN_WAIT2（终止等待2）状态，等待服务端发出的连接释放报文段。</p>
</li>
<li><p>第三次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号。此时服务端处于 <code>LAST_ACK</code> 的状态。 即服务端没有要向客户端发出的数据，服务端发出<strong>连接释放报文段</strong>（FIN=1，ACK=1，序号seq=w，确-认号ack=u+1），服务端进入LAST_ACK（最后确认）状态，等待客户端的确认。</p>
</li>
<li><p>第四次挥手：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 +1 作为自己 ACK 报文的序列号值，此时客户端处于 <code>TIME_WAIT</code> 状态。需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态，服务端收到 ACK 报文之后，就处于关闭连接了，处于 <code>CLOSED</code> 状态。 即客户端收到服务端的连接释放报文段后，对此发出<strong>确认报文段</strong>（ACK=1，seq=u+1，ack=w+1），客户端进入TIME_WAIT（时间等待）状态。此时TCP未释放掉，需要经过时间等待计时器设置的时间2MSL后，客户端才进入CLOSED状态。</p>
<p>时间MSL叫做<strong>最长报文段寿命</strong>（Maximun Segment Lifetime）</p>
</li>
</ul>
<p><strong>状态整理</strong>：</p>
<ul>
<li>客户端：已建立连接（ESTABLISHED）、FIN_WAIT1（终止等待1）、FIN_WAIT2（终止等待2）、TIME_WAIT（时间等待）</li>
<li>服务器：已建立连接（ESTABLISHED）、CLOSE_WAIT（关闭等待）、LAST_ACK（最后确认）</li>
</ul>
<h3 id="挥手为什么需要四次"><a href="#挥手为什么需要四次" class="headerlink" title="挥手为什么需要四次"></a>挥手为什么需要四次</h3><p>关键字：半关闭，<strong>服务端还想要发送数据</strong></p>
<h3 id="四次挥手释放连接时，等待2MSL的意义"><a href="#四次挥手释放连接时，等待2MSL的意义" class="headerlink" title="四次挥手释放连接时，等待2MSL的意义?"></a>四次挥手释放连接时，等待2MSL的意义?</h3><h4 id="两个理由："><a href="#两个理由：" class="headerlink" title="两个理由："></a>两个理由：</h4><ol>
<li><p>关键字：<strong>客户端重传</strong>，确保客户端最后一个 ACK 能够到达服务端（这个 ACK 可能丢失）</p>
<p>保证客户端发送的最后一个ACK报文段能够到达服务端。 <strong>客户端的ACK报文段有可能丢失</strong>（<strong>所以客户端怎么着也得重传一次，不然服务端没办法正常关闭</strong>），使得处于LAST-ACK状态的B收不到对已发送的FIN+ACK报文段的确认，服务端超时重传FIN+ACK报文段，而客户端能在2MSL时间内收到这个重传的FIN+ACK报文段，接着客户端重传一次确认，重新启动2MSL计时器，最后客户端和服务端都进入到CLOSED状态，若客户端在TIME-WAIT状态不等待一段时间，而是发送完ACK报文段后立即释放连接，则无法收到服务端重传的FIN+ACK报文段，所以不会再发送一次确认报文段，则服务端无法正常进入到CLOSED状态。</p>
</li>
<li><p>关键字：<strong>已失效的连接请求报文段</strong></p>
<p>防止“已失效的连接请求报文段”出现在本连接中。 客户端在发送完最后一个ACK报文段后，再经过2MSL，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失，使下一个新的连接中不会出现这种旧的连接请求报文段。</p>
</li>
</ol>
<p><strong>ACK报文</strong>：在TCP/IP协议中，如果接收方成功的接收到数据，那么会回复一个ACK数据。通常ACK信号有自己固定的格式,长度大小,由接收方回复给发送方。</p>
<p><strong>TCP 对应的一些函数</strong></p>
<h4 id="TCP-三次握手发生在哪个函数之间"><a href="#TCP-三次握手发生在哪个函数之间" class="headerlink" title="TCP 三次握手发生在哪个函数之间"></a>TCP 三次握手发生在哪个函数之间</h4><p>TCP 三次握手是发送在<strong>客户端</strong>调用 <code>connect()</code> 函数的时候，注意服务器响应 ack 跟 <code>accept()</code> 没什么关系，服务器在 listen() 之后，就可以响应 ack，所以如果问发生在服务器端的哪个函数，应该说是 <code>listen()</code> 之后。</p>
<h2 id="tcp和udp的区别"><a href="#tcp和udp的区别" class="headerlink" title="tcp和udp的区别"></a>tcp和udp的区别</h2><hr>
<p><strong>比较方向</strong></p>
<p>tcp 是一个 <strong>可靠</strong> 的 <strong>面向连接</strong> 的 <strong>字节流</strong> 服务</p>
<p>可靠性，是否有连接，报文格式，双工性，传输速度</p>
<img src="/2021/04/12/%E8%AE%A1%E7%BD%91/image-20210415220450406.png" class="" title="image-20210415220450406">

<h2 id="TCP如何保证可靠性"><a href="#TCP如何保证可靠性" class="headerlink" title="TCP如何保证可靠性"></a>TCP如何保证可靠性</h2><hr>
<p>主要方向：<strong>校验和</strong>，<strong>握手</strong>，<strong>流量控制</strong>，<strong>拥塞控制</strong></p>
<ul>
<li>校验和，按16位为一个数据<strong>相加</strong>，最后的进位继续加，最终的值<strong>取反</strong></li>
</ul>
<img src="/2021/04/12/%E8%AE%A1%E7%BD%91/image-20210415220516424.png" class="" title="image-20210415220516424">

<ul>
<li>发送方：在发送数据之前计算检验和，并进行校验和的填充。 接收方：收到数据后，对数据以同样的方式进行计算，求出校验和，与发送方的进行比对。</li>
<li>确认应答和序列号</li>
<li>超时重传</li>
<li>连接管理，三次握手，四次挥手</li>
<li>流量控制</li>
<li>拥塞控制</li>
</ul>
<h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><hr>
<h3 id="http状态码"><a href="#http状态码" class="headerlink" title="http状态码"></a>http状态码</h3><h4 id="201-Created-（已创建）"><a href="#201-Created-（已创建）" class="headerlink" title="201 Created （已创建）"></a>201 Created （已创建）</h4><ul>
<li>响应结果：该请求已成功，并因此创建了一个新的资源。</li>
<li>使用场景：作为PUT请求的返回值。</li>
</ul>
<h3 id="204-No-Content-没有内容"><a href="#204-No-Content-没有内容" class="headerlink" title="204 No Content (没有内容)"></a>204 No Content (没有内容)</h3><ul>
<li>响应结果：服务器成功处理了客户端请求，但服务器无返回内容。204是HTTP中数据量最少的响应状态，204的<strong>响应中没有body</strong>，而且Content-Length=0。</li>
<li>使用场景：204状态在一些网站分析的代码中<strong>最常用</strong>到，只需要把客户端的一些信息提交给服务器而无需关心响应。</li>
</ul>
<h3 id="301-Moved-Permanently（永久性重定向"><a href="#301-Moved-Permanently（永久性重定向" class="headerlink" title="301 Moved Permanently（永久性重定向)"></a>301 Moved Permanently（永久性重定向)</h3><ul>
<li>响应结果：表示请求的资源已被分配了新的URL，以后应使用现在所指的URL。也就是说如果已经吧资源对应的URL保存为书签了，这时应该按Location首部字段提示的URL重新保存。</li>
<li>使用场景：</li>
<li><ul>
<li>域名到期不想续费（或者发现了更适合网站的域名），想换个域名。</li>
</ul>
</li>
<li><ul>
<li>在搜索引擎的搜索结果中出现了不带www的域名，而带www的域名却没有收录，这个时候可以用301重定向来告诉搜索引擎我们目标的域名是哪一个。</li>
</ul>
</li>
<li><ul>
<li>空间服务器不稳定，换空间的时候。</li>
</ul>
</li>
</ul>
<h3 id="302-Found（临时性重定向）"><a href="#302-Found（临时性重定向）" class="headerlink" title="302 Found（临时性重定向）"></a>302 Found（临时性重定向）</h3><ul>
<li>响应结果：该状态码表示请求的资源已被分配了新的URL，希望用户（本次）能使用新的URL访问。</li>
<li>使用场景：尽量使用301！</li>
</ul>
<h3 id="304-Not-Modified"><a href="#304-Not-Modified" class="headerlink" title="304 Not Modified"></a>304 Not Modified</h3><p>字面意思是：资源未改变，可直接使用缓存。</p>
<p>这种响应一般是GET请求中带有附加条件，例如请求头中含有if-Match,if-Modified-Since等（if-Match表示只请求带有特殊标记的资源，if-Modified-Since表示请求指定时间后未变更的资源，因为本文主要讲解状态码，所以不在此引入太多http头部的相关内容，这里是为了简单解释下附加条件请求的含义）。</p>
<p>这种情况下，<strong>服务端不会返回响应主体</strong>，含义就是：”<strong>从你上次访问以来这个资源都没变过哟，直接使用你本地的缓存就行啦</strong>“。</p>
<p>304就是3xx里面的一个特例，因为它不算是一个重定向。（一般我们认为重定向要给出一个新的地址让客户端去访问，304如果一定要解释为重定向，只能解释为让客户端转去访问缓存-_-）</p>
<h3 id="401-Unauthorized（未授权）"><a href="#401-Unauthorized（未授权）" class="headerlink" title="401 Unauthorized（未授权）"></a>401 Unauthorized（未授权）</h3><ul>
<li>响应结果：表示发送的请求需要有通过HTTP认证的认证信息。另外若之前已进行过一次请求，则表示用户认证失败。返回含有401响应必须包含一个适用于被请求资源的WWW-Authenticate 首部用以质询用户信息。当浏览器初次接收到401响应，会弹出认证用的对话窗口。</li>
<li>出现原因：客户端错误，指的是由于缺乏目标资源要求的身份验证凭证，发送的请求未得到满足。</li>
</ul>
<h3 id="403-Forbidden-（禁止）"><a href="#403-Forbidden-（禁止）" class="headerlink" title="403 Forbidden （禁止）"></a>403 Forbidden （禁止）</h3><ul>
<li>响应结果：对请求资源的访问服务器拒绝了。服务器端没有必要给出拒绝的详细理由，但如果想作说明的话，可以在实体的主题部分对原因进行描述，这样就能让用户看到了。</li>
<li>出现原因：未获得文件系统的访问授权，访问权限出现某些问题（从未授权的发送源IP地址试图访问）等列举情况都可能是发生403的原因。</li>
</ul>
<h3 id="502-Bad-Gateway"><a href="#502-Bad-Gateway" class="headerlink" title="502 Bad Gateway"></a>502 Bad Gateway</h3><p>作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应。这里说明下网关和代理服务器的概念：前面我们举例子都是直接客户端向服务器发请求，实际上客户端有时候不是直接向服务器请求，这中间可能存在网关和代理。画个简单的图：</p>
<h3 id="503-Service-Unavailable"><a href="#503-Service-Unavailable" class="headerlink" title="503 Service Unavailable"></a>503 Service Unavailable</h3><p>服务器暂时无法使用，可能是维护或者升级，反正无法使用。</p>
<h3 id="504-Gateway-Timeout"><a href="#504-Gateway-Timeout" class="headerlink" title="504 Gateway Timeout"></a>504 Gateway Timeout</h3><p>作为网关或者代理工作的服务器访问超时。</p>
<h2 id="ARQ协议"><a href="#ARQ协议" class="headerlink" title="ARQ协议"></a>ARQ协议</h2><hr>
<p>也是为了实现<strong>可靠传输</strong>的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组</p>
<h4 id="ARQ协议是什么？"><a href="#ARQ协议是什么？" class="headerlink" title="ARQ协议是什么？"></a>ARQ协议是什么？</h4><p><strong>自动重传请求</strong>（Automatic Repeat-reQuest，ARQ）是OSI模型中数据链路层和传输层的错误纠正协议之一。它通过使用<strong>确认</strong>和<strong>超时</strong>这两个机制，在不可靠服务的基础上实现可靠的信息传输。如果发送方在发送后一段时间之内没有收到确认帧，它通常会重新发送。ARQ包括停止等待ARQ协议和连续ARQ协议。</p>
<h4 id="根据arq协议可以延申出停止等待和连续arq协议"><a href="#根据arq协议可以延申出停止等待和连续arq协议" class="headerlink" title="根据arq协议可以延申出停止等待和连续arq协议"></a>根据arq协议可以延申出停止等待和连续arq协议</h4><h3 id="停止等待ARQ协议"><a href="#停止等待ARQ协议" class="headerlink" title="停止等待ARQ协议"></a>停止等待ARQ协议</h3><ul>
<li>停止等待协议是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认（回复ACK）。如果过了一段时间（超时时间后），还是没有收到 ACK 确认，说明没有发送成功，需要重新发送，直到收到确认后再发下一个分组；</li>
<li>在停止等待协议中，若接收方收到重复分组，就丢弃该分组，但同时还要发送确认；</li>
</ul>
<h3 id="连续ARQ协议"><a href="#连续ARQ协议" class="headerlink" title="连续ARQ协议"></a>连续ARQ协议</h3><p>连续 ARQ 协议可提高信道利用率。发送方维持一个发送窗口，凡位于发送窗口内的分组可以连续发送出去，而不需要等待对方确认。接收方一般采用累计确认，对按序到达的最后一个分组发送确认，表明到这个分组为止的所有分组都已经正确收到了。</p>
<h2 id="各层对应协议"><a href="#各层对应协议" class="headerlink" title="各层对应协议"></a>各层对应协议</h2><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">每一层的协议如下：</span><br><span class="line">物理层：RJ45、CLOCK、IEEE802.3    （中继器，集线器）</span><br><span class="line">数据链路：PPP、FR、HDLC、VLAN、MAC  （网桥，交换机）</span><br><span class="line">网络层：IP、ICMP、ARP、RARP、OSPF、IPX、RIP、IGRP、 （路由器）</span><br><span class="line">传输层：TCP、UDP、SPX</span><br><span class="line">会话层：NFS、SQL、NETBIOS、RPC</span><br><span class="line">表示层：JPEG、MPEG、ASII</span><br><span class="line">应用层：FTP、DNS、Telnet、SMTP、HTTP、WWW、NFS</span><br><span class="line">每一层的作用如下：</span><br><span class="line">物理层：通过媒介传输比特,确定机械及电气规范（比特Bit）</span><br><span class="line">数据链路层：将比特组装成帧和点到点的传递（帧Frame）</span><br><span class="line">网络层：负责数据包从源到宿的传递和网际互连（包PackeT）</span><br><span class="line">传输层：提供端到端的可靠报文传递和错误恢复（段Segment）</span><br><span class="line">会话层：建立、管理和终止会话（会话协议数据单元SPDU）</span><br><span class="line">表示层：对数据进行翻译、加密和压缩（表示协议数据单元PPDU）</span><br><span class="line">应用层：允许访问OSI环境的手段（应用协议数据单元APDU）</span><br></pre></td></tr></table></figure>

<h2 id="常用端口"><a href="#常用端口" class="headerlink" title="常用端口"></a>常用端口</h2><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">20,21：FTP</span><br><span class="line">22：SSH</span><br><span class="line">23：Telnet</span><br><span class="line">25：SMTP</span><br><span class="line">53：DNS（UDP）</span><br><span class="line">69：TFTP（类似FTP）</span><br><span class="line">80：HTTP</span><br><span class="line">443：HTTPS</span><br><span class="line">1080：socks代理服务</span><br><span class="line">8080：用户www代理服务</span><br></pre></td></tr></table></figure>

<h2 id="HTTPS加密过程"><a href="#HTTPS加密过程" class="headerlink" title="HTTPS加密过程"></a>HTTPS加密过程</h2><hr>
<h3 id="HTTP和HTTPS区别"><a href="#HTTP和HTTPS区别" class="headerlink" title="HTTP和HTTPS区别"></a>HTTP和HTTPS区别</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/xionghuixionghui/article/details/68569282">https://blog.csdn.net/xionghuixionghui/article/details/68569282</a></p>
<p>HTTP协议以明文方式发送内容，不提供任何方式的数据加密，如果攻击者截取了Web浏览器和网站服务器之间的传输报文，就可以直接读懂其中的信息，因此，HTTP协议不适合传输一些敏感信息，比如：信用卡号、密码等支付信息。</p>
<p>安全套接字层超文本传输协议HTTPS，为了数据传输的安全，HTTPS在HTTP的基础上加入了SSL协议，SSL依靠证书来验证服务器的身份，并为浏览器和服务器之间的通信加密。</p>
<p>HTTPS协议的主要作用可以分为两种：一种是建立一个信息安全通道，来保证数据传输的安全；另一种就是确认网站的真实性。</p>
<p>简单来说，HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全。</p>
<p>HTTPS和HTTP的区别主要如下：</p>
<p>1、https协议需要到ca<strong>申请证书</strong>，一般免费证书较少，因而需要一定费用。</p>
<p>2、http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。</p>
<p>3、http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。</p>
<p>4、http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。</p>
<p>最新推出的TLS协议，是SSL 3.0协议的升级版</p>
<img src="/2021/04/12/%E8%AE%A1%E7%BD%91/640" class="" title="图片">

<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzA5MzY4NTQwMA==&amp;mid=2651008910&amp;idx=4&amp;sn=049fa10eecb3de61b98d7f58bbb78f74&amp;chksm=8bad9c79bcda156fc2097361977595d4a19a56ded9c8b1ca55890bfe800db0551b1723f2d7b9&amp;mpshare=1&amp;scene=24&amp;srcid=08287mXFO8ufu50J99Dwdfcp&amp;sharer_sharetime=1566958392180&amp;sharer_shareid=21a49bdfc44694f7d1e3ef9964b3998f#rd">https://mp.weixin.qq.com/s?__biz=MzA5MzY4NTQwMA==&amp;mid=2651008910&amp;idx=4&amp;sn=049fa10eecb3de61b98d7f58bbb78f74&amp;chksm=8bad9c79bcda156fc2097361977595d4a19a56ded9c8b1ca55890bfe800db0551b1723f2d7b9&amp;mpshare=1&amp;scene=24&amp;srcid=08287mXFO8ufu50J99Dwdfcp&amp;sharer_sharetime=1566958392180&amp;sharer_shareid=21a49bdfc44694f7d1e3ef9964b3998f#rd</a></p>
<ol>
<li>客户端请求服务器获取证书<strong>公钥</strong>。</li>
<li>客户端(SSL/TLS)解析证书（无效会弹出警告）。</li>
<li>客户端生成随机值（这个随机值就是密钥）。</li>
<li>客户端用公钥加密密钥，发送给服务器。</li>
<li>服务端用私钥解密密钥得到随机值（密钥）。—从此以后就用密钥通信</li>
<li>将信息和随机值混合在一起进行对称加密。</li>
<li>将加密的内容发送给客户端。</li>
<li>客户端用秘钥解密信息。</li>
</ol>
<p><a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2011/08/what_is_a_digital_signature.html">http://www.ruanyifeng.com/blog/2011/08/what_is_a_digital_signature.html</a></p>
<p>ca证书<a target="_blank" rel="noopener" href="https://www.cnblogs.com/handsomeBoys/p/6556336.html">https://www.cnblogs.com/handsomeBoys/p/6556336.html</a></p>
<h2 id="TCP-KeepAlive-原理"><a href="#TCP-KeepAlive-原理" class="headerlink" title="TCP KeepAlive 原理"></a>TCP KeepAlive 原理</h2><hr>
<p>TCP KeepAlive 的基本原理是，<strong>隔一段时间给连接对端发送一个探测包</strong>，如果收到对方回应的 ACK，则认为连接还是存活的，在超过一定重试次数之后还是没有收到对方的回应，则丢弃该 TCP 连接。</p>
<h2 id="PING-的过程-实现"><a href="#PING-的过程-实现" class="headerlink" title="PING 的过程/实现"></a>PING 的过程/实现</h2><hr>
<p><a target="_blank" rel="noopener" href="https://blog.51cto.com/wanicy/335207">https://blog.51cto.com/wanicy/335207</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://wenwenhuan.gitee.io/2021/03/14/%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B8%80%E8%AE%B0%E5%BD%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="温文焕">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wenhuan Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/03/14/%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B8%80%E8%AE%B0%E5%BD%95/" class="post-title-link" itemprop="url">一份Java面试题记录</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-03-14 01:44:48" itemprop="dateCreated datePublished" datetime="2021-03-14T01:44:48+08:00">2021-03-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2021-04-19 23:43:52" itemprop="dateModified" datetime="2021-04-19T23:43:52+08:00">2021-04-19</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="一、int和Integer有什么区别？"><a href="#一、int和Integer有什么区别？" class="headerlink" title="一、int和Integer有什么区别？"></a>一、int和Integer有什么区别？</h3><h4 id="1-Java两种数据类型分类"><a href="#1-Java两种数据类型分类" class="headerlink" title="1.Java两种数据类型分类"></a>1.Java两种数据类型分类</h4><p>为了编程的方便还是引入了基本数据类型，但是为了能够将这些基本数据类型当成对象操作，Java为每 一个基本数据类型都引入了对应的包装类型（wrapper class），int的包装类就是Integer，从Java 5开始引入了自动装箱/拆箱机制，使得二者可以相互转换。</p>
<p>（1）基本数据类型，分为boolean、byte、int、char、long、short、double、float；<br>（2）引用数据类型 ，分为数组、类、接口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">基本数据类型: <span class="keyword">boolean</span>，<span class="keyword">char</span>，<span class="keyword">byte</span>，<span class="keyword">short</span>，<span class="keyword">int</span>，<span class="keyword">long</span>，<span class="keyword">float</span>，<span class="keyword">double</span></span><br><span class="line">封装类类型：Boolean，Character，Byte，Short，Integer，Long，Float，Double</span><br></pre></td></tr></table></figure>

<h4 id="2-int与Integer的基本使用对比"><a href="#2-int与Integer的基本使用对比" class="headerlink" title="2.int与Integer的基本使用对比"></a>2.int与Integer的基本使用对比</h4><ul>
<li>Integer是int的包装类；int是基本数据类型；</li>
<li>Integer变量必须实例化后才能使用；int变量不需要；</li>
<li>Integer实际是对象的引用，指向此new的Integer对象；int是直接存储数据值 ；</li>
<li>Integer的默认值是null；int的默认值是0。</li>
</ul>
<h4 id="int与Integer的深入对比"><a href="#int与Integer的深入对比" class="headerlink" title="int与Integer的深入对比"></a>int与Integer的深入对比</h4><p>（1）由于Integer变量实际上是对一个Integer对象的引用，所以两个通过new生成的Integer变量永远是不相等的（<strong>因为new生成的是两个对象，其内存地址不同</strong>）。</p>
<p>（2）Integer变量和int变量比较时，只要两个变量的值是向等的，则结果为true（因为<strong>包装类Integer和基本数据类型int比较时，java会自动拆包装为int，然后进行比较，实际上就变为两个int变量的比较</strong>）</p>
<p>（3）非new生成的Integer变量和new Integer()生成的变量比较时，结果为false。因为<strong>非new生成的Integer变量指向的是静态常量池中cache数组中存储的指向了堆中的Integer对象，而new Integer()生成的变量指向堆中新建的对象，两者在内存中的对象引用（地址）不同</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer i = <span class="keyword">new</span> Integer(<span class="number">100</span>);</span><br><span class="line">Integer j = <span class="number">100</span>;</span><br><span class="line">System.out.print(i == j); <span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<h3 id="二、String和StringBuffer的区别"><a href="#二、String和StringBuffer的区别" class="headerlink" title="二、String和StringBuffer的区别"></a>二、String和StringBuffer的区别</h3><h4 id="什么是StringBuffer？"><a href="#什么是StringBuffer？" class="headerlink" title="什么是StringBuffer？"></a>什么是StringBuffer？</h4><blockquote>
<p>线程安全的可变字符序列。一个类似于 <a target="_blank" rel="noopener" href="https://tool.oschina.net/uploads/apidocs/jdk-zh/java/lang/String.html"><code>String</code></a> 的字符串缓冲区，但不能修改。虽然在任意时间点上它都包含某种特定的字符序列，但通过某些方法调用可以改变该序列的长度和内容。</p>
</blockquote>
<blockquote>
<p>可将字符串缓冲区安全地用于多个线程。可以在必要时对这些方法进行同步，因此任意特定实例上的所有操作就好像是以串行顺序发生的，该顺序与所涉及的每个线程进行的方法调用顺序一致。</p>
</blockquote>
<blockquote>
<p><code>StringBuffer</code> 上的主要操作是 <code>append</code> 和 <code>insert</code> 方法，可重载这些方法，以接受任意类型的数据。每个方法都能有效地将给定的数据转换成字符串，然后将该字符串的字符追加或插入到字符串缓冲区中。<code>append</code> 方法始终将这些字符添加到缓冲区的末端；而 <code>insert</code> 方法则在指定的点添加字符。</p>
</blockquote>
<blockquote>
<p>通常，如果 sb 引用 <code>StringBuilder</code> 的一个实例，则 <code>sb.append(x)</code> 和 <code>sb.insert(sb.length(), x)</code> 具有相同的效果。</p>
</blockquote>
<blockquote>
<p>当发生与源序列有关的操作（如源序列中的追加或插入操作）时，该类只在执行此操作的字符串缓冲区上而不是在源上实现同步。</p>
</blockquote>
<blockquote>
<p>从 JDK 5 开始，为该类补充了一个单个线程使用的等价类，即 <a target="_blank" rel="noopener" href="https://tool.oschina.net/uploads/apidocs/jdk-zh/java/lang/StringBuilder.html"><code>StringBuilder</code></a>。与该类相比，通常应该优先使用 <code>StringBuilder</code> 类，因为它支持所有相同的操作，但由于它不执行同步，所以速度更快。</p>
</blockquote>
<blockquote>
<p>将 <code>StringBuilder</code> 的实例用于多个线程是不安全的。如果需要这样的同步，则建议使用 <a target="_blank" rel="noopener" href="https://tool.oschina.net/uploads/apidocs/jdk-zh/java/lang/StringBuffer.html"><code>StringBuffer</code></a>。</p>
</blockquote>
<blockquote>
<p>Java 语言提供对字符串串联符号（”+”）以及将其他对象转换为字符串的特殊支持。字符串串联是通过 <code>StringBuilder</code>（或 <code>StringBuffer</code>）类及其 <code>append</code> 方法实现的。字符串转换是通过 <code>toString</code> 方法实现的，该方法由 <code>Object</code> 类定义，并可被 Java 中的所有类继承。</p>
</blockquote>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>简单地说，就是一个变量和常量的关系。StringBuffer对象的内容可以修改；而String对象一旦产生后就不可以被修改，重新赋值其实是两个对象。<br>StringBuffer的内部实现方式和String不同，<strong>StringBuffer在进行字符串处理时，不生成新的对象，在内存使用上要优于String类。</strong>所以在实际使用时，如果经常需要对一个字符串进行修改，例如插入、删除等操作，使用StringBuffer要更加适合一些。<br>String:在String类中没有用来改变已有字符串中的某个字符的方法，由于不能改变一个java字符串中的某个单独字符，所以在JDK文档中称String类的对象是不可改变的。然而，不可改变的字符串具有一个很大的优点:编译器可以把字符串设为共享的。<br>StringBuffer:<strong>StringBuffer类属于一种辅助类，可预先分配指定长度的内存块建立一个字符串缓冲区。</strong>这样使用StringBuffer类的append方法追加字符 比 String使用 + 操作符添加字符到一个已经存在的字符串后面有效率得多。因为使用 + 操作符每一次将字符添加到一个字符串中去时，字符串对象都需要寻找一个新的内存空间来容纳更大的字符串，这无凝是一个非常消耗时间的操作。添加多个字符也就意味着要一次又一次的对字符串重新分配内存。使用StringBuffer类就避免了这个问题。<br><strong>StringBuffer是线程安全的</strong>，在多线程程序中也可以很方便的进行使用，但是程序的执行效率相对来说就要稍微慢一些。</p>
<ol>
<li> StringBuffer在进行字符串处理时，不生成新的对象，在内存使用优于String类。</li>
<li>StringBuffer可预先分配指定长度的内存块建立一个字符串缓冲区。</li>
<li>StringBuffer是线程安全的。</li>
</ol>
<h3 id="三、运行时异常与一般异常有何区别"><a href="#三、运行时异常与一般异常有何区别" class="headerlink" title="三、运行时异常与一般异常有何区别"></a>三、运行时异常与一般异常有何区别</h3><h4 id="异常和错误（Exception-amp-Error）"><a href="#异常和错误（Exception-amp-Error）" class="headerlink" title="异常和错误（Exception&amp;Error）"></a>异常和错误（Exception&amp;Error）</h4><img src="/2021/03/14/%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B8%80%E8%AE%B0%E5%BD%95/Exception&Error.png" class="" title="img">

<p>Throwable： 有两个重要的子类：<strong>Exception（异常）和 Error（错误）</strong>，二者都是 Java 异常处理的重要子类，各自都包含大量子类。</p>
<p>Error（错误）:</p>
<p>　　是<strong>程序无法处理的错误</strong>，表示运行应用程序中较严重问题。<strong>大多数错误与代码编写者执行的操作无关</strong>，而表示代码运行时 JVM（Java 虚拟机）出现的问题。例如，Java虚拟机运行错误（Virtual MachineError），当 JVM 不再有继续执行操作所需的内存资源时，将出现 OutOfMemoryError。这些异常发生时，Java虚拟机（JVM）一般会选择线程终止。</p>
<p>Exception（异常）:</p>
<p>　　是<strong>程序本身可以处理的异常。</strong></p>
<p>Exception可以分为checked exceptions和unchecked exceptions：</p>
<ol>
<li>unchecked exceptions（<strong>运行时异常</strong>）都是RuntimeException类及其子类异常，就是我们在开发中测试功能时程序终止，控制台出现的异常，比如：</li>
</ol>
<ul>
<li>NullPointerException(空指针异常)、</li>
<li>IndexOutOfBoundsException(下标越界异常)</li>
<li>ClassCastException(类转换异常)</li>
<li>ArrayStoreException(数据存储异常，操作数组时类型不一致)</li>
<li>IO操作的BufferOverflowException异常</li>
</ul>
<ol start="2">
<li>checked exceptions 非运行时异常 （编译异常）：是RuntimeException以外的异常，类型上都属于Exception类及其子类。从程序语法角度讲是必须进行处理的异常，如果不处理，程序就不能编译通过。如IOException、SQLException等以及用户自定义的Exception异常，一般情况下不自定义检查异常。<br>通俗的话说就是在写代码时出现红线，需要try catch或者throws时出现的异常。</li>
</ol>
<p><strong>1、运行时异常与一般异常有何异同？</strong></p>
<p>异常表示程序运行过程中可能出现的非正常状态，运行时异常表示虚拟机的通常操作中可能遇到的异常，是一种常见运行错误。java编译器要求方法必须声明抛出可能发生的非运行时异常，但是并不要求必须声明抛出未被捕获的运行时异常。</p>
<p>　　<strong>理解：</strong></p>
<p>　　<u>运行时异常，我们<strong>可以不处理</strong>。当出现这样的异常时，<strong>总是由虚拟机接管</strong>。</u>比如：我们从来没有人去处理过 NullPointerException 异常，它就是运行时异常，并且，这种异常还是最常见的异常之一。RuntimeException 体系包括<strong>错误的类型转换、数组越界访问和试图访问空指针</strong>等等。处理 RuntimeException 的原则是：假如出现 RuntimeException，那么一定是程序员的错误，例如，可以通过检查数组小标和数组边界来避免越界访问异常。</p>
<p>　　一般异常：<u>定义方法时<strong>必须声明</strong>所有可能会抛出的checked exception</u>；在调用这个方法时，必须捕获它的checked exception，不然就得把它的exception传递下去；checked exception是从java.lang.Exception类衍生出来的。</p>
<p><strong>2、error和exception有什么区别?</strong></p>
<p>　　error 是<strong>程序无法处理的错误</strong>。比如说内存溢出。<strong>不可能指望程序能处理这样的情况</strong>。 <strong>exception 表示一种设计或实现问题</strong>。也就是说，它表示如果程序运行正常，从不会发生的情况。</p>
<p><strong>3.Java中的异常处理机制的简单原理和应用</strong></p>
<p>　　异常是指java程序运行时（非编译）所发生的非正常情况或错误，与现实生活中的事件很相似，现实生活中的事件可以包含事件发生的时间、地点、人物、情节等信息，可以用一个对象来表示，Java使用面向对象的方式来处理异常，它把程序中发生的每个异常也都分别封装到一个对象来表示的，该对象中包含有异常的信息。</p>
<p>　　Java对异常进行了分类，不同类型的异常分别用不同的Java类来表示，所有异常的根类为java.lang.Throwable，Throwable下面又派生了两个子类：Error和Exception,Error表示应用程序本身无法克服和恢复的一种严重问题，程序只有死的份了，例如，说内存溢出和线程死锁等系统问题。Exception表示程序表示程序还能够克服和恢复的一种严重问题，其中又分为系统异常和普通异常，系统异常是软件本身缺陷所导致的问题，也就是软件开发人员考虑不周所导致的问题，软件使用者无法克服和恢复这种问题，但在这种问题下还可以让软件系统继续运行或者让软件死掉，例如，数组脚本越界（ArrayIndexOutOfBoundsException）、空指针异常（NullPointerException）、类转换异常（ClassCastException）；普通异常是运行环境的变化或异常所导致的问题，是用户能够克服的问题，例如，网络断线，硬盘空间不够，发生这样的异常后，程序不应该死掉。</p>
<p>　　java为系统异常和普通异常提供了不同的解决方案，编译器强制普通异常必须try···catch处理或用throws声明继续抛给上层调用方法处理，所以普通异常也称为checked异常，而系统异常可以处理也可以不处理，所以，编译器不强制用try…catch处理或用throws声明，所以系统异常也称为unchecked异常。</p>
<h3 id="四、final和finally的区别"><a href="#四、final和finally的区别" class="headerlink" title="四、final和finally的区别"></a>四、final和finally的区别</h3><ol>
<li>final修饰符（关键字）。<strong>被final修饰的类不能被其他子类继承。</strong>因此一个类不能既被abstract声明，又被final声明。<strong>将变量或方法声明为final，可以保证他们在使用的过程中不被修改。</strong>被声明为final的变量必须在声明时给出变量的初始值，而在以后的引用中只能读取。<strong>被final声明的方法也同样只能使用，即不能方法重写。</strong></li>
<li><strong>finally是在异常处理时提供finally块来执行任何清除操作。不管有没有异常被抛出、捕获，finally块都会被执行。</strong>try块中的内容是在无异常时执行到结束。catch块中的内容，是在try块内容发生catch所声明的异常时，跳转到catch块中执行。finally块则是无论异常是否发生，都会执行finally块的内容，所以在代码逻辑中有需要无论发生什么都必须执行的代码，就可以放在finally块中。</li>
</ol>
<h3 id="五、abstract-class和interface有什么区别"><a href="#五、abstract-class和interface有什么区别" class="headerlink" title="五、abstract class和interface有什么区别"></a>五、abstract class和interface有什么区别</h3><h4 id="抽象类是什么？"><a href="#抽象类是什么？" class="headerlink" title="抽象类是什么？"></a>抽象类是什么？</h4><p>本文中的抽象类表示的是一个抽象体</p>
<ul>
<li>在面向对象的概念中，所有的对象都是通过类来描绘的，但是并不是所有的类都是用来描绘对象的，<strong>如果一个类中没有包含足够的信息来描绘一个具体的对象，这样的类就是抽象类。</strong></li>
<li>抽象类的定义<br>是对一系列看上去不同，但是本质上相同的具体概念的抽象，往往用来表征我们在对问题进行分析、设计中得出的抽象概念</li>
<li>它和具体类的核心区别是，抽象类不能创建对象(比如，不能使用new Shape())，而具体类可以。</li>
<li>一个类在继承抽象类后，必须实现抽象类中定义的所有抽象方法，除非它自己也声明为抽象类。</li>
</ul>
<h4 id="为什么要有抽象类？"><a href="#为什么要有抽象类？" class="headerlink" title="为什么要有抽象类？"></a>为什么要有抽象类？</h4><ul>
<li>待总结</li>
</ul>
<h4 id="抽象类（abstract-class）"><a href="#抽象类（abstract-class）" class="headerlink" title="抽象类（abstract class）"></a>抽象类（abstract class）</h4><ul>
<li><p>定义：包含抽象方法的的类是abstract class</p>
<blockquote>
<p>用abstract关键字修饰</p>
</blockquote>
</li>
<li><p>作用：abstractclass是为了把相同的东西提取出来,<strong>即重用</strong></p>
</li>
<li><p>使用abstractclass语法规定</p>
</li>
</ul>
<table>
<thead>
<tr>
<th align="left">语法</th>
<th align="center">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="left">抽象类定义用abstract关键字修饰</td>
<td align="center">要通过子类进行实例化</td>
</tr>
<tr>
<td align="left">抽象类是不能被实例化的</td>
<td align="center">要通过子类进行实例化</td>
</tr>
<tr>
<td align="left"><strong>子类必须重写父类的所有抽象方法</strong></td>
<td align="center">抽象方法：声明但却未被实现的方法，用abstract关键字修饰</td>
</tr>
<tr>
<td align="left">含有抽象方法的类一定是抽象类，但是抽象类不一定含有抽象方法</td>
<td align="center">无</td>
</tr>
<tr>
<td align="left">抽象类是用来被它的子类继承的</td>
<td align="center"><strong>关键字extends</strong></td>
</tr>
</tbody></table>
<h4 id="Interface"><a href="#Interface" class="headerlink" title="Interface"></a>Interface</h4><ul>
<li><p>定义：比abstract class更加抽象，是一种特殊的abstract class</p>
<blockquote>
<p>用Interface关键字修饰</p>
</blockquote>
</li>
<li><p>作用：Interface是为了把程序模块进行固化的契约,是<strong>为了降低偶合</strong></p>
</li>
<li><p>使用Interface的语法规定</p>
</li>
</ul>
<table>
<thead>
<tr>
<th align="left">语法</th>
<th align="center">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="left">接口定义用Interface关键字修饰</td>
<td align="center"></td>
</tr>
<tr>
<td align="left">接口中的所有方法都是抽象的</td>
<td align="center"><strong>可以用abstract修饰，也可以省略</strong></td>
</tr>
<tr>
<td align="left">接口中的方法<strong>必须是用public修饰，或不写</strong></td>
<td align="center">但是不能被其他修饰符修饰</td>
</tr>
<tr>
<td align="left">接口中的属性<strong>必须是全局常量</strong></td>
<td align="center"><strong>public static final修饰</strong></td>
</tr>
<tr>
<td align="left">抽象类是用来被它的子类实现的</td>
<td align="center"><strong>关键字Implements</strong></td>
</tr>
<tr>
<td align="left">接口不能被实例化</td>
<td align="center">无</td>
</tr>
<tr>
<td align="left"><strong>子类实现接口时需要实现接口中的所有方法</strong></td>
<td align="center">若有一个未不实现，该子类就是抽象类abstractclass</td>
</tr>
</tbody></table>
<h4 id="二者的相同点"><a href="#二者的相同点" class="headerlink" title="二者的相同点"></a>二者的相同点</h4><p>都不能被实例化</p>
<h4 id="二者的区别"><a href="#二者的区别" class="headerlink" title="二者的区别"></a>二者的区别</h4><table>
<thead>
<tr>
<th align="left">类型</th>
<th align="center">abstract class</th>
<th align="center">Interface</th>
</tr>
</thead>
<tbody><tr>
<td align="left">定义</td>
<td align="center">abstract class关键字</td>
<td align="center">Interface关键字</td>
</tr>
<tr>
<td align="left">继承</td>
<td align="center"><strong>子类只可以继承一个抽象类</strong></td>
<td align="center"><strong>接口只可以继承接口（一个或多个）；子类可以实现多个接口</strong></td>
</tr>
<tr>
<td align="left">访问修饰符</td>
<td align="center">抽象方法可以有<strong>public</strong>、<strong>protected</strong>和<strong>default</strong>这些修饰符</td>
<td align="center">接口方法默认修饰符是<strong>public</strong>。你不可以使用其它修饰符</td>
</tr>
<tr>
<td align="left">方法实现</td>
<td align="center">可定义构造方法，<strong>可以有抽象方法和具体方法</strong></td>
<td align="center">接口完全是抽象的，没构造方法，且方法都是抽象的，不存在方法的实现</td>
</tr>
<tr>
<td align="left">实现方式</td>
<td align="center">子类使用<strong>extends</strong>关键字来继承抽象类。如果子类不是抽象类的话，它需要提供抽象类中所有声明的方法的实现</td>
<td align="center">子类使用关键字<strong>implements</strong>来实现接口。它需要提供接口中所有声明的方法的实现</td>
</tr>
<tr>
<td align="left">作用</td>
<td align="center">把相同的东西提取出来,<strong>即重用</strong></td>
<td align="center">为了把程序模块进行固化的契约,是<strong>为了降低偶合</strong></td>
</tr>
</tbody></table>
<ol>
<li>抽象类中抽象方法的访问权限可以是public、protectedl；接口只能是public</li>
<li>抽象类中可以有非抽象方法；接口中的方法都是抽象方法</li>
<li>抽象类中可以定义普通成员变量；接口中不能定义普通成员变量</li>
<li>抽象类和接口都能定义静态成员变量，抽象类访问权限可以是任意的；但是接口只能是 public static final即常量</li>
<li>抽象类中可以有构造方法；接口中不能有构造方法</li>
<li>一个类只能实现一个抽象类；但一个类可以实现多个接口，接口可以继承多个接口</li>
</ol>
<h3 id="六、数据连接池的工作机制"><a href="#六、数据连接池的工作机制" class="headerlink" title="六、数据连接池的工作机制"></a>六、数据连接池的工作机制</h3><ol>
<li>初始化时建立由最大维持连接数决定数量的连接。</li>
<li>用户申请连接直到达到最大连接数的时候，请求将被添加到等待队列。</li>
<li>用户断开连接后，超过最大维持连接数的连接不会马上销毁，最大等待时间过后才会销毁</li>
<li>对数据库连接的管理能显著影响到整个应用程序的伸缩性和健壮性，影响到程序的性能指标。</li>
</ol>
<h3 id="七、数组有无length-方法，String有无length-方法？"><a href="#七、数组有无length-方法，String有无length-方法？" class="headerlink" title="七、数组有无length()方法，String有无length()方法？"></a>七、数组有无length()方法，String有无length()方法？</h3><p>数组有length属性，String有length()方法。</p>
<h3 id="八、try-里有一个return语句，那么紧跟在try后的finally-里的code什么时候执行？"><a href="#八、try-里有一个return语句，那么紧跟在try后的finally-里的code什么时候执行？" class="headerlink" title="八、try{}里有一个return语句，那么紧跟在try后的finally{}里的code什么时候执行？"></a>八、try{}里有一个return语句，那么紧跟在try后的finally{}里的code什么时候执行？</h3><p>在return前执行</p>
<h3 id="九、当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底时值传递还是引用传递？"><a href="#九、当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底时值传递还是引用传递？" class="headerlink" title="九、当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底时值传递还是引用传递？"></a>九、当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底时值传递还是引用传递？</h3><p>是值传递。Java编程语言只有值传递参数。当一个对象实例作为一个参数被传递到方法中时，参数的值就是该对象的引用一个副本。指向同一个对象,对象的内容可以在被调用的方法中改变，但<strong>对象的引用(不是引用的副本)是永远不会改变的</strong>。</p>
<h3 id="十、当一个线程进入一个对象的一个synchronized方法后，其他线程是否可进入此对象的其他方法？"><a href="#十、当一个线程进入一个对象的一个synchronized方法后，其他线程是否可进入此对象的其他方法？" class="headerlink" title="十、当一个线程进入一个对象的一个synchronized方法后，其他线程是否可进入此对象的其他方法？"></a>十、当一个线程进入一个对象的一个synchronized方法后，其他线程是否可进入此对象的其他方法？</h3><p>不可以</p>
<h3 id="十一、集合类都有哪些？主要方法是？"><a href="#十一、集合类都有哪些？主要方法是？" class="headerlink" title="十一、集合类都有哪些？主要方法是？"></a>十一、集合类都有哪些？主要方法是？</h3>

<p><strong>Set</strong></p>
<p>Set中不能包含重复的元素。</p>
<p><strong>List接口</strong></p>
<p>List是一个有序的集合，可以包含重复的元素。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">add(E e),add(<span class="keyword">int</span> index, E e),contains(Object o),addAll(Collection c),equals(Object o),get(<span class="keyword">int</span> index),indexOf(Object o),</span><br><span class="line">isEmpty(),set(<span class="keyword">int</span> index, E element),remove(<span class="keyword">int</span> index),remove(Object o),size(),toArray()</span><br></pre></td></tr></table></figure>

<p>ArrayList：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ensureCapacity()</span><br></pre></td></tr></table></figure>

<p>LinkList:</p>
<p>除了实现 List 接口外，LinkedList 类还为在列表的开头及结尾 get、remove 和 insert 元素提供了统一的命名方法。这些操作允许将链接列表用作堆栈、队列或双端队列。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">peek(),peekFirst(),	peekLast(),<span class="comment">//获取不移除</span></span><br><span class="line">poll(),pollFirst(),pollLast(),<span class="comment">//获取并移除</span></span><br><span class="line">pop(),push(E e)、、堆栈操作</span><br></pre></td></tr></table></figure>

<p>Vector：</p>
<p>Stack：</p>
<p>通过五个操作对类 <code>Vector</code> 进行了扩展</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">empty(),peek(),pop(),push(E item),search(Object o)</span><br></pre></td></tr></table></figure>

<p><strong>queue</strong></p>
<h3 id="十二、线程的基本概念、基本状态及状态间的关系？"><a href="#十二、线程的基本概念、基本状态及状态间的关系？" class="headerlink" title="十二、线程的基本概念、基本状态及状态间的关系？"></a>十二、线程的基本概念、基本状态及状态间的关系？</h3><p><strong>什么是线程</strong></p>
<p>一个线程是<u>进程的一个顺序执行流</u>。同类的多个线程<u>共享一块内存空间和一组系统资源</u>，线程本身有一个供程序执行时的堆栈。线程在切换时负荷小，因此，线程也被称为轻负荷进程。一个进程中可以包含多个线程。</p>
<p><strong>进程与线程的区别</strong></p>
<p>一个进程至少有一个线程。线程的划分尺度小于进程，使得多线程程序的并发性高。另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。</p>
<p>线程在执行过程中与进程的区别在于每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。</p>
<p>从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操<u>作系统并没有将多个线程看做多个独立的应用来实现进程的调度和管理以及资源分配</u>。</p>
<p><strong>并发原理</strong></p>
<p>多个线程或进程”同时”运行只是我们感官上的一种表现。事实上进程和线程是并发运行的，OS的线程调度机制将时间划分为很多时间片段（时间片），尽可能均匀分配给正在运行的程序，获取CPU时间片的线程或进程得以被执行，其他则等待。而CPU则在这些进程或线程上来回切换运行。微观上所有进程和线程是走走停停的，宏观上都在运行，这种都运行的现象叫并发，但是不是绝对意义上的“同时发生”。</p>
<p><strong>线程状态</strong></p>
<p><strong>1.新建</strong></p>
<p>用new语句创建的线程对象处于新建状态，此时它和其他java对象一样，仅被分配了内存。</p>
<p><strong>2.等待</strong></p>
<p>当线程在new之后，并且在调用start方法前，线程处于等待状态。</p>
<p><strong>3.就绪</strong></p>
<p>当一个线程对象创建后，其他线程调用它的start()方法，该线程就进入就绪状态。处于这个状态的线程<u>位于Java虚拟机的可运行池中</u>，等待cpu的使用权。</p>
<p><strong>4.运行状态</strong></p>
<p>处于这个状态的线程占用CPU，执行程序代码。在并发运行环境中，如果计算机只有一个CPU，那么任何时刻只会有一个线程处于这个状态。</p>
<p><u>只有处于就绪状态的线程才有机会转到运行状态。</u></p>
<p><strong>5.阻塞状态</strong></p>
<p>阻塞状态是指线程因为某些原因放弃CPU，暂时停止运行。当线程处于阻塞状态时，Java虚拟机不会给线程分配CPU，直到线程重新进入就绪状态，它才会有机会获得运行状态。</p>
<p><strong>阻塞状态分为三种:</strong></p>
<p>1、等待阻塞:运行的线程执行wait（）方法，JVM会把该线程放入等待池中。</p>
<p>2、同步阻塞:运行的线程在获取对象同步锁时，若该同步锁被别的线程占用，则JVM会把线程放入锁池中。</p>
<p>3、其他阻塞:运行的线程执行Sleep（）方法，或者发出I/O请求时，JVM会把线程设为阻塞状态。当Sleep（）状态超时、或者I/O处理完毕时，线程重新转入就绪状态。</p>
<p><strong>6.死亡状态</strong></p>
<p>当线程执行完run()方法中的代码，或者遇到了未捕获的异常，就会退出run()方法，此时就进入死亡状态，该线程结束生命周期。</p>
<h3 id="十三、java写一段代码读取C-test-txt文件"><a href="#十三、java写一段代码读取C-test-txt文件" class="headerlink" title="十三、java写一段代码读取C:\test.txt文件"></a>十三、java写一段代码读取C:\test.txt文件</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.Files;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.Path;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.Paths;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Path path = Paths.get(<span class="string">&quot;C:/test.txt&quot;</span>);</span><br><span class="line">        <span class="keyword">byte</span>[] data = Files.readAllBytes(path);</span><br><span class="line">        String result = <span class="keyword">new</span> String(data, <span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>问题整理：</p>
<ol>
<li><p>了解path类</p>
<p><strong>Path用于来表示文件路径和文件</strong>。</p>
<p>创建path对象的常用方式,要注意异常的处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.以当前路径创建Path对象</span></span><br><span class="line">String filePath = <span class="string">&quot;E:\\tempCSDN\\Paths&quot;</span>;</span><br><span class="line">Path path = Paths.get(filePath);</span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line">     <span class="keyword">if</span>(!Files.exists(target2))</span><br><span class="line">         Files.createFile(target2);</span><br><span class="line"> &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">     e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>files类</p>
<p>files类被path类取代了</p>
</li>
<li><p>String构造方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">byte</span>[] bytes, String charsetName)</span></span></span><br></pre></td></tr></table></figure>

<p>通过使用指定的charset解码指定的 byte 数组，构造一个新的 <code>String</code>。</p>
</li>
</ol>
<h3 id="十四、List、Map、Set三个接口，存取元素时，各有什么特点？"><a href="#十四、List、Map、Set三个接口，存取元素时，各有什么特点？" class="headerlink" title="十四、List、Map、Set三个接口，存取元素时，各有什么特点？"></a>十四、List、Map、Set三个接口，存取元素时，各有什么特点？</h3><p>List是有序存储，</p>
<p>Map时键值对存储，</p>
<p>Set不允许重复元素</p>
<h3 id="十五、SpringMVC（或Struts）、Spring、Hibernate（或MyBatis）分别是什么，用它有什么好处？谈谈你的理解。"><a href="#十五、SpringMVC（或Struts）、Spring、Hibernate（或MyBatis）分别是什么，用它有什么好处？谈谈你的理解。" class="headerlink" title="十五、SpringMVC（或Struts）、Spring、Hibernate（或MyBatis）分别是什么，用它有什么好处？谈谈你的理解。"></a>十五、SpringMVC（或Struts）、Spring、Hibernate（或MyBatis）分别是什么，用它有什么好处？谈谈你的理解。</h3><p>JavaEE体系结构包括四层，从上到下分别是<strong>应用层、Web层、业务层、持久层</strong>。Struts和SpringMVC是Web层的框架，Spring是业务层的框架，Hibernate和MyBatis是持久层的框架。</p>
<p><strong>为什么要使用SpringMVC？</strong></p>
<p>很多应用程序的问题在于处理业务数据的对象和显示业务数据的视图之间存在紧密耦合，通常，更新业务对象的命令都是从视图本身发起的，使视图对任何业务对象更改都有高度敏感性。而且，当多个视图依赖于同一个业务对象时是没有灵活性的。</p>
<p>SpringMVC是一种基于Java，实现了Web MVC设计模式，请求驱动类型的轻量级Web框架，即使用了MVC架构模式的思想，将Web层进行职责解耦。基于请求驱动指的就是使用请求-响应模型，框架的目的就是帮助我们简化开发，SpringMVC也是要简化我们日常Web开发。</p>
<p><strong>MVC设计模式</strong></p>
<p>MVC设计模式的任务是<strong>将包含业务数据的模块与显示模块的视图解耦</strong>。这是怎样发生的？在模型和视图之间引入重定向层可以解决问题。此重定向层是控制器，控制器将接收请求，执行更新模型的操作，然后通知视图关于模型更改的消息。</p>
<p><strong>SpringMVC的核心架构：</strong></p>
<p><img src="C:%5CUsers%5CPowerwenwh%5CDocuments%5CMyBlog%5Csource%5C_posts%5Cimgs%5C%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B8%80%E8%AE%B0%E5%BD%95%5C20190630145911981.png" alt="在这里插入图片描述"></p>
<p>具体流程：</p>
<p>（1）首先浏览器发送请求——&gt;DispatcherServlet，前端控制器收到请求后自己不进行处理，而是委托给其他的解析器进行处理，作为统一访问点，进行全局的流程控制；</p>
<p>（2）DispatcherServlet——&gt;HandlerMapping，处理器映射器将会把请求映射为HandlerExecutionChain对象（包含一个Handler处理器对象、多个HandlerInterceptor拦截器）对象；</p>
<p>（3）DispatcherServlet——&gt;HandlerAdapter，处理器适配器将会把处理器包装为适配器，从而支持多种类型的处理器，即适配器设计模式的应用，从而很容易支持很多类型的处理器；</p>
<p>（4）HandlerAdapter——&gt;调用处理器相应功能处理方法，并返回一个ModelAndView对象（包含模型数据、逻辑视图名）；</p>
<p>（5）ModelAndView对象（Model部分是业务对象返回的模型数据，View部分为逻辑视图名）——&gt; ViewResolver， 视图解析器将把逻辑视图名解析为具体的View；</p>
<p>（6）View——&gt;渲染，View会根据传进来的Model模型数据进行渲染，此处的Model实际是一个Map数据结构；</p>
<p>（7）返回控制权给DispatcherServlet，由DispatcherServlet返回响应给用户，到此一个流程结束。</p>
<p>==待总结==</p>
<h3 id="十六、sql语句"><a href="#十六、sql语句" class="headerlink" title="十六、sql语句"></a>十六、sql语句</h3><h3 id=""><a href="#" class="headerlink" title=""></a><img src="C:%5CUsers%5CPowerwenwh%5CDocuments%5CMyBlog%5Csource%5C_posts%5Cimgs%5C%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B8%80%E8%AE%B0%E5%BD%95%5Cimage-20210321153913927.png" alt="image-20210321153913927"></h3><p><strong>思路：对除了自动编号外的字段进行分组即可筛选出不重复的数据</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> tb_student_score(id <span class="type">int</span>,sid <span class="type">int</span>,name varchar2(<span class="number">20</span>),kid <span class="type">int</span>,kname varchar2(<span class="number">20</span>),score <span class="type">int</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">--插入数据</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_student_score <span class="keyword">values</span>(<span class="number">1</span>,<span class="number">2018001</span>,<span class="string">&#x27;张三&#x27;</span>,<span class="number">0001</span>,<span class="string">&#x27;数学&#x27;</span>,<span class="number">69</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_student_score <span class="keyword">values</span>(<span class="number">2</span>,<span class="number">2018002</span>,<span class="string">&#x27;李四&#x27;</span>,<span class="number">0001</span>,<span class="string">&#x27;数学&#x27;</span>,<span class="number">89</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_student_score <span class="keyword">values</span>(<span class="number">3</span>,<span class="number">2018001</span>,<span class="string">&#x27;张三&#x27;</span>,<span class="number">0001</span>,<span class="string">&#x27;数学&#x27;</span>,<span class="number">69</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_student_score <span class="keyword">values</span>(<span class="number">4</span>,<span class="number">2018002</span>,<span class="string">&#x27;李四&#x27;</span>,<span class="number">0002</span>,<span class="string">&#x27;语文&#x27;</span>,<span class="number">79</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_student_score <span class="keyword">values</span>(<span class="number">5</span>,<span class="number">2018001</span>,<span class="string">&#x27;张三&#x27;</span>,<span class="number">0002</span>,<span class="string">&#x27;语文&#x27;</span>,<span class="number">80</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_student_score <span class="keyword">values</span>(<span class="number">6</span>,<span class="number">2018002</span>,<span class="string">&#x27;李四&#x27;</span>,<span class="number">0002</span>,<span class="string">&#x27;语文&#x27;</span>,<span class="number">79</span>);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">commit</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--查询数据</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_student_score;</span><br><span class="line">ID    SID      NAME  KID    KNAME  SCORE</span><br><span class="line"><span class="number">1</span>    <span class="number">2018001</span>    张三    <span class="number">1</span>    数学    <span class="number">69</span></span><br><span class="line"><span class="number">2</span>    <span class="number">2018002</span>    李四    <span class="number">1</span>    数学    <span class="number">89</span></span><br><span class="line"><span class="number">3</span>    <span class="number">2018001</span>    张三    <span class="number">1</span>    数学    <span class="number">69</span></span><br><span class="line"><span class="number">4</span>    <span class="number">2018002</span>    李四    <span class="number">2</span>    语文    <span class="number">79</span></span><br><span class="line"><span class="number">5</span>    <span class="number">2018001</span>    张三    <span class="number">2</span>    语文    <span class="number">80</span></span><br><span class="line"><span class="number">6</span>    <span class="number">2018002</span>    李四    <span class="number">2</span>    语文    <span class="number">79</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--执行删除SQL语句</span></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> tb_student_score</span><br><span class="line"> <span class="keyword">where</span> id <span class="keyword">not</span> <span class="keyword">in</span> (</span><br><span class="line">                   <span class="keyword">select</span> <span class="built_in">min</span>(id)</span><br><span class="line">                     <span class="keyword">from</span> tb_student_score t</span><br><span class="line">                    <span class="keyword">group</span> <span class="keyword">by</span> t.sid, t.name, t.kid, t.kname, t.score</span><br><span class="line">                  );</span><br><span class="line"><span class="keyword">commit</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--查询数据</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_student_score;</span><br><span class="line">ID    SID        NAME    KID    KNAME        SCORE</span><br><span class="line"><span class="number">1</span>    <span class="number">2018001</span>    张三    <span class="number">1</span>          数学         <span class="number">69</span></span><br><span class="line"><span class="number">2</span>    <span class="number">2018002</span>    李四    <span class="number">1</span>          数学         <span class="number">89</span></span><br><span class="line"><span class="number">4</span>    <span class="number">2018002</span>    李四    <span class="number">2</span>          语文         <span class="number">79</span></span><br><span class="line"><span class="number">5</span>    <span class="number">2018001</span>    张三    <span class="number">2</span>          语文         <span class="number">80</span></span><br></pre></td></tr></table></figure>

<h3 id="十七、一个叫team的表，里面只有一个字段name，一共有4条记录，分别是a，b，c，d，对应四个球队，现在四个球队进行比赛，用一条sql语句显示所有可能的比赛组合。"><a href="#十七、一个叫team的表，里面只有一个字段name，一共有4条记录，分别是a，b，c，d，对应四个球队，现在四个球队进行比赛，用一条sql语句显示所有可能的比赛组合。" class="headerlink" title="十七、一个叫team的表，里面只有一个字段name，一共有4条记录，分别是a，b，c，d，对应四个球队，现在四个球队进行比赛，用一条sql语句显示所有可能的比赛组合。"></a>十七、一个叫team的表，里面只有一个字段name，一共有4条记录，分别是a，b，c，d，对应四个球队，现在四个球队进行比赛，用一条sql语句显示所有可能的比赛组合。</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> team a,team b <span class="keyword">where</span> a.name<span class="operator">&gt;</span>b.name;</span><br></pre></td></tr></table></figure>

<p>由于需求为讲四个球队两两组合，故我们可以考虑相当于两张一样的表进行笛卡尔积多表查询,由上可看到两两组合的所有可能，但是结合实际，组合(a,a),(b,b)……在比赛中是不可能出现的，而(a,b)和(b,a)组合相当于一样。<a target="_blank" rel="noopener" href="http://故需要加where条件a.name/">故需要加where条件a.name</a>&gt;b.name排除以上的情况发生</p>
<h3 id="十八、String的-substring-int-beginIndex-、concat-String-str-方法。"><a href="#十八、String的-substring-int-beginIndex-、concat-String-str-方法。" class="headerlink" title="十八、String的**substring(int beginIndex)、concat**(String str)方法。"></a>十八、String的**<a target="_blank" rel="noopener" href="https://tool.oschina.net/uploads/apidocs/jdk-zh/java/lang/String.html#substring(int)">substring</a><strong>(int beginIndex)、</strong><a target="_blank" rel="noopener" href="https://tool.oschina.net/uploads/apidocs/jdk-zh/java/lang/String.html#concat(java.lang.String)">concat</a>**(<a target="_blank" rel="noopener" href="https://tool.oschina.net/uploads/apidocs/jdk-zh/java/lang/String.html">String</a> str)方法。</h3><p><strong><a target="_blank" rel="noopener" href="https://tool.oschina.net/uploads/apidocs/jdk-zh/java/lang/String.html#substring(int)">substring</a></strong>(int beginIndex)</p>
<p>返回一个新的字符串，它是此字符串的一个子字符串。该子字符串从指定索引处的字符开始，直到此字符串末尾。</p>
<p>示例：</p>
<blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;unhappy&quot;</span>.substring(<span class="number">2</span>) returns <span class="string">&quot;happy&quot;</span></span><br><span class="line"><span class="string">&quot;Harbison&quot;</span>.substring(<span class="number">3</span>) returns <span class="string">&quot;bison&quot;</span></span><br><span class="line"><span class="string">&quot;emptiness&quot;</span>.substring(<span class="number">9</span>) returns <span class="string">&quot;&quot;</span> (an empty string)</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong><a target="_blank" rel="noopener" href="https://tool.oschina.net/uploads/apidocs/jdk-zh/java/lang/String.html#concat(java.lang.String)">concat</a></strong>(<a target="_blank" rel="noopener" href="https://tool.oschina.net/uploads/apidocs/jdk-zh/java/lang/String.html">String</a> str)</p>
<p>将指定字符串连接到此字符串的结尾。</p>
<p>如果参数字符串的长度为 <code>0</code>，则返回此 <code>String</code> 对象。否则，创建一个新的 <code>String</code> 对象，用来表示由此 <code>String</code> 对象表示的字符序列和参数字符串表示的字符序列连接而成的字符序列。</p>
<p>示例：</p>
<blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;cares&quot;</span>.concat(<span class="string">&quot;s&quot;</span>) returns <span class="string">&quot;caress&quot;</span></span><br><span class="line"><span class="string">&quot;to&quot;</span>.concat(<span class="string">&quot;get&quot;</span>).concat(<span class="string">&quot;her&quot;</span>) returns <span class="string">&quot;together&quot;</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="十九、Javascript相关"><a href="#十九、Javascript相关" class="headerlink" title="十九、Javascript相关"></a>十九、Javascript相关</h3><p>以下哪一条Javascript语句会产生运行错误？</p>
<ul>
<li><p>```<br>var obj=( );//错误</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- &#96;&#96;&#96;</span><br><span class="line">  var obj&#x3D;[ ];&#x2F;&#x2F;声明obj为数组对象</span><br></pre></td></tr></table></figure></li>
<li><p>```<br>var obj={ };//声明obj为对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- &#96;&#96;&#96;</span><br><span class="line">  var obj&#x3D;&#x2F; &#x2F;;&#x2F;&#x2F;声明obj为正则对象</span><br></pre></td></tr></table></figure></li>
</ul>
<p>foo对象有att属性，那么获取att属性的值，以下哪些做法是可以的：（javascript）</p>
<p>javascrit获取对象属性的方法有两种：分别是采用’.’和[]。所以ADE都正确</p>
<ul>
<li><p>```<br>foo[“att”]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- &#96;&#96;&#96;</span><br><span class="line">  foo(&quot;att&quot;)</span><br></pre></td></tr></table></figure></li>
<li><p>```<br>foo{“att”}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- &#96;&#96;&#96;</span><br><span class="line">  foo.att</span><br></pre></td></tr></table></figure></li>
<li><p>```<br>foo[[“a”,”t”,”t”].join(“”)]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 二十、html相关</span><br><span class="line"></span><br><span class="line">在不指定特殊属性的情况下，以下标签可以手动输入文本的是B</span><br><span class="line"></span><br><span class="line">&#96;&lt;textarea&gt;&#96; 标签定义多行的文本输入控件。</span><br><span class="line"></span><br><span class="line">&#96;&lt;input type&#x3D;&quot;hidden&quot;&#x2F;&gt;&#96;  </span><br><span class="line">&#96;&lt;textarea&gt;&lt;&#x2F;textarea&gt;&#96;  </span><br><span class="line">&#96;&lt;div&gt;&lt;&#x2F;div&gt;&#96;  </span><br><span class="line">&#96;&lt;a&gt;&lt;&#x2F;a&gt;&#96;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">table标签</span><br><span class="line"></span><br><span class="line">**定义和用法**</span><br><span class="line"></span><br><span class="line">简单的 HTML 表格由 table 元素以及一个或多个 tr、th 或 td 元素组成。</span><br><span class="line"></span><br><span class="line">**tr 元素定义表格行，th 元素定义表头，td 元素定义表格单元。**</span><br><span class="line"></span><br><span class="line">更复杂的 HTML 表格也可能包括 caption、col、colgroup、thead、tfoot 以及 tbody 元素。</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;html</span><br><span class="line">&lt;p&gt;每个表格由 table 标签开始。&lt;&#x2F;p&gt;</span><br><span class="line">&lt;p&gt;每个表格行由 tr 标签开始。&lt;&#x2F;p&gt;</span><br><span class="line">&lt;p&gt;每个表格数据由 td 标签开始。&lt;&#x2F;p&gt;</span><br><span class="line"></span><br><span class="line">&lt;h4&gt;一列：&lt;&#x2F;h4&gt;</span><br><span class="line">&lt;table border&#x3D;&quot;1&quot;&gt;&#x2F;&#x2F;规定表格边框的宽度。</span><br><span class="line">&lt;tr&gt;</span><br><span class="line">  &lt;td&gt;100&lt;&#x2F;td&gt;</span><br><span class="line">&lt;&#x2F;tr&gt;</span><br><span class="line">&lt;&#x2F;table&gt;</span><br><span class="line"></span><br><span class="line">&lt;h4&gt;一行三列：&lt;&#x2F;h4&gt;</span><br><span class="line">&lt;table border&#x3D;&quot;1&quot;&gt;</span><br><span class="line">&lt;tr&gt;</span><br><span class="line">  &lt;td&gt;100&lt;&#x2F;td&gt;</span><br><span class="line">  &lt;td&gt;200&lt;&#x2F;td&gt;</span><br><span class="line">  &lt;td&gt;300&lt;&#x2F;td&gt;</span><br><span class="line">&lt;&#x2F;tr&gt;</span><br><span class="line">&lt;&#x2F;table&gt;</span><br><span class="line"></span><br><span class="line">&lt;h4&gt;两行三列：&lt;&#x2F;h4&gt;</span><br><span class="line">&lt;table border&#x3D;&quot;1&quot;&gt;</span><br><span class="line">&lt;tr&gt;</span><br><span class="line">  &lt;td&gt;100&lt;&#x2F;td&gt;</span><br><span class="line">  &lt;td&gt;200&lt;&#x2F;td&gt;</span><br><span class="line">  &lt;td&gt;300&lt;&#x2F;td&gt;</span><br><span class="line">&lt;&#x2F;tr&gt;</span><br><span class="line">&lt;tr&gt;</span><br><span class="line">  &lt;td&gt;400&lt;&#x2F;td&gt;</span><br><span class="line">  &lt;td&gt;500&lt;&#x2F;td&gt;</span><br><span class="line">  &lt;td&gt;600&lt;&#x2F;td&gt;</span><br><span class="line">&lt;&#x2F;tr&gt;</span><br><span class="line">&lt;&#x2F;table&gt;</span><br></pre></td></tr></table></figure></li>
</ul>


<h3 id="二十一、请你根据任意一个外卖app的使用经历，画出你所理解的外卖的流程。请画出主要的环节，以及每个环节涉及的角色。（比如用户、商家等）"><a href="#二十一、请你根据任意一个外卖app的使用经历，画出你所理解的外卖的流程。请画出主要的环节，以及每个环节涉及的角色。（比如用户、商家等）" class="headerlink" title="二十一、请你根据任意一个外卖app的使用经历，画出你所理解的外卖的流程。请画出主要的环节，以及每个环节涉及的角色。（比如用户、商家等）"></a>二十一、请你根据任意一个外卖app的使用经历，画出你所理解的外卖的流程。请画出主要的环节，以及每个环节涉及的角色。（比如用户、商家等）</h3>

<p>二十二、图形题解题技巧</p>
<ol>
<li><p>三角形或圆心类：找周围的数字与圆心数字关系</p>
<p>例子：</p>
</li>
<li><p>图形题目：观察点的数目，线的数目（直线、曲线、线头），笔画，角（有无，角度，数目），面（封闭区域数，部分数），对称（对称轴）</p>
</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://wenwenhuan.gitee.io/2021/03/07/Java%E4%B8%AD%E5%B8%83%E5%B0%94%E7%B1%BB%E5%9E%8B%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E4%BD%BF%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="温文焕">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wenhuan Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/03/07/Java%E4%B8%AD%E5%B8%83%E5%B0%94%E7%B1%BB%E5%9E%8B%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E4%BD%BF%E7%94%A8/" class="post-title-link" itemprop="url">Java中布尔类型运算符的使用</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-03-07 22:08:32 / 修改时间：15:18:32" itemprop="dateCreated datePublished" datetime="2021-03-07T22:08:32+08:00">2021-03-07</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="amp-，-与-的使用"><a href="#amp-，-与-的使用" class="headerlink" title="&amp;=，|=与^=的使用"></a>&amp;=，|=与^=的使用</h2><p>1.&amp;=<br>true &amp;= true ==&gt; true<br>true &amp;= false ==&gt; false<br>false &amp;= true ==&gt; false<br>false &amp;= false ==&gt; false</p>
<p>2.|=<br>true |= true ==&gt; true<br>true |= false ==&gt; true<br>false |= true ==&gt; true<br>false |= false ==&gt; false</p>
<p>3.^=(异或)<br>相同为假，不同为真<br>(男性和女性能生出孩子，否则就不行。)<br>true ^= true ==&gt; false<br>true ^= false ==&gt; true<br>false ^= true ==&gt; true<br>false ^= false ==&gt; false</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://wenwenhuan.gitee.io/2021/03/07/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="温文焕">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wenhuan Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/03/07/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D/" class="post-title-link" itemprop="url">正则表达式匹配</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-03-07 10:00:00 / 修改时间：15:50:58" itemprop="dateCreated datePublished" datetime="2021-03-07T10:00:00+08:00">2021-03-07</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="正则表达式匹配"><a href="#正则表达式匹配" class="headerlink" title="正则表达式匹配"></a>正则表达式匹配</h2><p>请实现一个函数用来匹配包含’. ‘和’※’的正则表达式。模式中的字符’.’表示任意一个字符，而”※”表示它前面的字符可以出现任意次（含0次）。在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串”aaa”与模式”a.a”和”ab<em>ac</em>a”匹配，但与”aa.a”和”ab*a”均不匹配。</p>
<h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><p>本题的思路选用<strong>动态规划</strong>的思路解题，构造动态规划矩阵来推导结果。对我来说难点在如何分，分几种情况考虑。并且※可以代表没有和无数次，用一般的方法很难用编程语言描述。</p>
<blockquote>
<p>假设主串为 A，模式串为 B 从最后一步出发，需要关注最后进来的字符。假设 A 的长度为 n ，B 的长度为 m ，关注正则表达式 B 的最后一个字符是谁，它有三种可能，正常字符、∗ 和 .（点），那针对这三种情况讨论即可，如下：</p>
<ol>
<li><p>如果 B 的最后一个字符是正常字符，那就是看 A[n-1] 是否等于 B[m-1]，相等则看 A_{0..n-2}与 B_{0..m-2}，不等则是不能匹配，这就是子问题。</p>
</li>
<li><p>如果 B 的最后一个字符是.，它能匹配任意字符，直接看 A_{0..n-2}与 B_{0..m-2}</p>
</li>
<li><p>如果 B 的最后一个字符是∗它代表 B[m-2]=c 可以重复0次或多次，它们是一个整体 c∗4</p>
<ul>
<li>情况一：A[n-1] 是 0 个 c，B 最后两个字符废了，能否匹配取决于 A_{0..n-1}和 B_{0..m-3}是否匹配</li>
<li>情况二：A[n-1]是多个 c 中的最后一个（这种情况必须 A[n-1]=c或者 c=’.’），所以 A 匹配完往前挪一个，B 继续匹配，因为可以匹配多个，继续看 A_{0..n-2}和 B_{0..m-1}是否匹配。</li>
</ul>
<h3 id="转移方程"><a href="#转移方程" class="headerlink" title="转移方程"></a>转移方程</h3><p>f[i][j] 代表 A 的前 i 个和 B 的前 j 个能否匹配</p>
<p>对于前面两个情况，可以合并成一种情况 f[i][j] = f[i-1][j-1]</p>
<p>对于第三种情况，对于 c∗ 分为看和不看两种情况</p>
<p>不看：直接砍掉正则串的后面两个， f[i][j] = f[i][j-2]<br>看：正则串不动，主串前移一个，f[i][j] = f[i-1][j]</p>
<h3 id="初始条件"><a href="#初始条件" class="headerlink" title="初始条件"></a>初始条件</h3><p>特判：需要考虑空串空正则</p>
<p>空串和空正则是匹配的，f[0][0] = true<br>空串和非空正则，不能直接定义 true 和 false，必须要计算出来。（比如A= ‘’ ‘’ ,B=a∗b∗c）<br>非空串和空正则必不匹配，f[1][0]=…=f[n][0]=false<br>非空串和非空正则，那肯定是需要计算的了。<br>大体上可以分为空正则和非空正则两种，空正则也是比较好处理的，对非空正则我们肯定需要计算，非空正则的三种情况，前面两种可以合并到一起讨论，第三种情况是单独一种，那么也就是分为当前位置是 ∗ 和不是 ∗ 两种情况了。</p>
<h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><p>我们开数组要开 n+1 ，这样对于空串的处理十分方便。结果就是 f[n][m]</p>
</li>
</ol>
</blockquote>
<p>看完解题思路，觉得这道题的关键是理解和分析出转移方程，也是动态规划的核心。细节方面则是需要考虑空串和空正则。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String A, String B)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = A.length();</span><br><span class="line">        <span class="keyword">int</span> m = B.length();</span><br><span class="line">        <span class="keyword">boolean</span>[][] f = <span class="keyword">new</span> <span class="keyword">boolean</span>[n + <span class="number">1</span>][m + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= m; j++) &#123;</span><br><span class="line">                <span class="comment">//分成空正则和非空正则两种</span></span><br><span class="line">                <span class="keyword">if</span> (j == <span class="number">0</span>) &#123;</span><br><span class="line">                    f[i][j] = i == <span class="number">0</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//非空正则分为两种情况 * 和 非*</span></span><br><span class="line">                    <span class="keyword">if</span> (B.charAt(j - <span class="number">1</span>) != <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; (A.charAt(i - <span class="number">1</span>) == B.charAt(j - <span class="number">1</span>) || B.charAt(j - <span class="number">1</span>) == <span class="string">&#x27;.&#x27;</span>)) &#123;</span><br><span class="line">                            f[i][j] = f[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">//碰到 * 了，分为看和不看两种情况</span></span><br><span class="line">                        <span class="comment">//不看</span></span><br><span class="line">                        <span class="keyword">if</span> (j &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">                            f[i][j] |= f[i][j - <span class="number">2</span>];</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//看</span></span><br><span class="line">                        <span class="keyword">if</span> (i &gt;= <span class="number">1</span> &amp;&amp; j &gt;= <span class="number">2</span> &amp;&amp; (A.charAt(i - <span class="number">1</span>) == B.charAt(j - <span class="number">2</span>) || B.charAt(j - <span class="number">2</span>) == <span class="string">&#x27;.&#x27;</span>)) &#123;</span><br><span class="line">                            f[i][j] |= f[i - <span class="number">1</span>][j];</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[n][m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://wenwenhuan.gitee.io/2021/03/03/Java%E4%B8%AD%E7%9A%84%E9%99%A4%E6%B3%95%E4%BF%9D%E7%95%99%E5%85%A8%E9%83%A8%E5%B0%8F%E6%95%B0%E4%BD%8D/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="温文焕">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wenhuan Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/03/03/Java%E4%B8%AD%E7%9A%84%E9%99%A4%E6%B3%95%E4%BF%9D%E7%95%99%E5%85%A8%E9%83%A8%E5%B0%8F%E6%95%B0%E4%BD%8D/" class="post-title-link" itemprop="url">Java中的除法保留全部小数位</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-03-03 16:08:32" itemprop="dateCreated datePublished" datetime="2021-03-03T16:08:32+08:00">2021-03-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2021-03-04 09:28:16" itemprop="dateModified" datetime="2021-03-04T09:28:16+08:00">2021-03-04</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>情景展示</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> a = <span class="number">1</span>/<span class="number">10</span>;</span><br><span class="line">System.out.println(d);<span class="comment">//0.0</span></span><br></pre></td></tr></table></figure>

<p>用int类型接受也可以</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>/<span class="number">10</span>;</span><br><span class="line">System.out.println(d);<span class="comment">//0</span></span><br></pre></td></tr></table></figure>

<p>没有报错，因为在Java中整数之间 的除法运算，不管小数位有几位，小数是几，都会舍弃，只返回整数位数字。</p>
<p>之所以用double类型接受也可以，是因为double类型的取值要大于int类型，属于向上类型转换，Java会自动转换。使用float或long类型接受也没有问题。</p>
<p>在Java中，运算结果由被运算数的最高数据类型决定。所以想要得到完整的运算结果只需要将其中一个数据类型转换为double类型或float类型，而不是只改变接受运算结果的数据类型。 </p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://wenwenhuan.gitee.io/2021/02/28/Java%E6%8E%A5%E5%8F%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="温文焕">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wenhuan Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/02/28/Java%E6%8E%A5%E5%8F%A3/" class="post-title-link" itemprop="url">Java中的接口</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-02-28 22:08:32 / 修改时间：22:09:04" itemprop="dateCreated datePublished" datetime="2021-02-28T22:08:32+08:00">2021-02-28</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="Java接口"><a href="#Java接口" class="headerlink" title="Java接口"></a>Java接口</h2><h3 id="1、几个问题"><a href="#1、几个问题" class="headerlink" title="1、几个问题"></a>1、几个问题</h3><ol>
<li><p>为什么不直接在类里面写对应的方法, 而要多写1个接口(或抽象类)?</p>
</li>
<li><p>既然接口跟抽象类差不多, 什么情况下要用接口而不是抽象类.</p>
</li>
<li><p>为什么interface叫做接口呢? 跟一般范畴的接口例如usb接口, 显卡接口有什么联系呢?</p>
</li>
</ol>
<h3 id="2、接口是不可以被实例化-但是接口引用可以指向1个实现该接口的对象"><a href="#2、接口是不可以被实例化-但是接口引用可以指向1个实现该接口的对象" class="headerlink" title="2、接口是不可以被实例化, 但是接口引用可以指向1个实现该接口的对象."></a>2、<strong>接口是不可以被实例化, 但是接口引用可以指向1个实现该接口的对象.</strong></h3><p>假如类A impletments 了接口B</p>
<p>那么下面是合法的:</p>
<p><code>B b = new A();</code></p>
<p>也可以把A的对象强制转换为 接口B的对象</p>
<p><code>A a = new A90; B b = (B)a;</code></p>
<p>这个特性是下面内容的前提.</p>
<h3 id="3、接口-或抽象类-的存在是为了多态的实现"><a href="#3、接口-或抽象类-的存在是为了多态的实现" class="headerlink" title="3、接口(或抽象类)的存在是为了多态的实现."></a>3、接口(或抽象类)的存在是为了多态的实现.</h3><p>详细代码用抽象举1个例子：</p>
<p>先定义几个类,</p>
<p>动物(Animal) 抽象类</p>
<p>爬行动物(Reptile) 抽象类  继承动物类</p>
<p>哺乳动物(Mammal) 抽象类 继承动物类</p>
<p>山羊(Goat) 继承哺乳动物类<br>老虎(Tiger)  继承哺乳动物类<br>兔子(Rabbit) 继承哺乳动物类<br>蛇(Snake)   继承爬行动物类</p>
<p>农夫(Farmer)   没有继承任何类 但是农夫可以给Animal喂水(依赖关系)</p>
<h4 id="3-1-Animal类"><a href="#3-1-Animal类" class="headerlink" title="3.1 Animal类"></a>3.1 Animal类</h4><p>这个是抽象类, 显示也没有”动物” 这种实体</p>
<p>类里面包含3个抽象方法.</p>
<ol>
<li><p>静态方法getName()</p>
</li>
<li><p>移动方法move(), 因为动物都能移动.  但是各种动物有不同的移动方法, 例如老虎和山羊会跑着移动, 兔子跳着移动, 蛇会爬着移动.</p>
</li>
</ol>
<p><u>作为抽象基类, 我们不关心继承的实体类是如何移动的, 所以移动方法move()是1个抽象方法.  这个就是多态的思想.</u></p>
<ol start="3">
<li>喝水方法drink(), 同样, 各种动物有各种饮水方法. 这个也是抽象方法.</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    </span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">(String destination)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">drink</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-2-Mammal类"><a href="#3-2-Mammal类" class="headerlink" title="3.2 Mammal类"></a>3.2 Mammal类</h4><p>这个是继承动物类的哺乳动物类, 后面的老虎山羊等都继承自这个类.<br>Mammal类自然继承了Animal类的3个抽象方法, 实体类不再用写其他代码.</p>
<p><code>abstract class Mammal extends Animal&#123;&#125;</code></p>
<h4 id="3-3-Reptile类"><a href="#3-3-Reptile类" class="headerlink" title="3.3 Reptile类"></a>3.3 Reptile类</h4><p>这个是代表爬行动物的抽象类, 同上, 都是继承自Animal类.<br><code>abstract class Reptile extends Animal&#123;&#125;</code></p>
<p>3.4 Tiger类<br><u>老虎类就是1个实体类, 所以它必须重写所有继承自超类的抽象方法</u>, 至于那些方法如何重写, 则取决于老虎类本身.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tiger</span> <span class="keyword">extends</span> <span class="title">Mammal</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String name = <span class="string">&quot;Tiger&quot;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">(String destination)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Goat moved to &quot;</span> + destination + <span class="string">&quot;.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drink</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Goat lower it&#x27;s head and drink.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<p>如上, 老虎的移动方法很普通, 低头喝水.</p>
<h4 id="3-5-Goat类-和-Rabbit类"><a href="#3-5-Goat类-和-Rabbit类" class="headerlink" title="3.5 Goat类 和 Rabbit类"></a>3.5 Goat类 和 Rabbit类</h4><p>这个两个类与Tiger类似, 它们都继承自Mammal这个类.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Goat</span> <span class="keyword">extends</span> <span class="title">Mammal</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String name = <span class="string">&quot;Goat&quot;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">(String destination)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Goat moved to &quot;</span> + destination + <span class="string">&quot;.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drink</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Goat lower it&#x27;s head and drink.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>兔子: 喝水方法有点区别</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rabbit</span> <span class="keyword">extends</span> <span class="title">Mammal</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String name = <span class="string">&quot;Rabbit&quot;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">(String destination)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Rabbit moved to &quot;</span> + destination + <span class="string">&quot;.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drink</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Rabbit put out it&#x27;s tongue and drink.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="3-6-Snake类"><a href="#3-6-Snake类" class="headerlink" title="3.6 Snake类"></a>3.6 Snake类</h4><p>蛇类继承自Reptile(爬行动物)<br>移动方法和喝水方法都跟其他3动物有点区别.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Snake</span> <span class="keyword">extends</span> <span class="title">Reptile</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String name = <span class="string">&quot;Snake&quot;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">(String destination)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Snake crawled to &quot;</span> + destination + <span class="string">&quot;.&quot;</span>);</span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drink</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Snake dived into water and drink.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-7-Farmer-类"><a href="#3-7-Farmer-类" class="headerlink" title="3.7 Farmer 类"></a>3.7 Farmer 类</h4><p>Farmer类不属于 Animal类族, 但是Farmer农夫可以给各种动物, 喂水.</p>
<p>Farmer类有2个关键方法, 一个是<br><code>bringWater(String destination)</code>    –&gt; 把水带到某个地点</p>
<p>另1个就是<code>feedWater()</code>了, </p>
<p>feedWater这个方法分为三步:</p>
<p>首先是农夫带水到饲养室,(<code>bringWater())</code></p>
<p>接着被喂水动物走到饲养室,(<code>move()</code>)</p>
<p>接着动物喝水(<code>drink()</code>)</p>
<p>Farmer可以给老虎喂水, 可以给山羊喂水, 还可以给蛇喂水, 那么feedWater()里的参数类型到底是老虎,山羊还是蛇呢.</p>
<p>实际上<u>因为老虎,山羊, 蛇都继承自Animal这个类, 所以feedWater里的参数类型设为Animal就可以了.</u></p>
<p>Farmer类首先调用bringWater(“饲养室”),<br>至于<u>这个动物是如何走到饲养室和如何喝水的, Farmer类则不用关心.</u></p>
<p><u>因为执行时, Animal超类会根据引用指向的对象类型不同 而 指向不同的被重写的方法.  这个就是多态的意义.</u></p>
<p>代码如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Farmer</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bringWater</span><span class="params">(String destination)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Farmer bring water to &quot;</span> + destination + <span class="string">&quot;.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">feedWater</span><span class="params">(Animal a)</span></span>&#123; <span class="comment">// polymorphism多态性</span></span><br><span class="line">        <span class="keyword">this</span>.bringWater(<span class="string">&quot;Feeding Room&quot;</span>);</span><br><span class="line">        a.move(<span class="string">&quot;Feeding Room&quot;</span>);</span><br><span class="line">        a.drink();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="3-7-执行农夫喂水的代码"><a href="#3-7-执行农夫喂水的代码" class="headerlink" title="3.7 执行农夫喂水的代码."></a>3.7 执行农夫喂水的代码.</h4><p>下面的代码是1个农夫依次喂水给一只老虎, 一只羊, 以及一条蛇</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Farmer fm = <span class="keyword">new</span> Farmer();</span><br><span class="line">        Snake sn = <span class="keyword">new</span> Snake();</span><br><span class="line">        Goat gt = <span class="keyword">new</span> Goat();</span><br><span class="line">        Tiger tg = <span class="keyword">new</span> Tiger();</span><br><span class="line"> </span><br><span class="line">        fm.feedWater(sn);</span><br><span class="line">        fm.feedWater(gt);</span><br><span class="line">        fm.feedWater(tg);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h4 id="3-8总结"><a href="#3-8总结" class="headerlink" title="3.8总结"></a>3.8总结</h4><p>农夫只负责带水过去制定地点, 而不必关心老虎, 蛇, 山羊它们是如何过来的. 它们如何喝水. 这些农夫都不必关心.<br>只需要调用同1个方法<code>feedWater()</code>.  </p>
<p>不使用多态的后果:<br>而如果老虎, 蛇, 山羊的<code>drink() </code>方法不是重写自同1个抽象方法的话, 多态就不能实现.<br><u>农夫类就可能要根据参数类型的不同而重载很多个 <code> feedWater()</code>方法了.</u></p>
<p>而且每增加1个类(例如 狮子Lion)</p>
<p>就需要在农夫类里增加1个feedWater的重载方法<code> feedWater(Lion l)</code>…</p>
<p>而接口跟抽象类类似,<br>这个就回答了本文第一个问题.<br>1.为什么不直接在类里面写对应的方法,  而要多写1个接口(或抽象类)?</p>
<h3 id="4、抽象类解决不了的问题"><a href="#4、抽象类解决不了的问题" class="headerlink" title="4、抽象类解决不了的问题."></a>4、抽象类解决不了的问题.</h3><p>既然抽象类很好地实现了多态性, 那么什么情况下用接口会更加好呢?</p>
<p>对于上面的例子, 我们加一点需求.</p>
<p>Farmer 农夫多了1个技能, 就是给另1个动物喂兔子(囧).</p>
<p><code>BringAnimal(Animal a, String destination)  </code> 把兔子带到某个地点…</p>
<p><code>feedAnimal(Animal ht, Animal a) </code> 把动物a丢给动物ht</p>
<p>注意农夫并没有把兔子宰了, 而是把小动物(a)丢给另1个被喂食的动物(ht).</p>
<p>那么问题来了, 那个动物必须有捕猎这个技能.  也就是我们要给被喂食的动物加上1个方法(捕猎) <code>hunt(Animal a)</code>.</p>
<p>但是现实上不是所有动物都有捕猎这个技能的, 所以我们不应该把<code>hunt(Animal a)</code>方法加在Goat类和Rabbit类里,  只加在Tiger类和Snake类里.</p>
<p>而且老虎跟蛇的捕猎方法也不一样, 则表明<u>hunt()的方法体在Tiger类里和Snake类里是不一样的.</u></p>
<p>下面有3个方案.</p>
<ol>
<li><p>分别在Tiger类里和Snake类里加上Hunt() 方法.  其它类(例如Goat) 不加.</p>
</li>
<li><p>在基类Animal里加上Hunt()抽象方法. 在Tiger里和Snake里重写这个Hunt() 方法.</p>
</li>
<li><p>添加肉食性动物这个抽象类.   </p>
</li>
</ol>
<p>先来说第1种方案.</p>
<p>这种情况下, Tiger里的<code>Hunt(Animal a)</code>方法与 Snake里的<code>Hunt(Animal a)</code>方法毫无关联. 也就是说不能利用多态性.</p>
<p>导致Farm类里的<code>feedAnimal()</code>方法需要分别为Tiger 与 Snake类重载. 否决.</p>
<p>第2种方案:</p>
<p>如果在抽象类Animal里加上<code>Hunt()</code>方法, 则所有它的非抽象派生类都要重写实现这个方法, 包括 Goat类和 Rabbit类.</p>
<p>这是不合理的, 因为Goat类根本没必要用到Hunt()方法, 造成了资源(内存)浪费.</p>
<p>第3种方案:<br>加入我们在哺乳类动物下做个分叉, 加上肉食性哺乳类动物, 非肉食性哺乳动物这两个抽象类?</p>
<p>首先,<br>肉食性这种分叉并不准确, 例如很多腐蚀性动物不会捕猎, 但是它们是肉食性.</p>
<p>其次</p>
<p>这种方案会另类族图越来越复杂, 假如以后再需要辨别能否飞的动物呢, 增加飞翔 <code>fly()</code>这个方法呢? 是不是还要分叉?</p>
<p>再次,</p>
<p>很现实的问题, 在项目中, 你很可能没机会修改上层的类代码, 因为它们是用Jar包发布的, 或者你没有修改权限.</p>
<p>这种情况下就需要用到接口了.</p>
<h3 id="5、接口与多态-以及-多继承性"><a href="#5、接口与多态-以及-多继承性" class="headerlink" title="5、接口与多态 以及 多继承性."></a>5、接口与多态 以及 多继承性.</h3><p>上面的问题, 抽象类解决不了, 根本问题是Java的类不能多继承.</p>
<p>因为Tiger类继承了动物Animal类的特性(例如 move() 和 drink()) , 但是严格上来将 捕猎(hunt())并不算是动物的特性之一. 有些植物, 单细胞生物也会捕猎的.</p>
<p>所以Tiger要从别的地方来继承Hunt()这个方法.  接口就发挥作用了.</p>
<h4 id="5-1-Huntable接口"><a href="#5-1-Huntable接口" class="headerlink" title="5.1 Huntable接口"></a>5.1 Huntable接口</h4><p>我们增加1个Huntable接口.</p>
<p>接口里有1个方法hunt(Animal a), 就是捕捉动物, 至于怎样捕捉则由实现接口的类自己决定.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Huntable</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hunt</span><span class="params">(Animal a)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-2-Tiger-类"><a href="#5-2-Tiger-类" class="headerlink" title="5.2 Tiger 类"></a>5.2 Tiger 类</h4><p>既然定义了1个Huntable(可以捕猎的)接口.</p>
<p>Tiger类就要实现这个接口并重写接口里hunt()方法.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tiger</span> <span class="keyword">extends</span> <span class="title">Mammal</span> <span class="keyword">implements</span> <span class="title">Huntable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String name = <span class="string">&quot;Tiger&quot;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">(String destination)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Goat moved to &quot;</span> + destination + <span class="string">&quot;.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drink</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Goat lower it&#x27;s head and drink.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hunt</span><span class="params">(Animal a)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Tiger catched &quot;</span> + a.getName() + <span class="string">&quot; and eated it&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-3-Snake类"><a href="#5-3-Snake类" class="headerlink" title="5.3 Snake类"></a>5.3 Snake类</h4><p>同样:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Snake</span> <span class="keyword">extends</span> <span class="title">Reptile</span> <span class="keyword">implements</span> <span class="title">Huntable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String name = <span class="string">&quot;Snake&quot;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">(String destination)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Snake crawled to &quot;</span> + destination + <span class="string">&quot;.&quot;</span>);</span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drink</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Snake dived into water and drink.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hunt</span><span class="params">(Animal a)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Snake coiled &quot;</span> + a.getName() + <span class="string">&quot; and eated it&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可见同样实现接口的<code>hunt()</code>方法, 但是蛇与老虎的捕猎方法是有区别的.</p>
<h4 id="5-4-Farmer类"><a href="#5-4-Farmer类" class="headerlink" title="5.4 Farmer类"></a>5.4 Farmer类</h4><p>这样的话. Farmer类里的<code>feedAnimal(Animal ht, Animal a)</code>就可以实现多态了.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Farmer</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bringWater</span><span class="params">(String destination)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Farmer bring water to &quot;</span> + destination + <span class="string">&quot;.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bringAnimal</span><span class="params">(Animal a,String destination)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Farmer bring &quot;</span> + a.getName() + <span class="string">&quot; to &quot;</span> + destination + <span class="string">&quot;.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">feedWater</span><span class="params">(Animal a)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.bringWater(<span class="string">&quot;Feeding Room&quot;</span>);</span><br><span class="line">        a.move(<span class="string">&quot;Feeding Room&quot;</span>);</span><br><span class="line">        a.drink();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">feedAnimal</span><span class="params">(Animal ht , Animal a)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.bringAnimal(a,<span class="string">&quot;Feeding Room&quot;</span>);</span><br><span class="line">        ht.move(<span class="string">&quot;Feeding Room&quot;</span>);</span><br><span class="line">        Huntable hab = (Huntable)ht;</span><br><span class="line">        hab.hunt(a);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关键是这一句<br><code>Huntable hab = (Huntable)ht;</code><br>本文一开始讲过了, 接口的引用可以指向实现该接口的对象.<br>当然, 如果把Goat对象传入Farmer的feedAnimal()里就会有异常, 因为Goat类没有实现该接口. 上面那个代码执行失败.</p>
<p>如果要避免上面的问题.</p>
<p>可以修改feedAnimal方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">feedAnimal</span><span class="params">(Huntable hab, Animal a)</span></span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.bringAnimal(a,<span class="string">&quot;Feeding Room&quot;</span>);</span><br><span class="line">      Animal ht = (Animal)hab;</span><br><span class="line">      ht.move(<span class="string">&quot;Feeding Room&quot;</span>);</span><br><span class="line">      hab.hunt(a);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>这样的话, 传入的对象就必须是实现了Huntable的对象, 如果把Goat放入就会编译报错.</p>
<p>但是里面一样有一句强制转换</p>
<p><code>Animal ht = (Animal)hab</code></p>
<p>反而更加不安全, 因为实现的Huntable的接口的类不一定都是Animal的派生类.<br>相反, 接口的出现就是鼓励多种不同的类实现同样的功能(方法)</p>
<p>例如,假如一个机械类也可以实现这个接口, 那么那个机械就可以帮忙打猎了(囧)</p>
<p>1个植物类(例如捕蝇草),实现这个接口, 也可以捕猎苍蝇了.</p>
<p>也就是说, <u>接口不会限制实现接口的类的类型.</u></p>
<p><u>这样, Tiger类与Snake类不但继承了Animal的方法, 还继承(实现)了接口Huntable的方法, 一定程度上弥补java的class不支持多继承的特点.</u></p>
<h3 id="6、接口上应用泛型"><a href="#6、接口上应用泛型" class="headerlink" title="6、接口上应用泛型."></a>6、接口上应用泛型.</h3><p>上面的Huntable里还是有点限制的,</p>
<p>就是它里面的hunt()方法的参数是 Animal a, 也就是说这个这个接口只能用于捕猎动物.</p>
<p>但是在java的世界里, 接口里的方法(行为)大多数是与类的类型无关的.</p>
<p>也就是说, Huntable接口里的hunt()方法里不单只可以捕猎动物, 还可以捕猎其他东西(例如 捕猎植物… 敌方机械等)</p>
<h4 id="6-1-Huntable接口"><a href="#6-1-Huntable接口" class="headerlink" title="6.1 Huntable接口"></a>6.1 Huntable接口</h4><p>首先要在Huntable接口上添加泛型标志:<T></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Huntable</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hunt</span><span class="params">(T o)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后里面的hunt()的参数的类型就写成T, 表示hunt()方法可以接受多种参数, 取决于实现接口的类.</p>
<h4 id="6-2-Tiger类-和Snake类"><a href="#6-2-Tiger类-和Snake类" class="headerlink" title="6.2 Tiger类(和Snake类)"></a>6.2 Tiger类(和Snake类)</h4><p>同样, 定义tiger类时必须加上接口的泛型标志<Animal>, 表示要把接口应用在Animal这种类型.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tiger</span> <span class="keyword">extends</span> <span class="title">Mammal</span> <span class="keyword">implements</span> <span class="title">Huntable</span>&lt;<span class="title">Animal</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String name = <span class="string">&quot;Tiger&quot;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">(String destination)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Goat moved to &quot;</span> + destination + <span class="string">&quot;.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drink</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Goat lower it&#x27;s head and drink.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hunt</span><span class="params">(Animal a)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Tiger catched &quot;</span> + a.getName() + <span class="string">&quot; and eated it&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样, 在里面hunt()参数就可以指明类型Animal了, 表示老虎虽然有捕猎这个行为, 但是只能捕猎动物.</p>
<h3 id="7、什么情况下应该使用接口而不用抽象类"><a href="#7、什么情况下应该使用接口而不用抽象类" class="headerlink" title="7、什么情况下应该使用接口而不用抽象类."></a>7、什么情况下应该使用接口而不用抽象类.</h3><p>好了, 回到本文最重要的一个问题.</p>
<p>做个总结</p>
<ol>
<li><p>需要实现多态</p>
</li>
<li><p>要实现的方法(功能)不是当前类族的必要(属性).</p>
</li>
<li><p>要为不同类族的多个类实现同样的方法(功能).</p>
</li>
</ol>
<h4 id="7-1-需要实现多态"><a href="#7-1-需要实现多态" class="headerlink" title="7.1 需要实现多态"></a>7.1 需要实现多态</h4><p>很明显, 接口其中一个存在意义就是为了实现多态. 这里不多说了.</p>
<p>而抽象类(继承) 也可以实现多态</p>
<h4 id="7-2-要实现的方法-功能-不是当前类族的必要-属性"><a href="#7-2-要实现的方法-功能-不是当前类族的必要-属性" class="headerlink" title="7.2. 要实现的方法(功能)不是当前类族的必要(属性)."></a>7.2. 要实现的方法(功能)不是当前类族的必要(属性).</h4><p>上面的例子就表明, 捕猎这个方法不是动物这个类必须的,<br>在动物的派生类中, 有些类需要, 有些不需要.  </p>
<p>如果把捕猎方法写在动物超类里面是不合理的浪费资源.</p>
<p>所以把捕猎这个方法封装成1个接口, 让派生类自己去选择实现!</p>
<h4 id="7-3-要为不同类族的多个类实现同样的方法-功能"><a href="#7-3-要为不同类族的多个类实现同样的方法-功能" class="headerlink" title="7.3  . 要为不同类族的多个类实现同样的方法(功能)."></a>7.3  . 要为不同类族的多个类实现同样的方法(功能).</h4><p>上面说过了, 其实不是只有Animal类的派生类才可以实现Huntable接口.<br>如果Farmer实现了这个接口, 那么农夫自己就可以去捕猎动物了…</p>
<p>我们拿另个常用的接口Comparable来做例子.</p>
<p>这个接口是应用了泛型,</p>
<p>首先, 比较(CompareTo) 这种行为很难界定适用的类族, 实际上, 几乎所有的类都可以比较.</p>
<p>比如 数字类可以比较大小,   人类可以比较财富,  动物可以比较体重等.</p>
<p>所以各种类都可以实现这个比较接口.</p>
<p>一旦实现了这个比较接口. 就可以开启另1个隐藏技能:</p>
<p>就是可以利用Arrays.sort()来进行排序了.</p>
<p>就如实现了捕猎的动物,<br>可以被农夫Farmer喂兔子一样…</p>
<h4 id="8、接口为什么会被叫做接口-跟真正的接口例如usb接口有联系吗"><a href="#8、接口为什么会被叫做接口-跟真正的接口例如usb接口有联系吗" class="headerlink" title="8、接口为什么会被叫做接口, 跟真正的接口例如usb接口有联系吗?"></a>8、接口为什么会被叫做接口, 跟真正的接口例如usb接口有联系吗?</h4><p>对啊, 为什么叫接口, 而不叫插件(plugin)呢,  貌似java接口的功能更类似1个插件啊.</p>
<p>插上某个插件, 就有某个功能啊.</p>
<p>实际上, 插件与接口是相辅相成的.</p>
<p>例如有1个外部存储插件(U盘), 也需要使用设备具有usb接口才能使用啊.</p>
<p>再举个具体的例子.</p>
<p>个人电脑是由大型机发展而来的</p>
<p>大型机-&gt;小型机-&gt;微机(PC)</p>
<p>而笔记本是继承自微机的.</p>
<p>那么问题来了.</p>
<p>对于, 计算机的CPU/内存/主板/独显/光驱/打印机 有很多功能(方法/行为), 那么到底哪些东西是继承, 哪些东西是接口呢.</p>
<p>首先,  cpu/内存/主板 是从大型机开始都必备的, 任何计算机都不能把它们去掉.<br>所以, 这三样东西是继承的, 也就说笔记本的cpu/内存/主板是继承自微机(PC)的</p>
<p>但是/光驱/呢,    现实上很多超薄笔记本不需要光驱的功能.</p>
<p>如果光驱做成继承, 那么笔记本就必须具有光驱, 然后屏蔽光驱功能, 那么这台笔记本还能做到超薄吗? 浪费了资源.</p>
<p>所以光驱,打印机这些东西就应该做成插件.</p>
<p>然后, 在笔记本上做1个可以插光驱和打印机的接口(usb接口).</p>
<p>也就是说, PC的派生类, 有些(笔记本)可以不实现这个接口, 有些(台式机)可以实现这个接口,只需要把光驱插到这个接口上.</p>
<p>至于光驱是如何实现的,</p>
<p>例如一些pc派生类选择实现蓝光光驱, 有些选择刻录机.  但是usb接口本身并不关心. 取决与实现接口的类.</p>
<p>这个就是现实意义上的多态性啊.<br>————————————————<br>版权声明：本文为CSDN博主「nvd11」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/nvd11/article/details/41129935">https://blog.csdn.net/nvd11/article/details/41129935</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://wenwenhuan.gitee.io/2020/12/28/Springboot/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="温文焕">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wenhuan Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/12/28/Springboot/" class="post-title-link" itemprop="url">Springboot</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-12-28 10:00:00" itemprop="dateCreated datePublished" datetime="2020-12-28T10:00:00+08:00">2020-12-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2021-02-28 16:47:12" itemprop="dateModified" datetime="2021-02-28T16:47:12+08:00">2021-02-28</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Springboot"><a href="#Springboot" class="headerlink" title="Springboot"></a><strong>Springboot</strong></h1><h2 id="一、静态资源访问"><a href="#一、静态资源访问" class="headerlink" title="一、静态资源访问"></a>一、静态资源访问</h2><h3 id="1、静态资源目录"><a href="#1、静态资源目录" class="headerlink" title="1、静态资源目录"></a>1、静态资源目录</h3><p>只要静态资源放在类路径下： called <code>/static</code> (or <code>/public</code> or <code>/resources</code> or <code>/META-INF/resources</code></p>
<p>访问 ： 当前项目根路径/ + 静态资源名 （直接访问）</p>
<p>原理： 静态映射/**。</p>
<p>请求进来，先去找Controller看能不能处理。不能处理的所有请求又都交给静态资源处理器。静态资源也找不到则响应404页面</p>
<p>改变默认的静态资源路径</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">mvc:</span></span><br><span class="line">    <span class="attr">static-path-pattern:</span> <span class="string">/res/**</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">resources:</span></span><br><span class="line">    <span class="attr">static-locations:</span> [<span class="string">classpath:/haha/</span>]</span><br></pre></td></tr></table></figure>

<h3 id="2、静态资源访问前缀"><a href="#2、静态资源访问前缀" class="headerlink" title="2、静态资源访问前缀"></a>2、静态资源访问前缀</h3><p>默认无前缀</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">mvc:</span></span><br><span class="line">    <span class="attr">static-path-pattern:</span> <span class="string">/res/**</span></span><br></pre></td></tr></table></figure>

<p>当前项目 + static-path-pattern + 静态资源名 = 静态资源文件夹下找</p>
<h3 id="3、欢迎页支持"><a href="#3、欢迎页支持" class="headerlink" title="3、欢迎页支持"></a>3、欢迎页支持</h3><ul>
<li><p>静态资源路径下  index.html</p>
</li>
<li><ul>
<li>可以配置静态资源路径</li>
<li>但是不可以配置静态资源的访问前缀。否则导致 index.html不能被默认访问</li>
</ul>
</li>
<li><p>```yml<br>spring:</p>
<h1 id="mvc"><a href="#mvc" class="headerlink" title="mvc:"></a>mvc:</h1><h1 id="static-path-pattern-res-这个会导致welcome-page功能失效"><a href="#static-path-pattern-res-这个会导致welcome-page功能失效" class="headerlink" title="static-path-pattern: /res/**   这个会导致welcome page功能失效"></a>static-path-pattern: /res/**   这个会导致welcome page功能失效</h1><p>  resources:</p>
<pre><code>static-locations: [classpath:/haha/]
</code></pre>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 4、自定义 &#96;Favicon&#96;</span><br><span class="line"></span><br><span class="line">favicon.ico 放在静态资源目录下即可。</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;yml</span><br><span class="line">spring:</span><br><span class="line">#  mvc:</span><br><span class="line">#    static-path-pattern: &#x2F;res&#x2F;**   这个会导致 Favicon 功能失效</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="二、请求参数处理"><a href="#二、请求参数处理" class="headerlink" title="二、请求参数处理"></a>二、请求参数处理</h2><h3 id="1、rest使用与原理"><a href="#1、rest使用与原理" class="headerlink" title="1、rest使用与原理"></a>1、rest使用与原理</h3><ul>
<li><p>@xxxMapping；</p>
</li>
<li><p>Rest风格支持（<em>使用<strong>HTTP</strong>请求方式动词来表示对资源的操作</em>）</p>
</li>
<li><ul>
<li><em>以前：*</em>/getUser*  <em>获取用户</em>   <em>/deleteUser</em> <em>删除用户</em>   <em>/editUser</em>  <em>修改用户</em>    <em>/saveUser</em> <em>保存用户</em></li>
<li><em>现在： /user</em>   *GET-*<em>获取用户</em>   *DELETE-*<em>删除用户</em>   *PUT-*<em>修改用户</em>    *POST-*<em>保存用户</em></li>
<li>核心Filter；HiddenHttpMethodFilter</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>用法： 表单method=post，隐藏域 _method=put</li>
<li>SpringBoot中手动开启</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">	<span class="comment">//@RequestMapping(value = &quot;/user&quot;,method = RequestMethod.GET)</span></span><br><span class="line">	<span class="meta">@GetMapping(&quot;/user&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUser</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;GET-张三&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//@RequestMapping(value = &quot;/user&quot;,method = RequestMethod.POST)</span></span><br><span class="line">	<span class="meta">@PostMapping(&quot;/user&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">saveUser</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;POST-张三&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//@RequestMapping(value = &quot;/user&quot;,method = RequestMethod.PUT)</span></span><br><span class="line">	<span class="meta">@PutMapping(&quot;/user&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">putUser</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;PUT-张三&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//@RequestMapping(value = &quot;/user&quot;,method = RequestMethod.DELETE)</span></span><br><span class="line">	<span class="meta">@DeleteMapping(&quot;/user&quot;)</span>	</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">deleteUser</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;DELETE-张三&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean(HiddenHttpMethodFilter.class)</span></span><br><span class="line">    <span class="meta">@ConditionalOnProperty(prefix = &quot;spring.mvc.hiddenmethod.filter&quot;, name = &quot;enabled&quot;, matchIfMissing = false)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> OrderedHiddenHttpMethodFilter <span class="title">hiddenHttpMethodFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> OrderedHiddenHttpMethodFilter();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义filter</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HiddenHttpMethodFilter <span class="title">hiddenHttpMethodFilter</span><span class="params">()</span></span>&#123;</span><br><span class="line">        HiddenHttpMethodFilter methodFilter = <span class="keyword">new</span> HiddenHttpMethodFilter();</span><br><span class="line">        methodFilter.setMethodParam(<span class="string">&quot;_m&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> methodFilter;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://wenwenhuan.gitee.io/2020/12/27/%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="温文焕">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wenhuan Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/12/27/%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4/" class="post-title-link" itemprop="url">机器人的运动范围</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-12-27 10:00:00" itemprop="dateCreated datePublished" datetime="2020-12-27T10:00:00+08:00">2020-12-27</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2021-02-28 16:55:26" itemprop="dateModified" datetime="2021-02-28T16:55:26+08:00">2021-02-28</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="机器人的运动范围"><a href="#机器人的运动范围" class="headerlink" title="机器人的运动范围"></a>机器人的运动范围</h1><p>地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？</p>
<h2 id="审题："><a href="#审题：" class="headerlink" title="审题："></a>审题：</h2><p>可以看出应该用dfs解题，但犯了两个错误：</p>
<ol>
<li>忘记标记已经遍历过的格子，导致无限循环。</li>
<li>把行r和列c调换了位置，导致数组下标溢出异常。</li>
</ol>
<h2 id="查看答案后"><a href="#查看答案后" class="headerlink" title="查看答案后:"></a>查看答案后:</h2><p>答案的中心思想和我一样，但我依旧做了很多无用功！</p>
<ol>
<li><strong>这是一个有规律的方阵</strong>，关键的条件“行坐标和列坐标的数位之和”是一个依次递增的，其实不用向四个方向查询，只需要向下，和向右查询就可以。</li>
</ol>
<p><img src="C:%5CUsers%5CPowerwenwh%5CDocuments%5C_posts%5C%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4.assets%5Cimage-20201225155726090.png" alt="image-20201225155726090"></p>
<p>这个特性也让我想起了之前做的另外一题———二维数组的查找，两者有同工异曲之妙。 </p>
<ol start="2">
<li>找规律的能力还要提升。</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/5/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">温文焕</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  





  





</body>
</html>
