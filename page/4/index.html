<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"wenwenhuan.gitee.io","root":"/","images":"/images","scheme":"Gemini","darkmode":true,"version":"8.8.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>
<meta property="og:type" content="website">
<meta property="og:title" content="Wenhuan Blog">
<meta property="og:url" content="https://wenwenhuan.gitee.io/page/4/index.html">
<meta property="og:site_name" content="Wenhuan Blog">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="温文焕">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://wenwenhuan.gitee.io/page/4/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/4/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Wenhuan Blog</title>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Wenhuan Blog</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">即使天无雨 我亦留此地</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">温文焕</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">61</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://wenwenhuan.gitee.io/2021/03/14/%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B8%80%E8%AE%B0%E5%BD%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="温文焕">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wenhuan Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/03/14/%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B8%80%E8%AE%B0%E5%BD%95/" class="post-title-link" itemprop="url">一份Java面试题记录</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-03-14 01:44:48" itemprop="dateCreated datePublished" datetime="2021-03-14T01:44:48+08:00">2021-03-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2021-04-19 23:43:52" itemprop="dateModified" datetime="2021-04-19T23:43:52+08:00">2021-04-19</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="一、int和Integer有什么区别？"><a href="#一、int和Integer有什么区别？" class="headerlink" title="一、int和Integer有什么区别？"></a>一、int和Integer有什么区别？</h3><h4 id="1-Java两种数据类型分类"><a href="#1-Java两种数据类型分类" class="headerlink" title="1.Java两种数据类型分类"></a>1.Java两种数据类型分类</h4><p>为了编程的方便还是引入了基本数据类型，但是为了能够将这些基本数据类型当成对象操作，Java为每 一个基本数据类型都引入了对应的包装类型（wrapper class），int的包装类就是Integer，从Java 5开始引入了自动装箱/拆箱机制，使得二者可以相互转换。</p>
<p>（1）基本数据类型，分为boolean、byte、int、char、long、short、double、float；<br>（2）引用数据类型 ，分为数组、类、接口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">基本数据类型: <span class="keyword">boolean</span>，<span class="keyword">char</span>，<span class="keyword">byte</span>，<span class="keyword">short</span>，<span class="keyword">int</span>，<span class="keyword">long</span>，<span class="keyword">float</span>，<span class="keyword">double</span></span><br><span class="line">封装类类型：Boolean，Character，Byte，Short，Integer，Long，Float，Double</span><br></pre></td></tr></table></figure>

<h4 id="2-int与Integer的基本使用对比"><a href="#2-int与Integer的基本使用对比" class="headerlink" title="2.int与Integer的基本使用对比"></a>2.int与Integer的基本使用对比</h4><ul>
<li>Integer是int的包装类；int是基本数据类型；</li>
<li>Integer变量必须实例化后才能使用；int变量不需要；</li>
<li>Integer实际是对象的引用，指向此new的Integer对象；int是直接存储数据值 ；</li>
<li>Integer的默认值是null；int的默认值是0。</li>
</ul>
<h4 id="int与Integer的深入对比"><a href="#int与Integer的深入对比" class="headerlink" title="int与Integer的深入对比"></a>int与Integer的深入对比</h4><p>（1）由于Integer变量实际上是对一个Integer对象的引用，所以两个通过new生成的Integer变量永远是不相等的（<strong>因为new生成的是两个对象，其内存地址不同</strong>）。</p>
<p>（2）Integer变量和int变量比较时，只要两个变量的值是向等的，则结果为true（因为<strong>包装类Integer和基本数据类型int比较时，java会自动拆包装为int，然后进行比较，实际上就变为两个int变量的比较</strong>）</p>
<p>（3）非new生成的Integer变量和new Integer()生成的变量比较时，结果为false。因为<strong>非new生成的Integer变量指向的是静态常量池中cache数组中存储的指向了堆中的Integer对象，而new Integer()生成的变量指向堆中新建的对象，两者在内存中的对象引用（地址）不同</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer i = <span class="keyword">new</span> Integer(<span class="number">100</span>);</span><br><span class="line">Integer j = <span class="number">100</span>;</span><br><span class="line">System.out.print(i == j); <span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<h3 id="二、String和StringBuffer的区别"><a href="#二、String和StringBuffer的区别" class="headerlink" title="二、String和StringBuffer的区别"></a>二、String和StringBuffer的区别</h3><h4 id="什么是StringBuffer？"><a href="#什么是StringBuffer？" class="headerlink" title="什么是StringBuffer？"></a>什么是StringBuffer？</h4><blockquote>
<p>线程安全的可变字符序列。一个类似于 <a target="_blank" rel="noopener" href="https://tool.oschina.net/uploads/apidocs/jdk-zh/java/lang/String.html"><code>String</code></a> 的字符串缓冲区，但不能修改。虽然在任意时间点上它都包含某种特定的字符序列，但通过某些方法调用可以改变该序列的长度和内容。</p>
</blockquote>
<blockquote>
<p>可将字符串缓冲区安全地用于多个线程。可以在必要时对这些方法进行同步，因此任意特定实例上的所有操作就好像是以串行顺序发生的，该顺序与所涉及的每个线程进行的方法调用顺序一致。</p>
</blockquote>
<blockquote>
<p><code>StringBuffer</code> 上的主要操作是 <code>append</code> 和 <code>insert</code> 方法，可重载这些方法，以接受任意类型的数据。每个方法都能有效地将给定的数据转换成字符串，然后将该字符串的字符追加或插入到字符串缓冲区中。<code>append</code> 方法始终将这些字符添加到缓冲区的末端；而 <code>insert</code> 方法则在指定的点添加字符。</p>
</blockquote>
<blockquote>
<p>通常，如果 sb 引用 <code>StringBuilder</code> 的一个实例，则 <code>sb.append(x)</code> 和 <code>sb.insert(sb.length(), x)</code> 具有相同的效果。</p>
</blockquote>
<blockquote>
<p>当发生与源序列有关的操作（如源序列中的追加或插入操作）时，该类只在执行此操作的字符串缓冲区上而不是在源上实现同步。</p>
</blockquote>
<blockquote>
<p>从 JDK 5 开始，为该类补充了一个单个线程使用的等价类，即 <a target="_blank" rel="noopener" href="https://tool.oschina.net/uploads/apidocs/jdk-zh/java/lang/StringBuilder.html"><code>StringBuilder</code></a>。与该类相比，通常应该优先使用 <code>StringBuilder</code> 类，因为它支持所有相同的操作，但由于它不执行同步，所以速度更快。</p>
</blockquote>
<blockquote>
<p>将 <code>StringBuilder</code> 的实例用于多个线程是不安全的。如果需要这样的同步，则建议使用 <a target="_blank" rel="noopener" href="https://tool.oschina.net/uploads/apidocs/jdk-zh/java/lang/StringBuffer.html"><code>StringBuffer</code></a>。</p>
</blockquote>
<blockquote>
<p>Java 语言提供对字符串串联符号（”+”）以及将其他对象转换为字符串的特殊支持。字符串串联是通过 <code>StringBuilder</code>（或 <code>StringBuffer</code>）类及其 <code>append</code> 方法实现的。字符串转换是通过 <code>toString</code> 方法实现的，该方法由 <code>Object</code> 类定义，并可被 Java 中的所有类继承。</p>
</blockquote>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>简单地说，就是一个变量和常量的关系。StringBuffer对象的内容可以修改；而String对象一旦产生后就不可以被修改，重新赋值其实是两个对象。<br>StringBuffer的内部实现方式和String不同，<strong>StringBuffer在进行字符串处理时，不生成新的对象，在内存使用上要优于String类。</strong>所以在实际使用时，如果经常需要对一个字符串进行修改，例如插入、删除等操作，使用StringBuffer要更加适合一些。<br>String:在String类中没有用来改变已有字符串中的某个字符的方法，由于不能改变一个java字符串中的某个单独字符，所以在JDK文档中称String类的对象是不可改变的。然而，不可改变的字符串具有一个很大的优点:编译器可以把字符串设为共享的。<br>StringBuffer:<strong>StringBuffer类属于一种辅助类，可预先分配指定长度的内存块建立一个字符串缓冲区。</strong>这样使用StringBuffer类的append方法追加字符 比 String使用 + 操作符添加字符到一个已经存在的字符串后面有效率得多。因为使用 + 操作符每一次将字符添加到一个字符串中去时，字符串对象都需要寻找一个新的内存空间来容纳更大的字符串，这无凝是一个非常消耗时间的操作。添加多个字符也就意味着要一次又一次的对字符串重新分配内存。使用StringBuffer类就避免了这个问题。<br><strong>StringBuffer是线程安全的</strong>，在多线程程序中也可以很方便的进行使用，但是程序的执行效率相对来说就要稍微慢一些。</p>
<ol>
<li> StringBuffer在进行字符串处理时，不生成新的对象，在内存使用优于String类。</li>
<li>StringBuffer可预先分配指定长度的内存块建立一个字符串缓冲区。</li>
<li>StringBuffer是线程安全的。</li>
</ol>
<h3 id="三、运行时异常与一般异常有何区别"><a href="#三、运行时异常与一般异常有何区别" class="headerlink" title="三、运行时异常与一般异常有何区别"></a>三、运行时异常与一般异常有何区别</h3><h4 id="异常和错误（Exception-amp-Error）"><a href="#异常和错误（Exception-amp-Error）" class="headerlink" title="异常和错误（Exception&amp;Error）"></a>异常和错误（Exception&amp;Error）</h4><img src="/2021/03/14/%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B8%80%E8%AE%B0%E5%BD%95/Exception&Error.png" class="" title="img">

<p>Throwable： 有两个重要的子类：<strong>Exception（异常）和 Error（错误）</strong>，二者都是 Java 异常处理的重要子类，各自都包含大量子类。</p>
<p>Error（错误）:</p>
<p>　　是<strong>程序无法处理的错误</strong>，表示运行应用程序中较严重问题。<strong>大多数错误与代码编写者执行的操作无关</strong>，而表示代码运行时 JVM（Java 虚拟机）出现的问题。例如，Java虚拟机运行错误（Virtual MachineError），当 JVM 不再有继续执行操作所需的内存资源时，将出现 OutOfMemoryError。这些异常发生时，Java虚拟机（JVM）一般会选择线程终止。</p>
<p>Exception（异常）:</p>
<p>　　是<strong>程序本身可以处理的异常。</strong></p>
<p>Exception可以分为checked exceptions和unchecked exceptions：</p>
<ol>
<li>unchecked exceptions（<strong>运行时异常</strong>）都是RuntimeException类及其子类异常，就是我们在开发中测试功能时程序终止，控制台出现的异常，比如：</li>
</ol>
<ul>
<li>NullPointerException(空指针异常)、</li>
<li>IndexOutOfBoundsException(下标越界异常)</li>
<li>ClassCastException(类转换异常)</li>
<li>ArrayStoreException(数据存储异常，操作数组时类型不一致)</li>
<li>IO操作的BufferOverflowException异常</li>
</ul>
<ol start="2">
<li>checked exceptions 非运行时异常 （编译异常）：是RuntimeException以外的异常，类型上都属于Exception类及其子类。从程序语法角度讲是必须进行处理的异常，如果不处理，程序就不能编译通过。如IOException、SQLException等以及用户自定义的Exception异常，一般情况下不自定义检查异常。<br>通俗的话说就是在写代码时出现红线，需要try catch或者throws时出现的异常。</li>
</ol>
<p><strong>1、运行时异常与一般异常有何异同？</strong></p>
<p>异常表示程序运行过程中可能出现的非正常状态，运行时异常表示虚拟机的通常操作中可能遇到的异常，是一种常见运行错误。java编译器要求方法必须声明抛出可能发生的非运行时异常，但是并不要求必须声明抛出未被捕获的运行时异常。</p>
<p>　　<strong>理解：</strong></p>
<p>　　<u>运行时异常，我们<strong>可以不处理</strong>。当出现这样的异常时，<strong>总是由虚拟机接管</strong>。</u>比如：我们从来没有人去处理过 NullPointerException 异常，它就是运行时异常，并且，这种异常还是最常见的异常之一。RuntimeException 体系包括<strong>错误的类型转换、数组越界访问和试图访问空指针</strong>等等。处理 RuntimeException 的原则是：假如出现 RuntimeException，那么一定是程序员的错误，例如，可以通过检查数组小标和数组边界来避免越界访问异常。</p>
<p>　　一般异常：<u>定义方法时<strong>必须声明</strong>所有可能会抛出的checked exception</u>；在调用这个方法时，必须捕获它的checked exception，不然就得把它的exception传递下去；checked exception是从java.lang.Exception类衍生出来的。</p>
<p><strong>2、error和exception有什么区别?</strong></p>
<p>　　error 是<strong>程序无法处理的错误</strong>。比如说内存溢出。<strong>不可能指望程序能处理这样的情况</strong>。 <strong>exception 表示一种设计或实现问题</strong>。也就是说，它表示如果程序运行正常，从不会发生的情况。</p>
<p><strong>3.Java中的异常处理机制的简单原理和应用</strong></p>
<p>　　异常是指java程序运行时（非编译）所发生的非正常情况或错误，与现实生活中的事件很相似，现实生活中的事件可以包含事件发生的时间、地点、人物、情节等信息，可以用一个对象来表示，Java使用面向对象的方式来处理异常，它把程序中发生的每个异常也都分别封装到一个对象来表示的，该对象中包含有异常的信息。</p>
<p>　　Java对异常进行了分类，不同类型的异常分别用不同的Java类来表示，所有异常的根类为java.lang.Throwable，Throwable下面又派生了两个子类：Error和Exception,Error表示应用程序本身无法克服和恢复的一种严重问题，程序只有死的份了，例如，说内存溢出和线程死锁等系统问题。Exception表示程序表示程序还能够克服和恢复的一种严重问题，其中又分为系统异常和普通异常，系统异常是软件本身缺陷所导致的问题，也就是软件开发人员考虑不周所导致的问题，软件使用者无法克服和恢复这种问题，但在这种问题下还可以让软件系统继续运行或者让软件死掉，例如，数组脚本越界（ArrayIndexOutOfBoundsException）、空指针异常（NullPointerException）、类转换异常（ClassCastException）；普通异常是运行环境的变化或异常所导致的问题，是用户能够克服的问题，例如，网络断线，硬盘空间不够，发生这样的异常后，程序不应该死掉。</p>
<p>　　java为系统异常和普通异常提供了不同的解决方案，编译器强制普通异常必须try···catch处理或用throws声明继续抛给上层调用方法处理，所以普通异常也称为checked异常，而系统异常可以处理也可以不处理，所以，编译器不强制用try…catch处理或用throws声明，所以系统异常也称为unchecked异常。</p>
<h3 id="四、final和finally的区别"><a href="#四、final和finally的区别" class="headerlink" title="四、final和finally的区别"></a>四、final和finally的区别</h3><ol>
<li>final修饰符（关键字）。<strong>被final修饰的类不能被其他子类继承。</strong>因此一个类不能既被abstract声明，又被final声明。<strong>将变量或方法声明为final，可以保证他们在使用的过程中不被修改。</strong>被声明为final的变量必须在声明时给出变量的初始值，而在以后的引用中只能读取。<strong>被final声明的方法也同样只能使用，即不能方法重写。</strong></li>
<li><strong>finally是在异常处理时提供finally块来执行任何清除操作。不管有没有异常被抛出、捕获，finally块都会被执行。</strong>try块中的内容是在无异常时执行到结束。catch块中的内容，是在try块内容发生catch所声明的异常时，跳转到catch块中执行。finally块则是无论异常是否发生，都会执行finally块的内容，所以在代码逻辑中有需要无论发生什么都必须执行的代码，就可以放在finally块中。</li>
</ol>
<h3 id="五、abstract-class和interface有什么区别"><a href="#五、abstract-class和interface有什么区别" class="headerlink" title="五、abstract class和interface有什么区别"></a>五、abstract class和interface有什么区别</h3><h4 id="抽象类是什么？"><a href="#抽象类是什么？" class="headerlink" title="抽象类是什么？"></a>抽象类是什么？</h4><p>本文中的抽象类表示的是一个抽象体</p>
<ul>
<li>在面向对象的概念中，所有的对象都是通过类来描绘的，但是并不是所有的类都是用来描绘对象的，<strong>如果一个类中没有包含足够的信息来描绘一个具体的对象，这样的类就是抽象类。</strong></li>
<li>抽象类的定义<br>是对一系列看上去不同，但是本质上相同的具体概念的抽象，往往用来表征我们在对问题进行分析、设计中得出的抽象概念</li>
<li>它和具体类的核心区别是，抽象类不能创建对象(比如，不能使用new Shape())，而具体类可以。</li>
<li>一个类在继承抽象类后，必须实现抽象类中定义的所有抽象方法，除非它自己也声明为抽象类。</li>
</ul>
<h4 id="为什么要有抽象类？"><a href="#为什么要有抽象类？" class="headerlink" title="为什么要有抽象类？"></a>为什么要有抽象类？</h4><ul>
<li>待总结</li>
</ul>
<h4 id="抽象类（abstract-class）"><a href="#抽象类（abstract-class）" class="headerlink" title="抽象类（abstract class）"></a>抽象类（abstract class）</h4><ul>
<li><p>定义：包含抽象方法的的类是abstract class</p>
<blockquote>
<p>用abstract关键字修饰</p>
</blockquote>
</li>
<li><p>作用：abstractclass是为了把相同的东西提取出来,<strong>即重用</strong></p>
</li>
<li><p>使用abstractclass语法规定</p>
</li>
</ul>
<table>
<thead>
<tr>
<th align="left">语法</th>
<th align="center">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="left">抽象类定义用abstract关键字修饰</td>
<td align="center">要通过子类进行实例化</td>
</tr>
<tr>
<td align="left">抽象类是不能被实例化的</td>
<td align="center">要通过子类进行实例化</td>
</tr>
<tr>
<td align="left"><strong>子类必须重写父类的所有抽象方法</strong></td>
<td align="center">抽象方法：声明但却未被实现的方法，用abstract关键字修饰</td>
</tr>
<tr>
<td align="left">含有抽象方法的类一定是抽象类，但是抽象类不一定含有抽象方法</td>
<td align="center">无</td>
</tr>
<tr>
<td align="left">抽象类是用来被它的子类继承的</td>
<td align="center"><strong>关键字extends</strong></td>
</tr>
</tbody></table>
<h4 id="Interface"><a href="#Interface" class="headerlink" title="Interface"></a>Interface</h4><ul>
<li><p>定义：比abstract class更加抽象，是一种特殊的abstract class</p>
<blockquote>
<p>用Interface关键字修饰</p>
</blockquote>
</li>
<li><p>作用：Interface是为了把程序模块进行固化的契约,是<strong>为了降低偶合</strong></p>
</li>
<li><p>使用Interface的语法规定</p>
</li>
</ul>
<table>
<thead>
<tr>
<th align="left">语法</th>
<th align="center">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="left">接口定义用Interface关键字修饰</td>
<td align="center"></td>
</tr>
<tr>
<td align="left">接口中的所有方法都是抽象的</td>
<td align="center"><strong>可以用abstract修饰，也可以省略</strong></td>
</tr>
<tr>
<td align="left">接口中的方法<strong>必须是用public修饰，或不写</strong></td>
<td align="center">但是不能被其他修饰符修饰</td>
</tr>
<tr>
<td align="left">接口中的属性<strong>必须是全局常量</strong></td>
<td align="center"><strong>public static final修饰</strong></td>
</tr>
<tr>
<td align="left">抽象类是用来被它的子类实现的</td>
<td align="center"><strong>关键字Implements</strong></td>
</tr>
<tr>
<td align="left">接口不能被实例化</td>
<td align="center">无</td>
</tr>
<tr>
<td align="left"><strong>子类实现接口时需要实现接口中的所有方法</strong></td>
<td align="center">若有一个未不实现，该子类就是抽象类abstractclass</td>
</tr>
</tbody></table>
<h4 id="二者的相同点"><a href="#二者的相同点" class="headerlink" title="二者的相同点"></a>二者的相同点</h4><p>都不能被实例化</p>
<h4 id="二者的区别"><a href="#二者的区别" class="headerlink" title="二者的区别"></a>二者的区别</h4><table>
<thead>
<tr>
<th align="left">类型</th>
<th align="center">abstract class</th>
<th align="center">Interface</th>
</tr>
</thead>
<tbody><tr>
<td align="left">定义</td>
<td align="center">abstract class关键字</td>
<td align="center">Interface关键字</td>
</tr>
<tr>
<td align="left">继承</td>
<td align="center"><strong>子类只可以继承一个抽象类</strong></td>
<td align="center"><strong>接口只可以继承接口（一个或多个）；子类可以实现多个接口</strong></td>
</tr>
<tr>
<td align="left">访问修饰符</td>
<td align="center">抽象方法可以有<strong>public</strong>、<strong>protected</strong>和<strong>default</strong>这些修饰符</td>
<td align="center">接口方法默认修饰符是<strong>public</strong>。你不可以使用其它修饰符</td>
</tr>
<tr>
<td align="left">方法实现</td>
<td align="center">可定义构造方法，<strong>可以有抽象方法和具体方法</strong></td>
<td align="center">接口完全是抽象的，没构造方法，且方法都是抽象的，不存在方法的实现</td>
</tr>
<tr>
<td align="left">实现方式</td>
<td align="center">子类使用<strong>extends</strong>关键字来继承抽象类。如果子类不是抽象类的话，它需要提供抽象类中所有声明的方法的实现</td>
<td align="center">子类使用关键字<strong>implements</strong>来实现接口。它需要提供接口中所有声明的方法的实现</td>
</tr>
<tr>
<td align="left">作用</td>
<td align="center">把相同的东西提取出来,<strong>即重用</strong></td>
<td align="center">为了把程序模块进行固化的契约,是<strong>为了降低偶合</strong></td>
</tr>
</tbody></table>
<ol>
<li>抽象类中抽象方法的访问权限可以是public、protectedl；接口只能是public</li>
<li>抽象类中可以有非抽象方法；接口中的方法都是抽象方法</li>
<li>抽象类中可以定义普通成员变量；接口中不能定义普通成员变量</li>
<li>抽象类和接口都能定义静态成员变量，抽象类访问权限可以是任意的；但是接口只能是 public static final即常量</li>
<li>抽象类中可以有构造方法；接口中不能有构造方法</li>
<li>一个类只能实现一个抽象类；但一个类可以实现多个接口，接口可以继承多个接口</li>
</ol>
<h3 id="六、数据连接池的工作机制"><a href="#六、数据连接池的工作机制" class="headerlink" title="六、数据连接池的工作机制"></a>六、数据连接池的工作机制</h3><ol>
<li>初始化时建立由最大维持连接数决定数量的连接。</li>
<li>用户申请连接直到达到最大连接数的时候，请求将被添加到等待队列。</li>
<li>用户断开连接后，超过最大维持连接数的连接不会马上销毁，最大等待时间过后才会销毁</li>
<li>对数据库连接的管理能显著影响到整个应用程序的伸缩性和健壮性，影响到程序的性能指标。</li>
</ol>
<h3 id="七、数组有无length-方法，String有无length-方法？"><a href="#七、数组有无length-方法，String有无length-方法？" class="headerlink" title="七、数组有无length()方法，String有无length()方法？"></a>七、数组有无length()方法，String有无length()方法？</h3><p>数组有length属性，String有length()方法。</p>
<h3 id="八、try-里有一个return语句，那么紧跟在try后的finally-里的code什么时候执行？"><a href="#八、try-里有一个return语句，那么紧跟在try后的finally-里的code什么时候执行？" class="headerlink" title="八、try{}里有一个return语句，那么紧跟在try后的finally{}里的code什么时候执行？"></a>八、try{}里有一个return语句，那么紧跟在try后的finally{}里的code什么时候执行？</h3><p>在return前执行</p>
<h3 id="九、当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底时值传递还是引用传递？"><a href="#九、当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底时值传递还是引用传递？" class="headerlink" title="九、当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底时值传递还是引用传递？"></a>九、当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底时值传递还是引用传递？</h3><p>是值传递。Java编程语言只有值传递参数。当一个对象实例作为一个参数被传递到方法中时，参数的值就是该对象的引用一个副本。指向同一个对象,对象的内容可以在被调用的方法中改变，但<strong>对象的引用(不是引用的副本)是永远不会改变的</strong>。</p>
<h3 id="十、当一个线程进入一个对象的一个synchronized方法后，其他线程是否可进入此对象的其他方法？"><a href="#十、当一个线程进入一个对象的一个synchronized方法后，其他线程是否可进入此对象的其他方法？" class="headerlink" title="十、当一个线程进入一个对象的一个synchronized方法后，其他线程是否可进入此对象的其他方法？"></a>十、当一个线程进入一个对象的一个synchronized方法后，其他线程是否可进入此对象的其他方法？</h3><p>不可以</p>
<h3 id="十一、集合类都有哪些？主要方法是？"><a href="#十一、集合类都有哪些？主要方法是？" class="headerlink" title="十一、集合类都有哪些？主要方法是？"></a>十一、集合类都有哪些？主要方法是？</h3>

<p><strong>Set</strong></p>
<p>Set中不能包含重复的元素。</p>
<p><strong>List接口</strong></p>
<p>List是一个有序的集合，可以包含重复的元素。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">add(E e),add(<span class="keyword">int</span> index, E e),contains(Object o),addAll(Collection c),equals(Object o),get(<span class="keyword">int</span> index),indexOf(Object o),</span><br><span class="line">isEmpty(),set(<span class="keyword">int</span> index, E element),remove(<span class="keyword">int</span> index),remove(Object o),size(),toArray()</span><br></pre></td></tr></table></figure>

<p>ArrayList：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ensureCapacity()</span><br></pre></td></tr></table></figure>

<p>LinkList:</p>
<p>除了实现 List 接口外，LinkedList 类还为在列表的开头及结尾 get、remove 和 insert 元素提供了统一的命名方法。这些操作允许将链接列表用作堆栈、队列或双端队列。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">peek(),peekFirst(),	peekLast(),<span class="comment">//获取不移除</span></span><br><span class="line">poll(),pollFirst(),pollLast(),<span class="comment">//获取并移除</span></span><br><span class="line">pop(),push(E e)、、堆栈操作</span><br></pre></td></tr></table></figure>

<p>Vector：</p>
<p>Stack：</p>
<p>通过五个操作对类 <code>Vector</code> 进行了扩展</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">empty(),peek(),pop(),push(E item),search(Object o)</span><br></pre></td></tr></table></figure>

<p><strong>queue</strong></p>
<h3 id="十二、线程的基本概念、基本状态及状态间的关系？"><a href="#十二、线程的基本概念、基本状态及状态间的关系？" class="headerlink" title="十二、线程的基本概念、基本状态及状态间的关系？"></a>十二、线程的基本概念、基本状态及状态间的关系？</h3><p><strong>什么是线程</strong></p>
<p>一个线程是<u>进程的一个顺序执行流</u>。同类的多个线程<u>共享一块内存空间和一组系统资源</u>，线程本身有一个供程序执行时的堆栈。线程在切换时负荷小，因此，线程也被称为轻负荷进程。一个进程中可以包含多个线程。</p>
<p><strong>进程与线程的区别</strong></p>
<p>一个进程至少有一个线程。线程的划分尺度小于进程，使得多线程程序的并发性高。另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。</p>
<p>线程在执行过程中与进程的区别在于每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。</p>
<p>从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操<u>作系统并没有将多个线程看做多个独立的应用来实现进程的调度和管理以及资源分配</u>。</p>
<p><strong>并发原理</strong></p>
<p>多个线程或进程”同时”运行只是我们感官上的一种表现。事实上进程和线程是并发运行的，OS的线程调度机制将时间划分为很多时间片段（时间片），尽可能均匀分配给正在运行的程序，获取CPU时间片的线程或进程得以被执行，其他则等待。而CPU则在这些进程或线程上来回切换运行。微观上所有进程和线程是走走停停的，宏观上都在运行，这种都运行的现象叫并发，但是不是绝对意义上的“同时发生”。</p>
<p><strong>线程状态</strong></p>
<p><strong>1.新建</strong></p>
<p>用new语句创建的线程对象处于新建状态，此时它和其他java对象一样，仅被分配了内存。</p>
<p><strong>2.等待</strong></p>
<p>当线程在new之后，并且在调用start方法前，线程处于等待状态。</p>
<p><strong>3.就绪</strong></p>
<p>当一个线程对象创建后，其他线程调用它的start()方法，该线程就进入就绪状态。处于这个状态的线程<u>位于Java虚拟机的可运行池中</u>，等待cpu的使用权。</p>
<p><strong>4.运行状态</strong></p>
<p>处于这个状态的线程占用CPU，执行程序代码。在并发运行环境中，如果计算机只有一个CPU，那么任何时刻只会有一个线程处于这个状态。</p>
<p><u>只有处于就绪状态的线程才有机会转到运行状态。</u></p>
<p><strong>5.阻塞状态</strong></p>
<p>阻塞状态是指线程因为某些原因放弃CPU，暂时停止运行。当线程处于阻塞状态时，Java虚拟机不会给线程分配CPU，直到线程重新进入就绪状态，它才会有机会获得运行状态。</p>
<p><strong>阻塞状态分为三种:</strong></p>
<p>1、等待阻塞:运行的线程执行wait（）方法，JVM会把该线程放入等待池中。</p>
<p>2、同步阻塞:运行的线程在获取对象同步锁时，若该同步锁被别的线程占用，则JVM会把线程放入锁池中。</p>
<p>3、其他阻塞:运行的线程执行Sleep（）方法，或者发出I/O请求时，JVM会把线程设为阻塞状态。当Sleep（）状态超时、或者I/O处理完毕时，线程重新转入就绪状态。</p>
<p><strong>6.死亡状态</strong></p>
<p>当线程执行完run()方法中的代码，或者遇到了未捕获的异常，就会退出run()方法，此时就进入死亡状态，该线程结束生命周期。</p>
<h3 id="十三、java写一段代码读取C-test-txt文件"><a href="#十三、java写一段代码读取C-test-txt文件" class="headerlink" title="十三、java写一段代码读取C:\test.txt文件"></a>十三、java写一段代码读取C:\test.txt文件</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.Files;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.Path;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.Paths;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Path path = Paths.get(<span class="string">&quot;C:/test.txt&quot;</span>);</span><br><span class="line">        <span class="keyword">byte</span>[] data = Files.readAllBytes(path);</span><br><span class="line">        String result = <span class="keyword">new</span> String(data, <span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>问题整理：</p>
<ol>
<li><p>了解path类</p>
<p><strong>Path用于来表示文件路径和文件</strong>。</p>
<p>创建path对象的常用方式,要注意异常的处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.以当前路径创建Path对象</span></span><br><span class="line">String filePath = <span class="string">&quot;E:\\tempCSDN\\Paths&quot;</span>;</span><br><span class="line">Path path = Paths.get(filePath);</span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line">     <span class="keyword">if</span>(!Files.exists(target2))</span><br><span class="line">         Files.createFile(target2);</span><br><span class="line"> &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">     e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>files类</p>
<p>files类被path类取代了</p>
</li>
<li><p>String构造方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">byte</span>[] bytes, String charsetName)</span></span></span><br></pre></td></tr></table></figure>

<p>通过使用指定的charset解码指定的 byte 数组，构造一个新的 <code>String</code>。</p>
</li>
</ol>
<h3 id="十四、List、Map、Set三个接口，存取元素时，各有什么特点？"><a href="#十四、List、Map、Set三个接口，存取元素时，各有什么特点？" class="headerlink" title="十四、List、Map、Set三个接口，存取元素时，各有什么特点？"></a>十四、List、Map、Set三个接口，存取元素时，各有什么特点？</h3><p>List是有序存储，</p>
<p>Map时键值对存储，</p>
<p>Set不允许重复元素</p>
<h3 id="十五、SpringMVC（或Struts）、Spring、Hibernate（或MyBatis）分别是什么，用它有什么好处？谈谈你的理解。"><a href="#十五、SpringMVC（或Struts）、Spring、Hibernate（或MyBatis）分别是什么，用它有什么好处？谈谈你的理解。" class="headerlink" title="十五、SpringMVC（或Struts）、Spring、Hibernate（或MyBatis）分别是什么，用它有什么好处？谈谈你的理解。"></a>十五、SpringMVC（或Struts）、Spring、Hibernate（或MyBatis）分别是什么，用它有什么好处？谈谈你的理解。</h3><p>JavaEE体系结构包括四层，从上到下分别是<strong>应用层、Web层、业务层、持久层</strong>。Struts和SpringMVC是Web层的框架，Spring是业务层的框架，Hibernate和MyBatis是持久层的框架。</p>
<p><strong>为什么要使用SpringMVC？</strong></p>
<p>很多应用程序的问题在于处理业务数据的对象和显示业务数据的视图之间存在紧密耦合，通常，更新业务对象的命令都是从视图本身发起的，使视图对任何业务对象更改都有高度敏感性。而且，当多个视图依赖于同一个业务对象时是没有灵活性的。</p>
<p>SpringMVC是一种基于Java，实现了Web MVC设计模式，请求驱动类型的轻量级Web框架，即使用了MVC架构模式的思想，将Web层进行职责解耦。基于请求驱动指的就是使用请求-响应模型，框架的目的就是帮助我们简化开发，SpringMVC也是要简化我们日常Web开发。</p>
<p><strong>MVC设计模式</strong></p>
<p>MVC设计模式的任务是<strong>将包含业务数据的模块与显示模块的视图解耦</strong>。这是怎样发生的？在模型和视图之间引入重定向层可以解决问题。此重定向层是控制器，控制器将接收请求，执行更新模型的操作，然后通知视图关于模型更改的消息。</p>
<p><strong>SpringMVC的核心架构：</strong></p>
<p><img src="C:%5CUsers%5CPowerwenwh%5CDocuments%5CMyBlog%5Csource%5C_posts%5Cimgs%5C%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B8%80%E8%AE%B0%E5%BD%95%5C20190630145911981.png" alt="在这里插入图片描述"></p>
<p>具体流程：</p>
<p>（1）首先浏览器发送请求——&gt;DispatcherServlet，前端控制器收到请求后自己不进行处理，而是委托给其他的解析器进行处理，作为统一访问点，进行全局的流程控制；</p>
<p>（2）DispatcherServlet——&gt;HandlerMapping，处理器映射器将会把请求映射为HandlerExecutionChain对象（包含一个Handler处理器对象、多个HandlerInterceptor拦截器）对象；</p>
<p>（3）DispatcherServlet——&gt;HandlerAdapter，处理器适配器将会把处理器包装为适配器，从而支持多种类型的处理器，即适配器设计模式的应用，从而很容易支持很多类型的处理器；</p>
<p>（4）HandlerAdapter——&gt;调用处理器相应功能处理方法，并返回一个ModelAndView对象（包含模型数据、逻辑视图名）；</p>
<p>（5）ModelAndView对象（Model部分是业务对象返回的模型数据，View部分为逻辑视图名）——&gt; ViewResolver， 视图解析器将把逻辑视图名解析为具体的View；</p>
<p>（6）View——&gt;渲染，View会根据传进来的Model模型数据进行渲染，此处的Model实际是一个Map数据结构；</p>
<p>（7）返回控制权给DispatcherServlet，由DispatcherServlet返回响应给用户，到此一个流程结束。</p>
<p>==待总结==</p>
<h3 id="十六、sql语句"><a href="#十六、sql语句" class="headerlink" title="十六、sql语句"></a>十六、sql语句</h3><h3 id=""><a href="#" class="headerlink" title=""></a><img src="C:%5CUsers%5CPowerwenwh%5CDocuments%5CMyBlog%5Csource%5C_posts%5Cimgs%5C%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B8%80%E8%AE%B0%E5%BD%95%5Cimage-20210321153913927.png" alt="image-20210321153913927"></h3><p><strong>思路：对除了自动编号外的字段进行分组即可筛选出不重复的数据</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> tb_student_score(id <span class="type">int</span>,sid <span class="type">int</span>,name varchar2(<span class="number">20</span>),kid <span class="type">int</span>,kname varchar2(<span class="number">20</span>),score <span class="type">int</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">--插入数据</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_student_score <span class="keyword">values</span>(<span class="number">1</span>,<span class="number">2018001</span>,<span class="string">&#x27;张三&#x27;</span>,<span class="number">0001</span>,<span class="string">&#x27;数学&#x27;</span>,<span class="number">69</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_student_score <span class="keyword">values</span>(<span class="number">2</span>,<span class="number">2018002</span>,<span class="string">&#x27;李四&#x27;</span>,<span class="number">0001</span>,<span class="string">&#x27;数学&#x27;</span>,<span class="number">89</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_student_score <span class="keyword">values</span>(<span class="number">3</span>,<span class="number">2018001</span>,<span class="string">&#x27;张三&#x27;</span>,<span class="number">0001</span>,<span class="string">&#x27;数学&#x27;</span>,<span class="number">69</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_student_score <span class="keyword">values</span>(<span class="number">4</span>,<span class="number">2018002</span>,<span class="string">&#x27;李四&#x27;</span>,<span class="number">0002</span>,<span class="string">&#x27;语文&#x27;</span>,<span class="number">79</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_student_score <span class="keyword">values</span>(<span class="number">5</span>,<span class="number">2018001</span>,<span class="string">&#x27;张三&#x27;</span>,<span class="number">0002</span>,<span class="string">&#x27;语文&#x27;</span>,<span class="number">80</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_student_score <span class="keyword">values</span>(<span class="number">6</span>,<span class="number">2018002</span>,<span class="string">&#x27;李四&#x27;</span>,<span class="number">0002</span>,<span class="string">&#x27;语文&#x27;</span>,<span class="number">79</span>);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">commit</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--查询数据</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_student_score;</span><br><span class="line">ID    SID      NAME  KID    KNAME  SCORE</span><br><span class="line"><span class="number">1</span>    <span class="number">2018001</span>    张三    <span class="number">1</span>    数学    <span class="number">69</span></span><br><span class="line"><span class="number">2</span>    <span class="number">2018002</span>    李四    <span class="number">1</span>    数学    <span class="number">89</span></span><br><span class="line"><span class="number">3</span>    <span class="number">2018001</span>    张三    <span class="number">1</span>    数学    <span class="number">69</span></span><br><span class="line"><span class="number">4</span>    <span class="number">2018002</span>    李四    <span class="number">2</span>    语文    <span class="number">79</span></span><br><span class="line"><span class="number">5</span>    <span class="number">2018001</span>    张三    <span class="number">2</span>    语文    <span class="number">80</span></span><br><span class="line"><span class="number">6</span>    <span class="number">2018002</span>    李四    <span class="number">2</span>    语文    <span class="number">79</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--执行删除SQL语句</span></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> tb_student_score</span><br><span class="line"> <span class="keyword">where</span> id <span class="keyword">not</span> <span class="keyword">in</span> (</span><br><span class="line">                   <span class="keyword">select</span> <span class="built_in">min</span>(id)</span><br><span class="line">                     <span class="keyword">from</span> tb_student_score t</span><br><span class="line">                    <span class="keyword">group</span> <span class="keyword">by</span> t.sid, t.name, t.kid, t.kname, t.score</span><br><span class="line">                  );</span><br><span class="line"><span class="keyword">commit</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--查询数据</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_student_score;</span><br><span class="line">ID    SID        NAME    KID    KNAME        SCORE</span><br><span class="line"><span class="number">1</span>    <span class="number">2018001</span>    张三    <span class="number">1</span>          数学         <span class="number">69</span></span><br><span class="line"><span class="number">2</span>    <span class="number">2018002</span>    李四    <span class="number">1</span>          数学         <span class="number">89</span></span><br><span class="line"><span class="number">4</span>    <span class="number">2018002</span>    李四    <span class="number">2</span>          语文         <span class="number">79</span></span><br><span class="line"><span class="number">5</span>    <span class="number">2018001</span>    张三    <span class="number">2</span>          语文         <span class="number">80</span></span><br></pre></td></tr></table></figure>

<h3 id="十七、一个叫team的表，里面只有一个字段name，一共有4条记录，分别是a，b，c，d，对应四个球队，现在四个球队进行比赛，用一条sql语句显示所有可能的比赛组合。"><a href="#十七、一个叫team的表，里面只有一个字段name，一共有4条记录，分别是a，b，c，d，对应四个球队，现在四个球队进行比赛，用一条sql语句显示所有可能的比赛组合。" class="headerlink" title="十七、一个叫team的表，里面只有一个字段name，一共有4条记录，分别是a，b，c，d，对应四个球队，现在四个球队进行比赛，用一条sql语句显示所有可能的比赛组合。"></a>十七、一个叫team的表，里面只有一个字段name，一共有4条记录，分别是a，b，c，d，对应四个球队，现在四个球队进行比赛，用一条sql语句显示所有可能的比赛组合。</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> team a,team b <span class="keyword">where</span> a.name<span class="operator">&gt;</span>b.name;</span><br></pre></td></tr></table></figure>

<p>由于需求为讲四个球队两两组合，故我们可以考虑相当于两张一样的表进行笛卡尔积多表查询,由上可看到两两组合的所有可能，但是结合实际，组合(a,a),(b,b)……在比赛中是不可能出现的，而(a,b)和(b,a)组合相当于一样。<a target="_blank" rel="noopener" href="http://故需要加where条件a.name/">故需要加where条件a.name</a>&gt;b.name排除以上的情况发生</p>
<h3 id="十八、String的-substring-int-beginIndex-、concat-String-str-方法。"><a href="#十八、String的-substring-int-beginIndex-、concat-String-str-方法。" class="headerlink" title="十八、String的**substring(int beginIndex)、concat**(String str)方法。"></a>十八、String的**<a target="_blank" rel="noopener" href="https://tool.oschina.net/uploads/apidocs/jdk-zh/java/lang/String.html#substring(int)">substring</a><strong>(int beginIndex)、</strong><a target="_blank" rel="noopener" href="https://tool.oschina.net/uploads/apidocs/jdk-zh/java/lang/String.html#concat(java.lang.String)">concat</a>**(<a target="_blank" rel="noopener" href="https://tool.oschina.net/uploads/apidocs/jdk-zh/java/lang/String.html">String</a> str)方法。</h3><p><strong><a target="_blank" rel="noopener" href="https://tool.oschina.net/uploads/apidocs/jdk-zh/java/lang/String.html#substring(int)">substring</a></strong>(int beginIndex)</p>
<p>返回一个新的字符串，它是此字符串的一个子字符串。该子字符串从指定索引处的字符开始，直到此字符串末尾。</p>
<p>示例：</p>
<blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;unhappy&quot;</span>.substring(<span class="number">2</span>) returns <span class="string">&quot;happy&quot;</span></span><br><span class="line"><span class="string">&quot;Harbison&quot;</span>.substring(<span class="number">3</span>) returns <span class="string">&quot;bison&quot;</span></span><br><span class="line"><span class="string">&quot;emptiness&quot;</span>.substring(<span class="number">9</span>) returns <span class="string">&quot;&quot;</span> (an empty string)</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong><a target="_blank" rel="noopener" href="https://tool.oschina.net/uploads/apidocs/jdk-zh/java/lang/String.html#concat(java.lang.String)">concat</a></strong>(<a target="_blank" rel="noopener" href="https://tool.oschina.net/uploads/apidocs/jdk-zh/java/lang/String.html">String</a> str)</p>
<p>将指定字符串连接到此字符串的结尾。</p>
<p>如果参数字符串的长度为 <code>0</code>，则返回此 <code>String</code> 对象。否则，创建一个新的 <code>String</code> 对象，用来表示由此 <code>String</code> 对象表示的字符序列和参数字符串表示的字符序列连接而成的字符序列。</p>
<p>示例：</p>
<blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;cares&quot;</span>.concat(<span class="string">&quot;s&quot;</span>) returns <span class="string">&quot;caress&quot;</span></span><br><span class="line"><span class="string">&quot;to&quot;</span>.concat(<span class="string">&quot;get&quot;</span>).concat(<span class="string">&quot;her&quot;</span>) returns <span class="string">&quot;together&quot;</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="十九、Javascript相关"><a href="#十九、Javascript相关" class="headerlink" title="十九、Javascript相关"></a>十九、Javascript相关</h3><p>以下哪一条Javascript语句会产生运行错误？</p>
<ul>
<li><p>```<br>var obj=( );//错误</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- &#96;&#96;&#96;</span><br><span class="line">  var obj&#x3D;[ ];&#x2F;&#x2F;声明obj为数组对象</span><br></pre></td></tr></table></figure></li>
<li><p>```<br>var obj={ };//声明obj为对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- &#96;&#96;&#96;</span><br><span class="line">  var obj&#x3D;&#x2F; &#x2F;;&#x2F;&#x2F;声明obj为正则对象</span><br></pre></td></tr></table></figure></li>
</ul>
<p>foo对象有att属性，那么获取att属性的值，以下哪些做法是可以的：（javascript）</p>
<p>javascrit获取对象属性的方法有两种：分别是采用’.’和[]。所以ADE都正确</p>
<ul>
<li><p>```<br>foo[“att”]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- &#96;&#96;&#96;</span><br><span class="line">  foo(&quot;att&quot;)</span><br></pre></td></tr></table></figure></li>
<li><p>```<br>foo{“att”}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- &#96;&#96;&#96;</span><br><span class="line">  foo.att</span><br></pre></td></tr></table></figure></li>
<li><p>```<br>foo[[“a”,”t”,”t”].join(“”)]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 二十、html相关</span><br><span class="line"></span><br><span class="line">在不指定特殊属性的情况下，以下标签可以手动输入文本的是B</span><br><span class="line"></span><br><span class="line">&#96;&lt;textarea&gt;&#96; 标签定义多行的文本输入控件。</span><br><span class="line"></span><br><span class="line">&#96;&lt;input type&#x3D;&quot;hidden&quot;&#x2F;&gt;&#96;  </span><br><span class="line">&#96;&lt;textarea&gt;&lt;&#x2F;textarea&gt;&#96;  </span><br><span class="line">&#96;&lt;div&gt;&lt;&#x2F;div&gt;&#96;  </span><br><span class="line">&#96;&lt;a&gt;&lt;&#x2F;a&gt;&#96;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">table标签</span><br><span class="line"></span><br><span class="line">**定义和用法**</span><br><span class="line"></span><br><span class="line">简单的 HTML 表格由 table 元素以及一个或多个 tr、th 或 td 元素组成。</span><br><span class="line"></span><br><span class="line">**tr 元素定义表格行，th 元素定义表头，td 元素定义表格单元。**</span><br><span class="line"></span><br><span class="line">更复杂的 HTML 表格也可能包括 caption、col、colgroup、thead、tfoot 以及 tbody 元素。</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;html</span><br><span class="line">&lt;p&gt;每个表格由 table 标签开始。&lt;&#x2F;p&gt;</span><br><span class="line">&lt;p&gt;每个表格行由 tr 标签开始。&lt;&#x2F;p&gt;</span><br><span class="line">&lt;p&gt;每个表格数据由 td 标签开始。&lt;&#x2F;p&gt;</span><br><span class="line"></span><br><span class="line">&lt;h4&gt;一列：&lt;&#x2F;h4&gt;</span><br><span class="line">&lt;table border&#x3D;&quot;1&quot;&gt;&#x2F;&#x2F;规定表格边框的宽度。</span><br><span class="line">&lt;tr&gt;</span><br><span class="line">  &lt;td&gt;100&lt;&#x2F;td&gt;</span><br><span class="line">&lt;&#x2F;tr&gt;</span><br><span class="line">&lt;&#x2F;table&gt;</span><br><span class="line"></span><br><span class="line">&lt;h4&gt;一行三列：&lt;&#x2F;h4&gt;</span><br><span class="line">&lt;table border&#x3D;&quot;1&quot;&gt;</span><br><span class="line">&lt;tr&gt;</span><br><span class="line">  &lt;td&gt;100&lt;&#x2F;td&gt;</span><br><span class="line">  &lt;td&gt;200&lt;&#x2F;td&gt;</span><br><span class="line">  &lt;td&gt;300&lt;&#x2F;td&gt;</span><br><span class="line">&lt;&#x2F;tr&gt;</span><br><span class="line">&lt;&#x2F;table&gt;</span><br><span class="line"></span><br><span class="line">&lt;h4&gt;两行三列：&lt;&#x2F;h4&gt;</span><br><span class="line">&lt;table border&#x3D;&quot;1&quot;&gt;</span><br><span class="line">&lt;tr&gt;</span><br><span class="line">  &lt;td&gt;100&lt;&#x2F;td&gt;</span><br><span class="line">  &lt;td&gt;200&lt;&#x2F;td&gt;</span><br><span class="line">  &lt;td&gt;300&lt;&#x2F;td&gt;</span><br><span class="line">&lt;&#x2F;tr&gt;</span><br><span class="line">&lt;tr&gt;</span><br><span class="line">  &lt;td&gt;400&lt;&#x2F;td&gt;</span><br><span class="line">  &lt;td&gt;500&lt;&#x2F;td&gt;</span><br><span class="line">  &lt;td&gt;600&lt;&#x2F;td&gt;</span><br><span class="line">&lt;&#x2F;tr&gt;</span><br><span class="line">&lt;&#x2F;table&gt;</span><br></pre></td></tr></table></figure></li>
</ul>


<h3 id="二十一、请你根据任意一个外卖app的使用经历，画出你所理解的外卖的流程。请画出主要的环节，以及每个环节涉及的角色。（比如用户、商家等）"><a href="#二十一、请你根据任意一个外卖app的使用经历，画出你所理解的外卖的流程。请画出主要的环节，以及每个环节涉及的角色。（比如用户、商家等）" class="headerlink" title="二十一、请你根据任意一个外卖app的使用经历，画出你所理解的外卖的流程。请画出主要的环节，以及每个环节涉及的角色。（比如用户、商家等）"></a>二十一、请你根据任意一个外卖app的使用经历，画出你所理解的外卖的流程。请画出主要的环节，以及每个环节涉及的角色。（比如用户、商家等）</h3>

<p>二十二、图形题解题技巧</p>
<ol>
<li><p>三角形或圆心类：找周围的数字与圆心数字关系</p>
<p>例子：</p>
</li>
<li><p>图形题目：观察点的数目，线的数目（直线、曲线、线头），笔画，角（有无，角度，数目），面（封闭区域数，部分数），对称（对称轴）</p>
</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://wenwenhuan.gitee.io/2021/03/07/Java%E4%B8%AD%E5%B8%83%E5%B0%94%E7%B1%BB%E5%9E%8B%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E4%BD%BF%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="温文焕">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wenhuan Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/03/07/Java%E4%B8%AD%E5%B8%83%E5%B0%94%E7%B1%BB%E5%9E%8B%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E4%BD%BF%E7%94%A8/" class="post-title-link" itemprop="url">Java中布尔类型运算符的使用</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-03-07 22:08:32 / 修改时间：15:18:32" itemprop="dateCreated datePublished" datetime="2021-03-07T22:08:32+08:00">2021-03-07</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="amp-，-与-的使用"><a href="#amp-，-与-的使用" class="headerlink" title="&amp;=，|=与^=的使用"></a>&amp;=，|=与^=的使用</h2><p>1.&amp;=<br>true &amp;= true ==&gt; true<br>true &amp;= false ==&gt; false<br>false &amp;= true ==&gt; false<br>false &amp;= false ==&gt; false</p>
<p>2.|=<br>true |= true ==&gt; true<br>true |= false ==&gt; true<br>false |= true ==&gt; true<br>false |= false ==&gt; false</p>
<p>3.^=(异或)<br>相同为假，不同为真<br>(男性和女性能生出孩子，否则就不行。)<br>true ^= true ==&gt; false<br>true ^= false ==&gt; true<br>false ^= true ==&gt; true<br>false ^= false ==&gt; false</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://wenwenhuan.gitee.io/2021/03/07/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="温文焕">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wenhuan Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/03/07/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D/" class="post-title-link" itemprop="url">正则表达式匹配</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-03-07 10:00:00 / 修改时间：15:50:58" itemprop="dateCreated datePublished" datetime="2021-03-07T10:00:00+08:00">2021-03-07</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="正则表达式匹配"><a href="#正则表达式匹配" class="headerlink" title="正则表达式匹配"></a>正则表达式匹配</h2><p>请实现一个函数用来匹配包含’. ‘和’※’的正则表达式。模式中的字符’.’表示任意一个字符，而”※”表示它前面的字符可以出现任意次（含0次）。在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串”aaa”与模式”a.a”和”ab<em>ac</em>a”匹配，但与”aa.a”和”ab*a”均不匹配。</p>
<h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><p>本题的思路选用<strong>动态规划</strong>的思路解题，构造动态规划矩阵来推导结果。对我来说难点在如何分，分几种情况考虑。并且※可以代表没有和无数次，用一般的方法很难用编程语言描述。</p>
<blockquote>
<p>假设主串为 A，模式串为 B 从最后一步出发，需要关注最后进来的字符。假设 A 的长度为 n ，B 的长度为 m ，关注正则表达式 B 的最后一个字符是谁，它有三种可能，正常字符、∗ 和 .（点），那针对这三种情况讨论即可，如下：</p>
<ol>
<li><p>如果 B 的最后一个字符是正常字符，那就是看 A[n-1] 是否等于 B[m-1]，相等则看 A_{0..n-2}与 B_{0..m-2}，不等则是不能匹配，这就是子问题。</p>
</li>
<li><p>如果 B 的最后一个字符是.，它能匹配任意字符，直接看 A_{0..n-2}与 B_{0..m-2}</p>
</li>
<li><p>如果 B 的最后一个字符是∗它代表 B[m-2]=c 可以重复0次或多次，它们是一个整体 c∗4</p>
<ul>
<li>情况一：A[n-1] 是 0 个 c，B 最后两个字符废了，能否匹配取决于 A_{0..n-1}和 B_{0..m-3}是否匹配</li>
<li>情况二：A[n-1]是多个 c 中的最后一个（这种情况必须 A[n-1]=c或者 c=’.’），所以 A 匹配完往前挪一个，B 继续匹配，因为可以匹配多个，继续看 A_{0..n-2}和 B_{0..m-1}是否匹配。</li>
</ul>
<h3 id="转移方程"><a href="#转移方程" class="headerlink" title="转移方程"></a>转移方程</h3><p>f[i][j] 代表 A 的前 i 个和 B 的前 j 个能否匹配</p>
<p>对于前面两个情况，可以合并成一种情况 f[i][j] = f[i-1][j-1]</p>
<p>对于第三种情况，对于 c∗ 分为看和不看两种情况</p>
<p>不看：直接砍掉正则串的后面两个， f[i][j] = f[i][j-2]<br>看：正则串不动，主串前移一个，f[i][j] = f[i-1][j]</p>
<h3 id="初始条件"><a href="#初始条件" class="headerlink" title="初始条件"></a>初始条件</h3><p>特判：需要考虑空串空正则</p>
<p>空串和空正则是匹配的，f[0][0] = true<br>空串和非空正则，不能直接定义 true 和 false，必须要计算出来。（比如A= ‘’ ‘’ ,B=a∗b∗c）<br>非空串和空正则必不匹配，f[1][0]=…=f[n][0]=false<br>非空串和非空正则，那肯定是需要计算的了。<br>大体上可以分为空正则和非空正则两种，空正则也是比较好处理的，对非空正则我们肯定需要计算，非空正则的三种情况，前面两种可以合并到一起讨论，第三种情况是单独一种，那么也就是分为当前位置是 ∗ 和不是 ∗ 两种情况了。</p>
<h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><p>我们开数组要开 n+1 ，这样对于空串的处理十分方便。结果就是 f[n][m]</p>
</li>
</ol>
</blockquote>
<p>看完解题思路，觉得这道题的关键是理解和分析出转移方程，也是动态规划的核心。细节方面则是需要考虑空串和空正则。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String A, String B)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = A.length();</span><br><span class="line">        <span class="keyword">int</span> m = B.length();</span><br><span class="line">        <span class="keyword">boolean</span>[][] f = <span class="keyword">new</span> <span class="keyword">boolean</span>[n + <span class="number">1</span>][m + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= m; j++) &#123;</span><br><span class="line">                <span class="comment">//分成空正则和非空正则两种</span></span><br><span class="line">                <span class="keyword">if</span> (j == <span class="number">0</span>) &#123;</span><br><span class="line">                    f[i][j] = i == <span class="number">0</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//非空正则分为两种情况 * 和 非*</span></span><br><span class="line">                    <span class="keyword">if</span> (B.charAt(j - <span class="number">1</span>) != <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; (A.charAt(i - <span class="number">1</span>) == B.charAt(j - <span class="number">1</span>) || B.charAt(j - <span class="number">1</span>) == <span class="string">&#x27;.&#x27;</span>)) &#123;</span><br><span class="line">                            f[i][j] = f[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">//碰到 * 了，分为看和不看两种情况</span></span><br><span class="line">                        <span class="comment">//不看</span></span><br><span class="line">                        <span class="keyword">if</span> (j &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">                            f[i][j] |= f[i][j - <span class="number">2</span>];</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//看</span></span><br><span class="line">                        <span class="keyword">if</span> (i &gt;= <span class="number">1</span> &amp;&amp; j &gt;= <span class="number">2</span> &amp;&amp; (A.charAt(i - <span class="number">1</span>) == B.charAt(j - <span class="number">2</span>) || B.charAt(j - <span class="number">2</span>) == <span class="string">&#x27;.&#x27;</span>)) &#123;</span><br><span class="line">                            f[i][j] |= f[i - <span class="number">1</span>][j];</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[n][m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://wenwenhuan.gitee.io/2021/03/03/Java%E4%B8%AD%E7%9A%84%E9%99%A4%E6%B3%95%E4%BF%9D%E7%95%99%E5%85%A8%E9%83%A8%E5%B0%8F%E6%95%B0%E4%BD%8D/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="温文焕">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wenhuan Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/03/03/Java%E4%B8%AD%E7%9A%84%E9%99%A4%E6%B3%95%E4%BF%9D%E7%95%99%E5%85%A8%E9%83%A8%E5%B0%8F%E6%95%B0%E4%BD%8D/" class="post-title-link" itemprop="url">Java中的除法保留全部小数位</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-03-03 16:08:32" itemprop="dateCreated datePublished" datetime="2021-03-03T16:08:32+08:00">2021-03-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2021-03-04 09:28:16" itemprop="dateModified" datetime="2021-03-04T09:28:16+08:00">2021-03-04</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>情景展示</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> a = <span class="number">1</span>/<span class="number">10</span>;</span><br><span class="line">System.out.println(d);<span class="comment">//0.0</span></span><br></pre></td></tr></table></figure>

<p>用int类型接受也可以</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>/<span class="number">10</span>;</span><br><span class="line">System.out.println(d);<span class="comment">//0</span></span><br></pre></td></tr></table></figure>

<p>没有报错，因为在Java中整数之间 的除法运算，不管小数位有几位，小数是几，都会舍弃，只返回整数位数字。</p>
<p>之所以用double类型接受也可以，是因为double类型的取值要大于int类型，属于向上类型转换，Java会自动转换。使用float或long类型接受也没有问题。</p>
<p>在Java中，运算结果由被运算数的最高数据类型决定。所以想要得到完整的运算结果只需要将其中一个数据类型转换为double类型或float类型，而不是只改变接受运算结果的数据类型。 </p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://wenwenhuan.gitee.io/2021/02/28/Java%E6%8E%A5%E5%8F%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="温文焕">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wenhuan Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/02/28/Java%E6%8E%A5%E5%8F%A3/" class="post-title-link" itemprop="url">Java中的接口</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-02-28 22:08:32 / 修改时间：22:09:04" itemprop="dateCreated datePublished" datetime="2021-02-28T22:08:32+08:00">2021-02-28</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="Java接口"><a href="#Java接口" class="headerlink" title="Java接口"></a>Java接口</h2><h3 id="1、几个问题"><a href="#1、几个问题" class="headerlink" title="1、几个问题"></a>1、几个问题</h3><ol>
<li><p>为什么不直接在类里面写对应的方法, 而要多写1个接口(或抽象类)?</p>
</li>
<li><p>既然接口跟抽象类差不多, 什么情况下要用接口而不是抽象类.</p>
</li>
<li><p>为什么interface叫做接口呢? 跟一般范畴的接口例如usb接口, 显卡接口有什么联系呢?</p>
</li>
</ol>
<h3 id="2、接口是不可以被实例化-但是接口引用可以指向1个实现该接口的对象"><a href="#2、接口是不可以被实例化-但是接口引用可以指向1个实现该接口的对象" class="headerlink" title="2、接口是不可以被实例化, 但是接口引用可以指向1个实现该接口的对象."></a>2、<strong>接口是不可以被实例化, 但是接口引用可以指向1个实现该接口的对象.</strong></h3><p>假如类A impletments 了接口B</p>
<p>那么下面是合法的:</p>
<p><code>B b = new A();</code></p>
<p>也可以把A的对象强制转换为 接口B的对象</p>
<p><code>A a = new A90; B b = (B)a;</code></p>
<p>这个特性是下面内容的前提.</p>
<h3 id="3、接口-或抽象类-的存在是为了多态的实现"><a href="#3、接口-或抽象类-的存在是为了多态的实现" class="headerlink" title="3、接口(或抽象类)的存在是为了多态的实现."></a>3、接口(或抽象类)的存在是为了多态的实现.</h3><p>详细代码用抽象举1个例子：</p>
<p>先定义几个类,</p>
<p>动物(Animal) 抽象类</p>
<p>爬行动物(Reptile) 抽象类  继承动物类</p>
<p>哺乳动物(Mammal) 抽象类 继承动物类</p>
<p>山羊(Goat) 继承哺乳动物类<br>老虎(Tiger)  继承哺乳动物类<br>兔子(Rabbit) 继承哺乳动物类<br>蛇(Snake)   继承爬行动物类</p>
<p>农夫(Farmer)   没有继承任何类 但是农夫可以给Animal喂水(依赖关系)</p>
<h4 id="3-1-Animal类"><a href="#3-1-Animal类" class="headerlink" title="3.1 Animal类"></a>3.1 Animal类</h4><p>这个是抽象类, 显示也没有”动物” 这种实体</p>
<p>类里面包含3个抽象方法.</p>
<ol>
<li><p>静态方法getName()</p>
</li>
<li><p>移动方法move(), 因为动物都能移动.  但是各种动物有不同的移动方法, 例如老虎和山羊会跑着移动, 兔子跳着移动, 蛇会爬着移动.</p>
</li>
</ol>
<p><u>作为抽象基类, 我们不关心继承的实体类是如何移动的, 所以移动方法move()是1个抽象方法.  这个就是多态的思想.</u></p>
<ol start="3">
<li>喝水方法drink(), 同样, 各种动物有各种饮水方法. 这个也是抽象方法.</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    </span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">(String destination)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">drink</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-2-Mammal类"><a href="#3-2-Mammal类" class="headerlink" title="3.2 Mammal类"></a>3.2 Mammal类</h4><p>这个是继承动物类的哺乳动物类, 后面的老虎山羊等都继承自这个类.<br>Mammal类自然继承了Animal类的3个抽象方法, 实体类不再用写其他代码.</p>
<p><code>abstract class Mammal extends Animal&#123;&#125;</code></p>
<h4 id="3-3-Reptile类"><a href="#3-3-Reptile类" class="headerlink" title="3.3 Reptile类"></a>3.3 Reptile类</h4><p>这个是代表爬行动物的抽象类, 同上, 都是继承自Animal类.<br><code>abstract class Reptile extends Animal&#123;&#125;</code></p>
<p>3.4 Tiger类<br><u>老虎类就是1个实体类, 所以它必须重写所有继承自超类的抽象方法</u>, 至于那些方法如何重写, 则取决于老虎类本身.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tiger</span> <span class="keyword">extends</span> <span class="title">Mammal</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String name = <span class="string">&quot;Tiger&quot;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">(String destination)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Goat moved to &quot;</span> + destination + <span class="string">&quot;.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drink</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Goat lower it&#x27;s head and drink.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<p>如上, 老虎的移动方法很普通, 低头喝水.</p>
<h4 id="3-5-Goat类-和-Rabbit类"><a href="#3-5-Goat类-和-Rabbit类" class="headerlink" title="3.5 Goat类 和 Rabbit类"></a>3.5 Goat类 和 Rabbit类</h4><p>这个两个类与Tiger类似, 它们都继承自Mammal这个类.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Goat</span> <span class="keyword">extends</span> <span class="title">Mammal</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String name = <span class="string">&quot;Goat&quot;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">(String destination)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Goat moved to &quot;</span> + destination + <span class="string">&quot;.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drink</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Goat lower it&#x27;s head and drink.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>兔子: 喝水方法有点区别</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rabbit</span> <span class="keyword">extends</span> <span class="title">Mammal</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String name = <span class="string">&quot;Rabbit&quot;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">(String destination)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Rabbit moved to &quot;</span> + destination + <span class="string">&quot;.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drink</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Rabbit put out it&#x27;s tongue and drink.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="3-6-Snake类"><a href="#3-6-Snake类" class="headerlink" title="3.6 Snake类"></a>3.6 Snake类</h4><p>蛇类继承自Reptile(爬行动物)<br>移动方法和喝水方法都跟其他3动物有点区别.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Snake</span> <span class="keyword">extends</span> <span class="title">Reptile</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String name = <span class="string">&quot;Snake&quot;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">(String destination)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Snake crawled to &quot;</span> + destination + <span class="string">&quot;.&quot;</span>);</span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drink</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Snake dived into water and drink.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-7-Farmer-类"><a href="#3-7-Farmer-类" class="headerlink" title="3.7 Farmer 类"></a>3.7 Farmer 类</h4><p>Farmer类不属于 Animal类族, 但是Farmer农夫可以给各种动物, 喂水.</p>
<p>Farmer类有2个关键方法, 一个是<br><code>bringWater(String destination)</code>    –&gt; 把水带到某个地点</p>
<p>另1个就是<code>feedWater()</code>了, </p>
<p>feedWater这个方法分为三步:</p>
<p>首先是农夫带水到饲养室,(<code>bringWater())</code></p>
<p>接着被喂水动物走到饲养室,(<code>move()</code>)</p>
<p>接着动物喝水(<code>drink()</code>)</p>
<p>Farmer可以给老虎喂水, 可以给山羊喂水, 还可以给蛇喂水, 那么feedWater()里的参数类型到底是老虎,山羊还是蛇呢.</p>
<p>实际上<u>因为老虎,山羊, 蛇都继承自Animal这个类, 所以feedWater里的参数类型设为Animal就可以了.</u></p>
<p>Farmer类首先调用bringWater(“饲养室”),<br>至于<u>这个动物是如何走到饲养室和如何喝水的, Farmer类则不用关心.</u></p>
<p><u>因为执行时, Animal超类会根据引用指向的对象类型不同 而 指向不同的被重写的方法.  这个就是多态的意义.</u></p>
<p>代码如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Farmer</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bringWater</span><span class="params">(String destination)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Farmer bring water to &quot;</span> + destination + <span class="string">&quot;.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">feedWater</span><span class="params">(Animal a)</span></span>&#123; <span class="comment">// polymorphism多态性</span></span><br><span class="line">        <span class="keyword">this</span>.bringWater(<span class="string">&quot;Feeding Room&quot;</span>);</span><br><span class="line">        a.move(<span class="string">&quot;Feeding Room&quot;</span>);</span><br><span class="line">        a.drink();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="3-7-执行农夫喂水的代码"><a href="#3-7-执行农夫喂水的代码" class="headerlink" title="3.7 执行农夫喂水的代码."></a>3.7 执行农夫喂水的代码.</h4><p>下面的代码是1个农夫依次喂水给一只老虎, 一只羊, 以及一条蛇</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Farmer fm = <span class="keyword">new</span> Farmer();</span><br><span class="line">        Snake sn = <span class="keyword">new</span> Snake();</span><br><span class="line">        Goat gt = <span class="keyword">new</span> Goat();</span><br><span class="line">        Tiger tg = <span class="keyword">new</span> Tiger();</span><br><span class="line"> </span><br><span class="line">        fm.feedWater(sn);</span><br><span class="line">        fm.feedWater(gt);</span><br><span class="line">        fm.feedWater(tg);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h4 id="3-8总结"><a href="#3-8总结" class="headerlink" title="3.8总结"></a>3.8总结</h4><p>农夫只负责带水过去制定地点, 而不必关心老虎, 蛇, 山羊它们是如何过来的. 它们如何喝水. 这些农夫都不必关心.<br>只需要调用同1个方法<code>feedWater()</code>.  </p>
<p>不使用多态的后果:<br>而如果老虎, 蛇, 山羊的<code>drink() </code>方法不是重写自同1个抽象方法的话, 多态就不能实现.<br><u>农夫类就可能要根据参数类型的不同而重载很多个 <code> feedWater()</code>方法了.</u></p>
<p>而且每增加1个类(例如 狮子Lion)</p>
<p>就需要在农夫类里增加1个feedWater的重载方法<code> feedWater(Lion l)</code>…</p>
<p>而接口跟抽象类类似,<br>这个就回答了本文第一个问题.<br>1.为什么不直接在类里面写对应的方法,  而要多写1个接口(或抽象类)?</p>
<h3 id="4、抽象类解决不了的问题"><a href="#4、抽象类解决不了的问题" class="headerlink" title="4、抽象类解决不了的问题."></a>4、抽象类解决不了的问题.</h3><p>既然抽象类很好地实现了多态性, 那么什么情况下用接口会更加好呢?</p>
<p>对于上面的例子, 我们加一点需求.</p>
<p>Farmer 农夫多了1个技能, 就是给另1个动物喂兔子(囧).</p>
<p><code>BringAnimal(Animal a, String destination)  </code> 把兔子带到某个地点…</p>
<p><code>feedAnimal(Animal ht, Animal a) </code> 把动物a丢给动物ht</p>
<p>注意农夫并没有把兔子宰了, 而是把小动物(a)丢给另1个被喂食的动物(ht).</p>
<p>那么问题来了, 那个动物必须有捕猎这个技能.  也就是我们要给被喂食的动物加上1个方法(捕猎) <code>hunt(Animal a)</code>.</p>
<p>但是现实上不是所有动物都有捕猎这个技能的, 所以我们不应该把<code>hunt(Animal a)</code>方法加在Goat类和Rabbit类里,  只加在Tiger类和Snake类里.</p>
<p>而且老虎跟蛇的捕猎方法也不一样, 则表明<u>hunt()的方法体在Tiger类里和Snake类里是不一样的.</u></p>
<p>下面有3个方案.</p>
<ol>
<li><p>分别在Tiger类里和Snake类里加上Hunt() 方法.  其它类(例如Goat) 不加.</p>
</li>
<li><p>在基类Animal里加上Hunt()抽象方法. 在Tiger里和Snake里重写这个Hunt() 方法.</p>
</li>
<li><p>添加肉食性动物这个抽象类.   </p>
</li>
</ol>
<p>先来说第1种方案.</p>
<p>这种情况下, Tiger里的<code>Hunt(Animal a)</code>方法与 Snake里的<code>Hunt(Animal a)</code>方法毫无关联. 也就是说不能利用多态性.</p>
<p>导致Farm类里的<code>feedAnimal()</code>方法需要分别为Tiger 与 Snake类重载. 否决.</p>
<p>第2种方案:</p>
<p>如果在抽象类Animal里加上<code>Hunt()</code>方法, 则所有它的非抽象派生类都要重写实现这个方法, 包括 Goat类和 Rabbit类.</p>
<p>这是不合理的, 因为Goat类根本没必要用到Hunt()方法, 造成了资源(内存)浪费.</p>
<p>第3种方案:<br>加入我们在哺乳类动物下做个分叉, 加上肉食性哺乳类动物, 非肉食性哺乳动物这两个抽象类?</p>
<p>首先,<br>肉食性这种分叉并不准确, 例如很多腐蚀性动物不会捕猎, 但是它们是肉食性.</p>
<p>其次</p>
<p>这种方案会另类族图越来越复杂, 假如以后再需要辨别能否飞的动物呢, 增加飞翔 <code>fly()</code>这个方法呢? 是不是还要分叉?</p>
<p>再次,</p>
<p>很现实的问题, 在项目中, 你很可能没机会修改上层的类代码, 因为它们是用Jar包发布的, 或者你没有修改权限.</p>
<p>这种情况下就需要用到接口了.</p>
<h3 id="5、接口与多态-以及-多继承性"><a href="#5、接口与多态-以及-多继承性" class="headerlink" title="5、接口与多态 以及 多继承性."></a>5、接口与多态 以及 多继承性.</h3><p>上面的问题, 抽象类解决不了, 根本问题是Java的类不能多继承.</p>
<p>因为Tiger类继承了动物Animal类的特性(例如 move() 和 drink()) , 但是严格上来将 捕猎(hunt())并不算是动物的特性之一. 有些植物, 单细胞生物也会捕猎的.</p>
<p>所以Tiger要从别的地方来继承Hunt()这个方法.  接口就发挥作用了.</p>
<h4 id="5-1-Huntable接口"><a href="#5-1-Huntable接口" class="headerlink" title="5.1 Huntable接口"></a>5.1 Huntable接口</h4><p>我们增加1个Huntable接口.</p>
<p>接口里有1个方法hunt(Animal a), 就是捕捉动物, 至于怎样捕捉则由实现接口的类自己决定.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Huntable</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hunt</span><span class="params">(Animal a)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-2-Tiger-类"><a href="#5-2-Tiger-类" class="headerlink" title="5.2 Tiger 类"></a>5.2 Tiger 类</h4><p>既然定义了1个Huntable(可以捕猎的)接口.</p>
<p>Tiger类就要实现这个接口并重写接口里hunt()方法.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tiger</span> <span class="keyword">extends</span> <span class="title">Mammal</span> <span class="keyword">implements</span> <span class="title">Huntable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String name = <span class="string">&quot;Tiger&quot;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">(String destination)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Goat moved to &quot;</span> + destination + <span class="string">&quot;.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drink</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Goat lower it&#x27;s head and drink.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hunt</span><span class="params">(Animal a)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Tiger catched &quot;</span> + a.getName() + <span class="string">&quot; and eated it&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-3-Snake类"><a href="#5-3-Snake类" class="headerlink" title="5.3 Snake类"></a>5.3 Snake类</h4><p>同样:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Snake</span> <span class="keyword">extends</span> <span class="title">Reptile</span> <span class="keyword">implements</span> <span class="title">Huntable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String name = <span class="string">&quot;Snake&quot;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">(String destination)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Snake crawled to &quot;</span> + destination + <span class="string">&quot;.&quot;</span>);</span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drink</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Snake dived into water and drink.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hunt</span><span class="params">(Animal a)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Snake coiled &quot;</span> + a.getName() + <span class="string">&quot; and eated it&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可见同样实现接口的<code>hunt()</code>方法, 但是蛇与老虎的捕猎方法是有区别的.</p>
<h4 id="5-4-Farmer类"><a href="#5-4-Farmer类" class="headerlink" title="5.4 Farmer类"></a>5.4 Farmer类</h4><p>这样的话. Farmer类里的<code>feedAnimal(Animal ht, Animal a)</code>就可以实现多态了.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Farmer</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bringWater</span><span class="params">(String destination)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Farmer bring water to &quot;</span> + destination + <span class="string">&quot;.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bringAnimal</span><span class="params">(Animal a,String destination)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Farmer bring &quot;</span> + a.getName() + <span class="string">&quot; to &quot;</span> + destination + <span class="string">&quot;.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">feedWater</span><span class="params">(Animal a)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.bringWater(<span class="string">&quot;Feeding Room&quot;</span>);</span><br><span class="line">        a.move(<span class="string">&quot;Feeding Room&quot;</span>);</span><br><span class="line">        a.drink();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">feedAnimal</span><span class="params">(Animal ht , Animal a)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.bringAnimal(a,<span class="string">&quot;Feeding Room&quot;</span>);</span><br><span class="line">        ht.move(<span class="string">&quot;Feeding Room&quot;</span>);</span><br><span class="line">        Huntable hab = (Huntable)ht;</span><br><span class="line">        hab.hunt(a);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关键是这一句<br><code>Huntable hab = (Huntable)ht;</code><br>本文一开始讲过了, 接口的引用可以指向实现该接口的对象.<br>当然, 如果把Goat对象传入Farmer的feedAnimal()里就会有异常, 因为Goat类没有实现该接口. 上面那个代码执行失败.</p>
<p>如果要避免上面的问题.</p>
<p>可以修改feedAnimal方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">feedAnimal</span><span class="params">(Huntable hab, Animal a)</span></span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.bringAnimal(a,<span class="string">&quot;Feeding Room&quot;</span>);</span><br><span class="line">      Animal ht = (Animal)hab;</span><br><span class="line">      ht.move(<span class="string">&quot;Feeding Room&quot;</span>);</span><br><span class="line">      hab.hunt(a);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>这样的话, 传入的对象就必须是实现了Huntable的对象, 如果把Goat放入就会编译报错.</p>
<p>但是里面一样有一句强制转换</p>
<p><code>Animal ht = (Animal)hab</code></p>
<p>反而更加不安全, 因为实现的Huntable的接口的类不一定都是Animal的派生类.<br>相反, 接口的出现就是鼓励多种不同的类实现同样的功能(方法)</p>
<p>例如,假如一个机械类也可以实现这个接口, 那么那个机械就可以帮忙打猎了(囧)</p>
<p>1个植物类(例如捕蝇草),实现这个接口, 也可以捕猎苍蝇了.</p>
<p>也就是说, <u>接口不会限制实现接口的类的类型.</u></p>
<p><u>这样, Tiger类与Snake类不但继承了Animal的方法, 还继承(实现)了接口Huntable的方法, 一定程度上弥补java的class不支持多继承的特点.</u></p>
<h3 id="6、接口上应用泛型"><a href="#6、接口上应用泛型" class="headerlink" title="6、接口上应用泛型."></a>6、接口上应用泛型.</h3><p>上面的Huntable里还是有点限制的,</p>
<p>就是它里面的hunt()方法的参数是 Animal a, 也就是说这个这个接口只能用于捕猎动物.</p>
<p>但是在java的世界里, 接口里的方法(行为)大多数是与类的类型无关的.</p>
<p>也就是说, Huntable接口里的hunt()方法里不单只可以捕猎动物, 还可以捕猎其他东西(例如 捕猎植物… 敌方机械等)</p>
<h4 id="6-1-Huntable接口"><a href="#6-1-Huntable接口" class="headerlink" title="6.1 Huntable接口"></a>6.1 Huntable接口</h4><p>首先要在Huntable接口上添加泛型标志:<T></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Huntable</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hunt</span><span class="params">(T o)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后里面的hunt()的参数的类型就写成T, 表示hunt()方法可以接受多种参数, 取决于实现接口的类.</p>
<h4 id="6-2-Tiger类-和Snake类"><a href="#6-2-Tiger类-和Snake类" class="headerlink" title="6.2 Tiger类(和Snake类)"></a>6.2 Tiger类(和Snake类)</h4><p>同样, 定义tiger类时必须加上接口的泛型标志<Animal>, 表示要把接口应用在Animal这种类型.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tiger</span> <span class="keyword">extends</span> <span class="title">Mammal</span> <span class="keyword">implements</span> <span class="title">Huntable</span>&lt;<span class="title">Animal</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String name = <span class="string">&quot;Tiger&quot;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">(String destination)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Goat moved to &quot;</span> + destination + <span class="string">&quot;.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drink</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Goat lower it&#x27;s head and drink.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hunt</span><span class="params">(Animal a)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Tiger catched &quot;</span> + a.getName() + <span class="string">&quot; and eated it&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样, 在里面hunt()参数就可以指明类型Animal了, 表示老虎虽然有捕猎这个行为, 但是只能捕猎动物.</p>
<h3 id="7、什么情况下应该使用接口而不用抽象类"><a href="#7、什么情况下应该使用接口而不用抽象类" class="headerlink" title="7、什么情况下应该使用接口而不用抽象类."></a>7、什么情况下应该使用接口而不用抽象类.</h3><p>好了, 回到本文最重要的一个问题.</p>
<p>做个总结</p>
<ol>
<li><p>需要实现多态</p>
</li>
<li><p>要实现的方法(功能)不是当前类族的必要(属性).</p>
</li>
<li><p>要为不同类族的多个类实现同样的方法(功能).</p>
</li>
</ol>
<h4 id="7-1-需要实现多态"><a href="#7-1-需要实现多态" class="headerlink" title="7.1 需要实现多态"></a>7.1 需要实现多态</h4><p>很明显, 接口其中一个存在意义就是为了实现多态. 这里不多说了.</p>
<p>而抽象类(继承) 也可以实现多态</p>
<h4 id="7-2-要实现的方法-功能-不是当前类族的必要-属性"><a href="#7-2-要实现的方法-功能-不是当前类族的必要-属性" class="headerlink" title="7.2. 要实现的方法(功能)不是当前类族的必要(属性)."></a>7.2. 要实现的方法(功能)不是当前类族的必要(属性).</h4><p>上面的例子就表明, 捕猎这个方法不是动物这个类必须的,<br>在动物的派生类中, 有些类需要, 有些不需要.  </p>
<p>如果把捕猎方法写在动物超类里面是不合理的浪费资源.</p>
<p>所以把捕猎这个方法封装成1个接口, 让派生类自己去选择实现!</p>
<h4 id="7-3-要为不同类族的多个类实现同样的方法-功能"><a href="#7-3-要为不同类族的多个类实现同样的方法-功能" class="headerlink" title="7.3  . 要为不同类族的多个类实现同样的方法(功能)."></a>7.3  . 要为不同类族的多个类实现同样的方法(功能).</h4><p>上面说过了, 其实不是只有Animal类的派生类才可以实现Huntable接口.<br>如果Farmer实现了这个接口, 那么农夫自己就可以去捕猎动物了…</p>
<p>我们拿另个常用的接口Comparable来做例子.</p>
<p>这个接口是应用了泛型,</p>
<p>首先, 比较(CompareTo) 这种行为很难界定适用的类族, 实际上, 几乎所有的类都可以比较.</p>
<p>比如 数字类可以比较大小,   人类可以比较财富,  动物可以比较体重等.</p>
<p>所以各种类都可以实现这个比较接口.</p>
<p>一旦实现了这个比较接口. 就可以开启另1个隐藏技能:</p>
<p>就是可以利用Arrays.sort()来进行排序了.</p>
<p>就如实现了捕猎的动物,<br>可以被农夫Farmer喂兔子一样…</p>
<h4 id="8、接口为什么会被叫做接口-跟真正的接口例如usb接口有联系吗"><a href="#8、接口为什么会被叫做接口-跟真正的接口例如usb接口有联系吗" class="headerlink" title="8、接口为什么会被叫做接口, 跟真正的接口例如usb接口有联系吗?"></a>8、接口为什么会被叫做接口, 跟真正的接口例如usb接口有联系吗?</h4><p>对啊, 为什么叫接口, 而不叫插件(plugin)呢,  貌似java接口的功能更类似1个插件啊.</p>
<p>插上某个插件, 就有某个功能啊.</p>
<p>实际上, 插件与接口是相辅相成的.</p>
<p>例如有1个外部存储插件(U盘), 也需要使用设备具有usb接口才能使用啊.</p>
<p>再举个具体的例子.</p>
<p>个人电脑是由大型机发展而来的</p>
<p>大型机-&gt;小型机-&gt;微机(PC)</p>
<p>而笔记本是继承自微机的.</p>
<p>那么问题来了.</p>
<p>对于, 计算机的CPU/内存/主板/独显/光驱/打印机 有很多功能(方法/行为), 那么到底哪些东西是继承, 哪些东西是接口呢.</p>
<p>首先,  cpu/内存/主板 是从大型机开始都必备的, 任何计算机都不能把它们去掉.<br>所以, 这三样东西是继承的, 也就说笔记本的cpu/内存/主板是继承自微机(PC)的</p>
<p>但是/光驱/呢,    现实上很多超薄笔记本不需要光驱的功能.</p>
<p>如果光驱做成继承, 那么笔记本就必须具有光驱, 然后屏蔽光驱功能, 那么这台笔记本还能做到超薄吗? 浪费了资源.</p>
<p>所以光驱,打印机这些东西就应该做成插件.</p>
<p>然后, 在笔记本上做1个可以插光驱和打印机的接口(usb接口).</p>
<p>也就是说, PC的派生类, 有些(笔记本)可以不实现这个接口, 有些(台式机)可以实现这个接口,只需要把光驱插到这个接口上.</p>
<p>至于光驱是如何实现的,</p>
<p>例如一些pc派生类选择实现蓝光光驱, 有些选择刻录机.  但是usb接口本身并不关心. 取决与实现接口的类.</p>
<p>这个就是现实意义上的多态性啊.<br>————————————————<br>版权声明：本文为CSDN博主「nvd11」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/nvd11/article/details/41129935">https://blog.csdn.net/nvd11/article/details/41129935</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://wenwenhuan.gitee.io/2020/12/28/Springboot/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="温文焕">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wenhuan Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/12/28/Springboot/" class="post-title-link" itemprop="url">Springboot</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-12-28 10:00:00" itemprop="dateCreated datePublished" datetime="2020-12-28T10:00:00+08:00">2020-12-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2021-02-28 16:47:12" itemprop="dateModified" datetime="2021-02-28T16:47:12+08:00">2021-02-28</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Springboot"><a href="#Springboot" class="headerlink" title="Springboot"></a><strong>Springboot</strong></h1><h2 id="一、静态资源访问"><a href="#一、静态资源访问" class="headerlink" title="一、静态资源访问"></a>一、静态资源访问</h2><h3 id="1、静态资源目录"><a href="#1、静态资源目录" class="headerlink" title="1、静态资源目录"></a>1、静态资源目录</h3><p>只要静态资源放在类路径下： called <code>/static</code> (or <code>/public</code> or <code>/resources</code> or <code>/META-INF/resources</code></p>
<p>访问 ： 当前项目根路径/ + 静态资源名 （直接访问）</p>
<p>原理： 静态映射/**。</p>
<p>请求进来，先去找Controller看能不能处理。不能处理的所有请求又都交给静态资源处理器。静态资源也找不到则响应404页面</p>
<p>改变默认的静态资源路径</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">mvc:</span></span><br><span class="line">    <span class="attr">static-path-pattern:</span> <span class="string">/res/**</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">resources:</span></span><br><span class="line">    <span class="attr">static-locations:</span> [<span class="string">classpath:/haha/</span>]</span><br></pre></td></tr></table></figure>

<h3 id="2、静态资源访问前缀"><a href="#2、静态资源访问前缀" class="headerlink" title="2、静态资源访问前缀"></a>2、静态资源访问前缀</h3><p>默认无前缀</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">mvc:</span></span><br><span class="line">    <span class="attr">static-path-pattern:</span> <span class="string">/res/**</span></span><br></pre></td></tr></table></figure>

<p>当前项目 + static-path-pattern + 静态资源名 = 静态资源文件夹下找</p>
<h3 id="3、欢迎页支持"><a href="#3、欢迎页支持" class="headerlink" title="3、欢迎页支持"></a>3、欢迎页支持</h3><ul>
<li><p>静态资源路径下  index.html</p>
</li>
<li><ul>
<li>可以配置静态资源路径</li>
<li>但是不可以配置静态资源的访问前缀。否则导致 index.html不能被默认访问</li>
</ul>
</li>
<li><p>```yml<br>spring:</p>
<h1 id="mvc"><a href="#mvc" class="headerlink" title="mvc:"></a>mvc:</h1><h1 id="static-path-pattern-res-这个会导致welcome-page功能失效"><a href="#static-path-pattern-res-这个会导致welcome-page功能失效" class="headerlink" title="static-path-pattern: /res/**   这个会导致welcome page功能失效"></a>static-path-pattern: /res/**   这个会导致welcome page功能失效</h1><p>  resources:</p>
<pre><code>static-locations: [classpath:/haha/]
</code></pre>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 4、自定义 &#96;Favicon&#96;</span><br><span class="line"></span><br><span class="line">favicon.ico 放在静态资源目录下即可。</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;yml</span><br><span class="line">spring:</span><br><span class="line">#  mvc:</span><br><span class="line">#    static-path-pattern: &#x2F;res&#x2F;**   这个会导致 Favicon 功能失效</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="二、请求参数处理"><a href="#二、请求参数处理" class="headerlink" title="二、请求参数处理"></a>二、请求参数处理</h2><h3 id="1、rest使用与原理"><a href="#1、rest使用与原理" class="headerlink" title="1、rest使用与原理"></a>1、rest使用与原理</h3><ul>
<li><p>@xxxMapping；</p>
</li>
<li><p>Rest风格支持（<em>使用<strong>HTTP</strong>请求方式动词来表示对资源的操作</em>）</p>
</li>
<li><ul>
<li><em>以前：*</em>/getUser*  <em>获取用户</em>   <em>/deleteUser</em> <em>删除用户</em>   <em>/editUser</em>  <em>修改用户</em>    <em>/saveUser</em> <em>保存用户</em></li>
<li><em>现在： /user</em>   *GET-*<em>获取用户</em>   *DELETE-*<em>删除用户</em>   *PUT-*<em>修改用户</em>    *POST-*<em>保存用户</em></li>
<li>核心Filter；HiddenHttpMethodFilter</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>用法： 表单method=post，隐藏域 _method=put</li>
<li>SpringBoot中手动开启</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">	<span class="comment">//@RequestMapping(value = &quot;/user&quot;,method = RequestMethod.GET)</span></span><br><span class="line">	<span class="meta">@GetMapping(&quot;/user&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUser</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;GET-张三&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//@RequestMapping(value = &quot;/user&quot;,method = RequestMethod.POST)</span></span><br><span class="line">	<span class="meta">@PostMapping(&quot;/user&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">saveUser</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;POST-张三&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//@RequestMapping(value = &quot;/user&quot;,method = RequestMethod.PUT)</span></span><br><span class="line">	<span class="meta">@PutMapping(&quot;/user&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">putUser</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;PUT-张三&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//@RequestMapping(value = &quot;/user&quot;,method = RequestMethod.DELETE)</span></span><br><span class="line">	<span class="meta">@DeleteMapping(&quot;/user&quot;)</span>	</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">deleteUser</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;DELETE-张三&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean(HiddenHttpMethodFilter.class)</span></span><br><span class="line">    <span class="meta">@ConditionalOnProperty(prefix = &quot;spring.mvc.hiddenmethod.filter&quot;, name = &quot;enabled&quot;, matchIfMissing = false)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> OrderedHiddenHttpMethodFilter <span class="title">hiddenHttpMethodFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> OrderedHiddenHttpMethodFilter();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义filter</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HiddenHttpMethodFilter <span class="title">hiddenHttpMethodFilter</span><span class="params">()</span></span>&#123;</span><br><span class="line">        HiddenHttpMethodFilter methodFilter = <span class="keyword">new</span> HiddenHttpMethodFilter();</span><br><span class="line">        methodFilter.setMethodParam(<span class="string">&quot;_m&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> methodFilter;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://wenwenhuan.gitee.io/2020/12/27/%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="温文焕">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wenhuan Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/12/27/%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4/" class="post-title-link" itemprop="url">机器人的运动范围</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-12-27 10:00:00" itemprop="dateCreated datePublished" datetime="2020-12-27T10:00:00+08:00">2020-12-27</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2021-02-28 16:55:26" itemprop="dateModified" datetime="2021-02-28T16:55:26+08:00">2021-02-28</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="机器人的运动范围"><a href="#机器人的运动范围" class="headerlink" title="机器人的运动范围"></a>机器人的运动范围</h1><p>地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？</p>
<h2 id="审题："><a href="#审题：" class="headerlink" title="审题："></a>审题：</h2><p>可以看出应该用dfs解题，但犯了两个错误：</p>
<ol>
<li>忘记标记已经遍历过的格子，导致无限循环。</li>
<li>把行r和列c调换了位置，导致数组下标溢出异常。</li>
</ol>
<h2 id="查看答案后"><a href="#查看答案后" class="headerlink" title="查看答案后:"></a>查看答案后:</h2><p>答案的中心思想和我一样，但我依旧做了很多无用功！</p>
<ol>
<li><strong>这是一个有规律的方阵</strong>，关键的条件“行坐标和列坐标的数位之和”是一个依次递增的，其实不用向四个方向查询，只需要向下，和向右查询就可以。</li>
</ol>
<p><img src="C:%5CUsers%5CPowerwenwh%5CDocuments%5C_posts%5C%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4.assets%5Cimage-20201225155726090.png" alt="image-20201225155726090"></p>
<p>这个特性也让我想起了之前做的另外一题———二维数组的查找，两者有同工异曲之妙。 </p>
<ol start="2">
<li>找规律的能力还要提升。</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://wenwenhuan.gitee.io/2020/12/24/%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="温文焕">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wenhuan Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/12/24/%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84/" class="post-title-link" itemprop="url">矩阵中的路径</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-12-24 10:00:00" itemprop="dateCreated datePublished" datetime="2020-12-24T10:00:00+08:00">2020-12-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2021-02-28 20:00:34" itemprop="dateModified" datetime="2021-02-28T20:00:34+08:00">2021-02-28</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="矩阵中的路径"><a href="#矩阵中的路径" class="headerlink" title="矩阵中的路径"></a><strong>矩阵中的路径</strong></h1><p>请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。<br>路径可以从矩阵中的任意一格开始，每一步可以在矩阵中向左、右、上、下移动一格。<br>如果一条路径经过了矩阵的某一格，那么该路径不能再次进入该格子。<br>例如，在下面的3×4的矩阵中包含一条字符串“bfce”的路径（路径中的字母用加粗标出）。</p>
<pre><code>    [[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;e&quot;],
    [&quot;s&quot;,&quot;f&quot;,&quot;c&quot;,&quot;s&quot;],
    [&quot;a&quot;,&quot;d&quot;,&quot;e&quot;,&quot;e&quot;]]
</code></pre>
<p>但矩阵中不包含字符串“abfb”的路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入这个格子。</p>
<p><strong>一开始做题思路偏差，想到的是递归，但没想到DFS，这道题和岛屿问题其实很像</strong></p>
<p>调整思路：</p>
<ol>
<li><p>双for循环遍历每一格，当匹配到与某字符串第一个字符相同的字符时开始DFS</p>
</li>
<li><p>void DFS（char[][] board, String word，r，c，）：</p>
<ul>
<li><p>判断该格是否在矩阵内，是否遍历过（定义一个二维数组记录）</p>
</li>
<li><p>if（charAt！=current）{return ；}</p>
</li>
<li><p>else if（最后一个字符）{set true；return； }</p>
</li>
<li><p>else{四个方向遍历}</p>
</li>
</ul>
</li>
</ol>
<p>查看答案后总结：</p>
<ol>
<li><p>关于判断一个结点是否被访问过，我使用一个二维数组来做记录，需要自己控制它的回溯，不断传参，非常麻烦，答案用了一个非常巧妙的方法，遍历过后把那里的值设置为”\0”,先污染，代表访问过，在最后用<code>board[i][j] = word[k]</code>进行”治理”，以便下一次遍历可以正常使用。</p>
</li>
<li><p>每匹配到一个符合的char，需要记录是第几个char，我使用每次单独执行<code>word_current++</code>的方法，还放错了位置，其实只要每次传递的时候传递<code>word_current</code>的时候直接传<code>word_current++</code>，这样的写法减少了代码量，下次在递归里面写到判断相关的语句的时候都要仔细思考，什么时候判断，能不能用这种简洁方法判断！！</p>
</li>
<li><p>关于找到所有字符后，如何返回这个信息，我的方法是定义一个全局变量，找到之后修改这个全局变量，在DFS完了之后对这个变量进行判断，答案用的方法是“先污染”，我思考过，但想到“治理”的问题觉得麻烦—-我设定的DFS是没有返回值的，所以没用，当时的想法是，有返回值的话不知道如何处理，但显然这个方法更便捷。 也学到了处理返回值的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> res = DFS(board, word, r-<span class="number">1</span>, c, w++)|| DFS(board, word, r+<span class="number">1</span>, c, w++)||</span><br><span class="line">                    DFS(board, word, r, c-<span class="number">1</span>, w++)|| DFS(board, word, r, c+<span class="number">1</span>, w++);</span><br><span class="line">board[r][c] = word.charAt(w++);</span><br><span class="line"><span class="keyword">return</span> res;</span><br></pre></td></tr></table></figure></li>
<li><p><code>w++</code>和<code>w+1</code>的区别：要注意，值传递的时候，一定要使用后者，使用前者就改变了w的值！</p>
</li>
<li><p>不断的修改使得代码乱得一塌糊涂，调试过程没有善用“运行到鼠标处”，运行的时候总想着一步一步执行，浪费了大量时间，应该直接运行到最后一部查看参数找出问题。</p>
</li>
</ol>
<p>回顾：</p>
<p>其实解题的大致思路我是懂的，但是细节上仍然处理得不好。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://wenwenhuan.gitee.io/2020/12/23/Leetcode%E5%88%B7%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="温文焕">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wenhuan Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/12/23/Leetcode%E5%88%B7%E9%A2%98/" class="post-title-link" itemprop="url">刷题学习记录</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-12-23 10:00:00" itemprop="dateCreated datePublished" datetime="2020-12-23T10:00:00+08:00">2020-12-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2021-05-08 07:07:30" itemprop="dateModified" datetime="2021-05-08T07:07:30+08:00">2021-05-08</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="刷题学习记录"><a href="#刷题学习记录" class="headerlink" title="刷题学习记录"></a>刷题学习记录</h1><h4 id="青蛙跳台阶"><a href="#青蛙跳台阶" class="headerlink" title="青蛙跳台阶"></a>青蛙跳台阶</h4><p>有些题目正着想难，但从结果出发容易，看似复杂的题目，可以通过分解情况找规律。</p>
<h4 id="旋转数组的最小数字"><a href="#旋转数组的最小数字" class="headerlink" title="旋转数组的最小数字"></a>旋转数组的最小数字</h4><p>遇到排好序的</p>
<h1 id="20-12-20"><a href="#20-12-20" class="headerlink" title="20-12-20"></a>20-12-20</h1><h3 id="01-在for循环中使用变量控制循环次数"><a href="#01-在for循环中使用变量控制循环次数" class="headerlink" title="01.在for循环中使用变量控制循环次数"></a>01.在for循环中使用变量控制循环次数</h3><p>在做题“使用两个堆栈实现队列的时候用<code>stack1.size()</code>来控制for循环的次数，但每循环一次，<code>stack1.size()</code>的值都会减一，导致错误。</p>
<h1 id="2021-03-04"><a href="#2021-03-04" class="headerlink" title="2021-03-04"></a>2021-03-04</h1><h3 id="01-删除链表的节点"><a href="#01-删除链表的节点" class="headerlink" title="01.删除链表的节点"></a>01.删除链表的节点</h3><p>审题的时候没有看清题目，浪费了时间。</p>
<h3 id="02-不熟悉Java中引用的性质"><a href="#02-不熟悉Java中引用的性质" class="headerlink" title="02.不熟悉Java中引用的性质"></a>02.不熟悉Java中引用的性质</h3><p>指针a指向c，令指针b等于a，则改变b，并不会改变指针a，也即全都是引用。</p>
<h3 id="03-忘记控制空指针"><a href="#03-忘记控制空指针" class="headerlink" title="03.忘记控制空指针"></a>03.忘记控制空指针</h3><p>在访问数组时没注意数组访问越界问题，在使用指针的时候没注意使用前判断指针是否为空。</p>
<h3 id="04-a的b次方"><a href="#04-a的b次方" class="headerlink" title="04.a的b次方"></a>04.a的b次方</h3><p><code>Math.pow(a,b)</code>返回类型时double</p>
<h1 id="0201-03-05"><a href="#0201-03-05" class="headerlink" title="0201-03-05"></a>0201-03-05</h1><h2 id="正则表达式匹配"><a href="#正则表达式匹配" class="headerlink" title="正则表达式匹配"></a>正则表达式匹配</h2><h3 id="01-选用嵌套for循环"><a href="#01-选用嵌套for循环" class="headerlink" title="01.选用嵌套for循环"></a>01.选用嵌套for循环</h3><p>匹配的时候不一定是一一对应，有时候正则表达式里的一个字符可以匹配字符串里的多个字符，存在一对多的关系，应该使用一对多的方式</p>
<h1 id="2021-03-11"><a href="#2021-03-11" class="headerlink" title="2021-03-11"></a>2021-03-11</h1><h2 id="双指针反转链表、找链表中倒数第k个节点"><a href="#双指针反转链表、找链表中倒数第k个节点" class="headerlink" title="双指针反转链表、找链表中倒数第k个节点"></a>双指针反转链表、找链表中倒数第k个节点</h2><h3 id="01-continue关键字"><a href="#01-continue关键字" class="headerlink" title="01.continue关键字"></a>01.continue关键字</h3><p>用于中止当前循环，直接进入下一次循环，常与if连用。</p>
<h3 id="02-3-Ways-To-Fix-“Illegal-Start-Of-Expression”-Error-In-Java"><a href="#02-3-Ways-To-Fix-“Illegal-Start-Of-Expression”-Error-In-Java" class="headerlink" title="02.3 Ways To Fix “Illegal Start Of Expression” Error In Java"></a>02.3 Ways To Fix “Illegal Start Of Expression” Error In Java</h3><ol>
<li>Missing curly braces</li>
<li>Method inside Method</li>
<li>Public, private or protected access modifier inside method</li>
</ol>
<h3 id="03-Error-Found-cycle-in-the-ListNode"><a href="#03-Error-Found-cycle-in-the-ListNode" class="headerlink" title="03.Error - Found cycle in the ListNode"></a>03.Error - Found cycle in the ListNode</h3><p>链表中发现循环</p>
<h3 id="04-ArrayList的初始容量"><a href="#04-ArrayList的初始容量" class="headerlink" title="04.ArrayList的初始容量"></a>04.ArrayList的初始容量</h3><p>ArrayList的初始容量现在为0，等到第一次add的时候再初始化为10。想查看容量capacity需要用到反射，size（）方法是查询元素数量。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://wenwenhuan.gitee.io/2020/12/23/%E3%80%8C%E5%B2%9B%E5%B1%BF%E9%97%AE%E9%A2%98%E3%80%8D/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="温文焕">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wenhuan Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/12/23/%E3%80%8C%E5%B2%9B%E5%B1%BF%E9%97%AE%E9%A2%98%E3%80%8D/" class="post-title-link" itemprop="url">岛屿问题</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-12-23 10:00:00" itemprop="dateCreated datePublished" datetime="2020-12-23T10:00:00+08:00">2020-12-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2021-02-28 16:56:44" itemprop="dateModified" datetime="2021-02-28T16:56:44+08:00">2021-02-28</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="岛屿类问题的通用解法、DFS-遍历框架"><a href="#岛屿类问题的通用解法、DFS-遍历框架" class="headerlink" title="岛屿类问题的通用解法、DFS 遍历框架"></a>岛屿类问题的通用解法、DFS 遍历框架</h2><p>我们所熟悉的 DFS（深度优先搜索）问题通常是在树或者图结构上进行的。而我们今天要讨论的 DFS 问题，是在一种「网格」结构中进行的。岛屿问题是这类网格 DFS 问题的典型代表。网格结构遍历起来要比二叉树复杂一些，如果没有掌握一定的方法，DFS 代码容易写得冗长繁杂。</p>
<p>本文将以岛屿问题为例，展示网格类问题 DFS 通用思路，以及如何让代码变得简洁。</p>
<p><strong>网格问题的基本概念</strong><br>我们首先明确一下岛屿问题中的网格结构是如何定义的，以方便我们后面的讨论。</p>
<p>网格问题是由m×n 个小方格组成一个网格，每个小方格与其上下左右四个方格认为是相邻的，要在这样的网格上进行某种搜索。</p>
<p>岛屿问题是一类典型的网格问题。每个格子中的数字可能是 0 或者 1。我们把数字为 0 的格子看成海洋格子，数字为 1 的格子看成陆地格子，这样相邻的陆地格子就连接成一个岛屿。</p>
<h3 id="DFS-的基本结构"><a href="#DFS-的基本结构" class="headerlink" title="DFS 的基本结构"></a>DFS 的基本结构</h3><p>网格结构要比二叉树结构稍微复杂一些，它其实是一种简化版的图结构。要写好网格上的 DFS 遍历，我们首先要理解二叉树上的 DFS 遍历方法，再类比写出网格结构上的 DFS 遍历。我们写的二叉树 DFS 遍历一般是这样的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 判断 base case</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 访问两个相邻结点：左子结点、右子结点</span></span><br><span class="line">    traverse(root.left);</span><br><span class="line">    traverse(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，二叉树的 DFS 有两个要素：「==访问相邻结点」和「判断 base case」==。</p>
<p>第一个要素是访问相邻结点。二叉树的相邻结点非常简单，只有左子结点和右子结点两个。二叉树本身就是一个递归定义的结构：一棵二叉树，它的左子树和右子树也是一棵二叉树。那么我们的 DFS 遍历只需要递归调用左子树和右子树即可。</p>
<p>第二个要素是 判断 base case。一般来说，二叉树遍历的 base case 是 root == null。这样一个条件判断其实有两个含义：一方面，这表示 root 指向的子树为空，不需要再往下遍历了。另一方面，在 root == null 的时候==及时返回==，可以让后面的 root.left 和 root.right 操作不会出现空指针异常。</p>
<p>对于网格上的 DFS，我们完全可以参考二叉树的 DFS，写出网格 DFS 的两个要素：</p>
<p>首先，网格结构中的格子有多少相邻结点？答案是上下左右四个。对于格子 (r, c) 来说（r 和 c 分别代表行坐标和列坐标），四个相邻的格子分别是 (r-1, c)、(r+1, c)、(r, c-1)、(r, c+1)。换句话说，==网格结构是「四叉」的。==</p>
<p>其次，网格 DFS 中的 base case 是什么？从二叉树的 base case 对应过来，应该是网格中不需要继续遍历、grid[r][c] 会出现数组下标越界异常的格子，也就是那些超出网格范围的格子。</p>
<p>这一点稍微有些反直觉，坐标竟然可以临时超出网格的范围？这种方法我称为==「先污染后治理」==—— 甭管当前是在哪个格子，先往四个方向走一步再说，如果发现走出了网格范围再赶紧返回。这跟二叉树的遍历方法是一样的，先递归调用，发现 root == null 再返回。</p>
<p>这样，我们得到了网格 DFS 遍历的框架代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] grid, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 判断 base case</span></span><br><span class="line">    <span class="comment">// 如果坐标 (r, c) 超出了网格范围，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (!inArea(grid, r, c)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 访问上、下、左、右四个相邻结点</span></span><br><span class="line">    dfs(grid, r - <span class="number">1</span>, c);</span><br><span class="line">    dfs(grid, r + <span class="number">1</span>, c);</span><br><span class="line">    dfs(grid, r, c - <span class="number">1</span>);</span><br><span class="line">    dfs(grid, r, c + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断坐标 (r, c) 是否在网格中</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">inArea</span><span class="params">(<span class="keyword">int</span>[][] grid, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> &lt;= r &amp;&amp; r &lt; grid.length </span><br><span class="line">        	&amp;&amp; <span class="number">0</span> &lt;= c &amp;&amp; c &lt; grid[<span class="number">0</span>].length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="如何避免重复遍历"><a href="#如何避免重复遍历" class="headerlink" title="如何避免重复遍历"></a>如何避免重复遍历</h3><p>网格结构的 DFS 与二叉树的 DFS 最大的不同之处在于，遍历中可能遇到遍历过的结点。这是因为，网格结构本质上是一个「图」，我们可以把每个格子看成图中的结点，每个结点有向上下左右的四条边。在图中遍历时，自然可能遇到重复遍历结点。</p>
<p>这时候，DFS 可能会不停地「兜圈子」，永远停不下来。</p>
<p>如何避免这样的重复遍历呢？答案是标记已经遍历过的格子。以岛屿问题为例，我们需要在所有值为 1 的陆地格子上做 DFS 遍历。每走过一个陆地格子，就把格子的值改为 2，这样当我们遇到 2 的时候，就知道这是遍历过的格子了。也就是说，每个格子可能取三个值：</p>
<p>0 —— 海洋格子<br>1 —— 陆地格子（未遍历过）<br>2 —— 陆地格子（已遍历过）<br>我们在框架代码中加入避免重复遍历的语句：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] grid, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 判断 base case</span></span><br><span class="line">    <span class="keyword">if</span> (!inArea(grid, r, c)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果这个格子不是岛屿，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (grid[r][c] != <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    grid[r][c] = <span class="number">2</span>; <span class="comment">// 将格子标记为「已遍历过」</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 访问上、下、左、右四个相邻结点</span></span><br><span class="line">    dfs(grid, r - <span class="number">1</span>, c);</span><br><span class="line">    dfs(grid, r + <span class="number">1</span>, c);</span><br><span class="line">    dfs(grid, r, c - <span class="number">1</span>);</span><br><span class="line">    dfs(grid, r, c + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断坐标 (r, c) 是否在网格中</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">inArea</span><span class="params">(<span class="keyword">int</span>[][] grid, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> &lt;= r &amp;&amp; r &lt; grid.length </span><br><span class="line">        	&amp;&amp; <span class="number">0</span> &lt;= c &amp;&amp; c &lt; grid[<span class="number">0</span>].length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，我们就得到了一个岛屿问题、乃至各种网格问题的通用 DFS 遍历方法。以下所讲的几个例题，其实都只需要在 DFS 遍历框架上稍加修改而已。</p>
<blockquote>
<p>小贴士：</p>
</blockquote>
<blockquote>
<p>在一些题解中，可能会把「已遍历过的陆地格子」标记为和海洋格子一样的 0，美其名曰「陆地沉没方法」，即遍历完一个陆地格子就让陆地「沉没」为海洋。这种方法看似很巧妙，但实际上有很大隐患，因为这样我们就无法区分「海洋格子」和「已遍历过的陆地格子」了。如果题目更复杂一点，这很容易出 bug。</p>
</blockquote>
<h3 id="岛屿问题的解法"><a href="#岛屿问题的解法" class="headerlink" title="岛屿问题的解法"></a>岛屿问题的解法</h3><h4 id="例题-1：岛屿的最大面积"><a href="#例题-1：岛屿的最大面积" class="headerlink" title="例题 1：岛屿的最大面积"></a>例题 1：岛屿的最大面积</h4><h4 id="例题-2：填海造陆问题"><a href="#例题-2：填海造陆问题" class="headerlink" title="例题 2：填海造陆问题"></a>例题 2：填海造陆问题</h4><h4 id="例题-3：岛屿的周长"><a href="#例题-3：岛屿的周长" class="headerlink" title="例题 3：岛屿的周长"></a>例题 3：岛屿的周长</h4><h4 id="例题-4：岛屿的数量"><a href="#例题-4：岛屿的数量" class="headerlink" title="例题 4：岛屿的数量"></a>例题 4：岛屿的数量</h4><p>给你一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，请你计算网格中岛屿的数量。</p>
<p>岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。</p>
<p>此外，你可以假设该网格的四条边均被水包围。</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[][] grid, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> nr = grid.length;</span><br><span class="line">        <span class="keyword">int</span> nc = grid[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (r &lt; <span class="number">0</span> || c &lt; <span class="number">0</span> || r &gt;= nr || c &gt;= nc || grid[r][c] == <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        grid[r][c] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        dfs(grid, r - <span class="number">1</span>, c);</span><br><span class="line">        dfs(grid, r + <span class="number">1</span>, c);</span><br><span class="line">        dfs(grid, r, c - <span class="number">1</span>);</span><br><span class="line">        dfs(grid, r, c + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="keyword">char</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (grid == <span class="keyword">null</span> || grid.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> nr = grid.length;</span><br><span class="line">        <span class="keyword">int</span> nc = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> num_islands = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; nr; ++r) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; nc; ++c) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[r][c] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                    ++num_islands;</span><br><span class="line">                    dfs(grid, c, r);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> num_islands;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<ul>
<li><p>时间复杂度：O(MN)，其中 MM 和 NN 分别为行数和列数。</p>
</li>
<li><p>空间复杂度：O(MN)，在最坏情况下，整个网格均为陆地，深度优先搜索的深度达到 MN。</p>
</li>
</ul>
<blockquote>
<p>作者：LeetCode<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/number-of-islands/solution/dao-yu-shu-liang-by-leetcode/">https://leetcode-cn.com/problems/number-of-islands/solution/dao-yu-shu-liang-by-leetcode/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/5/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">温文焕</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  





  





</body>
</html>
