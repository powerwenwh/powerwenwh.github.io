<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"wenwenhuan.gitee.io","root":"/","images":"/images","scheme":"Gemini","darkmode":true,"version":"8.8.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>
<meta property="og:type" content="website">
<meta property="og:title" content="Wenhuan Blog">
<meta property="og:url" content="https://wenwenhuan.gitee.io/page/6/index.html">
<meta property="og:site_name" content="Wenhuan Blog">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="温文焕">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://wenwenhuan.gitee.io/page/6/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/6/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Wenhuan Blog</title>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Wenhuan Blog</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">即使天无雨 我亦留此地</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">温文焕</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">65</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://wenwenhuan.gitee.io/2020/11/01/spring5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="温文焕">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wenhuan Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/11/01/spring5/" class="post-title-link" itemprop="url">spring5</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-11-01 02:29:32" itemprop="dateCreated datePublished" datetime="2020-11-01T02:29:32+08:00">2020-11-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2021-05-12 12:09:56" itemprop="dateModified" datetime="2021-05-12T12:09:56+08:00">2021-05-12</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="一、Spring-框架概述"><a href="#一、Spring-框架概述" class="headerlink" title="一、Spring 框架概述"></a>一、Spring 框架概述</h2><p>1、Spring 是轻量级的开源的 JavaEE 框架 </p>
<p>2、Spring 可以解决企业应用开发的复杂性</p>
<p>3、Spring 有两个核心部分：IOC 和 Aop </p>
<p>==（1）IOC：控制反转，把创建对象过程交给 Spring 进行管理== </p>
<p>==（2）Aop：面向切面，不修改源代码进行功能增强==</p>
<p>4、Spring 特点 </p>
<p>（1）方便解耦，简化开发</p>
<p> （2）Aop 编程支持 </p>
<p>（3）方便程序测试 </p>
<p>（4）方便和其他框架进行整合 </p>
<p>（5）方便进行事务操作 </p>
<p>（6）降低 API 开发难度</p>
<h2 id="二、入门案例"><a href="#二、入门案例" class="headerlink" title="二、入门案例"></a>二、入门案例</h2><p>1、下载spring后创建Java工程并导入相关jar包</p>
<p><img src="C:%5CUsers%5CPowerwenwh%5CDocuments%5C_posts%5Cimgs%5Cspring5%5Cimage-20210119110144781.png" alt="image-20210119110144781"></p>
<p>2、创建普通类，在这个类创建普通方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        System.out.println(<span class="string">&quot;add......&quot;</span>);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、创建Spring配置文件，在配置文件配置创建的对象</p>
<p>Spring配置文件使用xml格式</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span> </span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">                           http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置User对象创建--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atguigu.spring5.User&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p>4、进行测试代码编写</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testAdd</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="comment">//1 加载spring配置文件 </span></span><br><span class="line">    ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;bean1.xml&quot;</span>); </span><br><span class="line">    <span class="comment">//2 获取配置创建的对象 </span></span><br><span class="line">    User user = context.getBean(<span class="string">&quot;user&quot;</span>, User.class); </span><br><span class="line">    System.out.println(user);<span class="comment">//输出全类名和地址 </span></span><br><span class="line">    user.add(); <span class="comment">//add......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="三、IOC"><a href="#三、IOC" class="headerlink" title="三、IOC"></a>三、IOC</h2><h3 id="概念和原理"><a href="#概念和原理" class="headerlink" title="概念和原理"></a>概念和原理</h3><p>1、什么是IOC<br>（1）控制反转，把对象创建和对象之间的调用过程，交给Spring进行管理<br>（2）使用IOC目的：==为了耦合度降低==<br>（3）做入门案例就是IOC实现</p>
<p>2、IOC底层原理<br>（1）xml解析、工厂模式、反射</p>
<p>3、画图讲解IOC底层原理<br><img src="C:%5CUsers%5CPowerwenwh%5CDocuments%5C_posts%5Cimgs%5Cspring5%5Cimage-20210119105608434.png" alt="image-20210119105608434"></p>
<h3 id="BeanFactory接口"><a href="#BeanFactory接口" class="headerlink" title="BeanFactory接口"></a>BeanFactory接口</h3><p>1、IOC思想基于IOC容器完成，IOC容器底层就是对象工厂<br>2、Spring提供IOC容器实现两种方式：（两个接口）<br>（1）BeanFactory：IOC容器基本实现，是Spring内部的使用接口，不提供开发人员进行使用</p>
<ul>
<li>加载配置文件时候不会创建对象，在获取对象（使用）才去创建对象</li>
</ul>
<p>（2）ApplicationContext：BeanFactory接口的子接口，提供更多更强大的功能，一般由开发人员进行使用</p>
<ul>
<li>加载配置文件时候就会把在配置文件对象进行创建</li>
</ul>
<p>3、ApplicationContext接口有实现类<br><img src="C:%5CUsers%5CPowerwenwh%5CDocuments%5C_posts%5Cimgs%5Cspring5%5Cimage-20210119112255505.png" alt="image-20210119112255505"></p>
<h3 id="IOC操作-Bean管理（概念）"><a href="#IOC操作-Bean管理（概念）" class="headerlink" title="IOC操作 Bean管理（概念）"></a>IOC操作 Bean管理（概念）</h3><p>1、什么是Bean管理<br>（0）Bean管理指的是两个操作</p>
<ul>
<li>Spring创建对象</li>
<li>Spirng注入属性</li>
</ul>
<p>2、Bean管理操作有两种方式<br>（1）基于xml配置文件方式实现<br>（2）基于注解方式实现</p>
<h3 id="IOC操作-Bean管理-基于注解方式"><a href="#IOC操作-Bean管理-基于注解方式" class="headerlink" title="IOC操作 Bean管理 (基于注解方式)"></a>IOC操作 Bean管理 (基于注解方式)</h3><p>1、 什么是注解<br>（1）注解是代码特殊标记，格式：@注解名称(属性名称=属性值, 属性名称=属性值..)<br>（2）使用注解，注解作用在类上面，方法上面，属性上面<br>（3）使用注解目的：简化xml配置</p>
<p>2、Spring针对Bean管理中创建对象提供注解<br>（1）@Component<br>（2）@Service<br>（3）@Controller<br>（4）@Repository</p>
<ul>
<li>上面四个注解功能是一样的，都可以用来创建bean实例</li>
</ul>
<p>3、基于注解方式实现对象创建<br>第一步 引入依赖</p>
<p><img src="C:%5CUsers%5CPowerwenwh%5CDocuments%5C_posts%5Cimgs%5Cspring5%5Cimage-20210119174609094.png" alt="image-20210119174609094"></p>
<p>第二步 开启组件扫描 </p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--开启组件扫描 </span></span><br><span class="line"><span class="comment">1 如果扫描多个包，多个包使用逗号隔开 </span></span><br><span class="line"><span class="comment">2 扫描包上层目录 --&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.atguigu&quot;</span>&gt;</span>/context:component-scan</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>第三步 创建类,在类上面添加创建对象注解</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在注解里面value属性值可以省略不写， </span></span><br><span class="line"><span class="comment">//默认值是类名称，首字母小写</span></span><br><span class="line"><span class="comment">//UserService -- userService</span></span><br><span class="line"><span class="meta">@Component(value = &quot;userService&quot;)</span> <span class="comment">//&lt;bean id=&quot;userService&quot; class=&quot;..&quot;/&gt; </span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        System.out.println(<span class="string">&quot;service add.......&quot;</span>); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4、开启组件扫描细节配置</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">&lt;!--示例1 </span></span><br><span class="line"><span class="comment">use-default-filters=&quot;false&quot; 表示现在不使用默认filter，自己配置filter </span></span><br><span class="line"><span class="comment">context:include-filter ，设置扫描哪些内容 --&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.atguigu&quot;</span> <span class="attr">use-default-filters</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:include-filter</span> <span class="attr">type</span>=<span class="string">&quot;annotation&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;org.springframework.stereotype.Controller&quot;</span>/&gt;</span> <span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--示例2 </span></span><br><span class="line"><span class="comment">下面配置扫描包所有内容 context:exclude-filter： 设置哪些内容不进行扫描 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.atguigu&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:exclude-filter</span> <span class="attr">type</span>=<span class="string">&quot;annotation&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;org.springframework.stereotype.Controller&quot;</span>/&gt;</span> <span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>5、基于注解方式实现属性注入<br>（1）@Autowired：根据属性类型进行自动装配<br>第一步 把service和dao对象创建，在service和dao类添加创建对象注解<br>第二步 在service注入dao对象，在service类添加dao类型属性，在属性上面使用注解</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123; </span><br><span class="line">    <span class="comment">//定义dao类型属性 </span></span><br><span class="line">    <span class="comment">//不需要添加set方法 </span></span><br><span class="line">    <span class="comment">//添加注入属性注解</span></span><br><span class="line">    <span class="meta">@Autowired</span> </span><br><span class="line">    <span class="keyword">private</span> UserDao userDao; </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        System.out.println(<span class="string">&quot;service add.......&quot;</span>); </span><br><span class="line">        userDao.add(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）@Qualifier：根据名称进行注入<br>这个@Qualifier注解的使用，和上面@Autowired一起使用</p>
<p>//定义dao类型属性 //不需要添加set方法//添加注入属性注解</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span> <span class="comment">//根据类型进行注入 </span></span><br><span class="line"><span class="meta">@Qualifier(value = &quot;userDaoImpl1&quot;)</span> <span class="comment">//根据名称进行注入 </span></span><br><span class="line"><span class="keyword">private</span> UserDao userDao;</span><br></pre></td></tr></table></figure>

<p>（3）@Resource：可以根据类型注入</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//@Resource //根据类型进行注入 </span></span><br><span class="line"><span class="meta">@Resource(name = &quot;userDaoImpl1&quot;)</span> <span class="comment">//根据名称进行注入</span></span><br><span class="line"><span class="keyword">private</span> UserDao userDao;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>（4）@Value：注入普通类型属性</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@Value(value = &quot;abc&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String name;</span><br></pre></td></tr></table></figure>

<p>6、完全注解开发 </p>
<p>（1）创建配置类，替代xml配置文件 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span> <span class="comment">//作为配置类，替代xml配置文件</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &#123;&quot;com.atguigu&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringConfig</span> </span>&#123; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>



<p>（2）编写测试类 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testService2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//加载配置类 </span></span><br><span class="line">    ApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext(SpringConfig.class); </span><br><span class="line">    UserService userService = context.getBean(<span class="string">&quot;userService&quot;</span>, UserService.class); </span><br><span class="line">    System.out.println(userService); </span><br><span class="line">    userService.add(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="四、AOP"><a href="#四、AOP" class="headerlink" title="四、AOP"></a>四、AOP</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>1、什么是AOP </p>
<p>（1）面向切面编程（方面），利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。<br>（2）通俗描述：不通过修改源代码方式，在主干功能里面添加新功能<br>（3）使用登录例子说明AOP</p>
<p><img src="C:%5CUsers%5CPowerwenwh%5CDocuments%5C_posts%5Cimgs%5Cspring5%5Cimage-20210119180333459.png" alt="image-20210119180333459"></p>
<h3 id="AOP（底层原理）"><a href="#AOP（底层原理）" class="headerlink" title="AOP（底层原理）"></a>AOP（底层原理）</h3><p>1、AOP底层使用动态代理</p>
<p>（1）有两种情况动态代理</p>
<p>第一种 有接口情况，使用JDK动态代理</p>
<ul>
<li><p>创建接口实现类代理对象，增强类的方法</p>
<p><img src="C:%5CUsers%5CPowerwenwh%5CDocuments%5C_posts%5Cimgs%5Cspring5%5Cimage-20210119203435084.png" alt="image-20210119203435084"></p>
</li>
</ul>
<p>第二种 没有接口情况，使用CGLIB动态代理</p>
<ul>
<li>创建子类的代理对象，增强类的方法<br><img src="C:%5CUsers%5CPowerwenwh%5CDocuments%5C_posts%5Cimgs%5Cspring5%5Cimage-20210119203418805.png" alt="image-20210119203418805"></li>
</ul>
<h3 id="JDK-动态代理"><a href="#JDK-动态代理" class="headerlink" title="JDK 动态代理"></a>JDK 动态代理</h3><p>1、使用JDK动态代理，使用Proxy类里面的方法创建代理对象</p>
<p><img src="C:%5CUsers%5CPowerwenwh%5CDocuments%5C_posts%5Cimgs%5Cspring5%5Cimage-20210119204311177.png" alt="image-20210119204311177"></p>
<p>（1）调用newProxyInstance方法</p>
<p><img src="C:%5CUsers%5CPowerwenwh%5CDocuments%5C_posts%5Cimgs%5Cspring5%5Cimage-20210119204324994.png" alt="image-20210119204324994"></p>
<p>方法有三个参数：<br>第一参数，类加载器<br>第二参数，增强方法所在的类，这个类实现的接口，支持多个接口<br>第三参数，实现这个接口InvocationHandler，创建代理对象，写增强的部分</p>
<p>2、编写JDK动态代理代码</p>
<p>（1）创建接口，定义方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDao</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">update</span><span class="params">(String id)</span></span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>（2）创建接口实现类，实现方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title">UserDao</span> </span>&#123; </span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> a+b; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> String <span class="title">update</span><span class="params">(String id)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> id; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（3）使用Proxy类创建接口代理对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JDKProxy</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123; </span><br><span class="line">    <span class="comment">//创建接口实现类代理对象 </span></span><br><span class="line">    Class[] interfaces = &#123;UserDao.class&#125;; </span><br><span class="line">    <span class="comment">// Proxy.newProxyInstance(JDKProxy.class.getClassLoader(), interfaces, new InvocationHandler() &#123; </span></span><br><span class="line">    <span class="comment">// @Override </span></span><br><span class="line">    <span class="comment">// public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; </span></span><br><span class="line">    <span class="comment">// return null; </span></span><br><span class="line">    <span class="comment">// &#125; </span></span><br><span class="line">    <span class="comment">// &#125;);</span></span><br><span class="line">    UserDaoImpl userDao = <span class="keyword">new</span> UserDaoImpl(); </span><br><span class="line">    UserDao dao = (UserDao)Proxy.newProxyInstance(JDKProxy.class.getClassLoader(), interfaces, <span class="keyword">new</span> UserDaoProxy(userDao));</span><br><span class="line">    <span class="keyword">int</span> result = dao.add(<span class="number">1</span>, <span class="number">2</span>); System.out.println(<span class="string">&quot;result:&quot;</span>+result); </span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建代理对象代码 </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserDaoProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123; </span><br><span class="line">    <span class="comment">//1 把创建的是谁的代理对象，把谁传递过来 </span></span><br><span class="line">    <span class="comment">//有参数构造传递 </span></span><br><span class="line">    <span class="keyword">private</span> Object obj; <span class="function"><span class="keyword">public</span> <span class="title">UserDaoProxy</span><span class="params">(Object obj)</span> </span>&#123; <span class="keyword">this</span>.obj = obj; &#125; </span><br><span class="line">    <span class="comment">//增强的逻辑 </span></span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123; </span><br><span class="line">        <span class="comment">//方法之前 </span></span><br><span class="line">        System.out.println(<span class="string">&quot;方法之前执行....&quot;</span>+method.getName()+<span class="string">&quot; :传递的参数...&quot;</span>+ Arrays.toString(args)); </span><br><span class="line">        <span class="comment">//被增强的方法执行 </span></span><br><span class="line">        Object res = method.invoke(obj, args); </span><br><span class="line">        <span class="comment">//方法之后 </span></span><br><span class="line">        System.out.println(<span class="string">&quot;方法之后执行....&quot;</span>+obj); </span><br><span class="line">        <span class="keyword">return</span> res; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h3><p>1、连接点</p>
<ul>
<li>类里面可以增强的方法</li>
</ul>
<p>2、切入点</p>
<ul>
<li>实际被增强的方法</li>
</ul>
<p>3、通知（增强）</p>
<ul>
<li>实际增强的逻辑部分<ul>
<li>前置通知</li>
<li>后置通知</li>
<li>环绕通知</li>
<li>异常通知</li>
<li>最终通知</li>
</ul>
</li>
</ul>
<p>4、切面</p>
<ul>
<li>是一个动作，把通知应用到切入点的过程</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://wenwenhuan.gitee.io/2020/10/20/List%E6%8E%A5%E5%8F%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="温文焕">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wenhuan Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/10/20/List%E6%8E%A5%E5%8F%A3/" class="post-title-link" itemprop="url">List接口</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-10-20 11:00:00" itemprop="dateCreated datePublished" datetime="2020-10-20T11:00:00+08:00">2020-10-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2021-03-07 15:57:18" itemprop="dateModified" datetime="2021-03-07T15:57:18+08:00">2021-03-07</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="List的性质"><a href="#List的性质" class="headerlink" title="List的性质"></a>List的性质</h2><p><strong>有序的 collection（也称为序列）</strong>。此接口的用户可以对列表中每个元素的插入位置进行精确地控制。用户可以根据元素的整数索引（在列表中的位置）访问元素，并搜索列表中的元素。</p>
<p>与 set 不同，列表通常允许重复的元素。更确切地讲，列表通常允许满足 e1.equals(e2) 的元素对 e1 和 e2，并且如果列表本身允许 null 元素的话，通常它们允许多个 null 元素。难免有人希望通过在用户尝试插入重复元素时抛出运行时异常的方法来禁止重复的列表，但我们希望这种用法越少越好。</p>
<p>List 接口提供了 4 种对列表元素进行定位（索引）访问方法。列表（像 Java 数组一样）是基于 0 的。注意，这些操作可能在和某些实现（例如 LinkedList 类）的索引值成比例的时间内执行。因此，如果调用者不知道实现，那么<strong>在列表元素上迭代通常优于用索引遍历列表。</strong></p>
<p>List 接口提供了两种搜索指定对象的方法。从性能的观点来看，应该小心使用这些方法。在很多实现中，它们将执行高开销的线性搜索。</p>
<p>List 接口提供了两种在列表的任意位置高效插入和移除多个元素的方法。</p>
<p>注意：尽管列表允许把自身作为元素包含在内，但建议要特别小心：在这样的列表上，equals 和 hashCode 方法不再是定义良好的。 </p>
<p>某些列表实现对列表可能包含的元素有限制。例如，某些实现禁止 null 元素，而某些实现则对元素的类型有限制。试图添加不合格的元素会抛出未经检查的异常，通常是 NullPointerException 或 ClassCastException。试图查询不合格的元素是否存在可能会抛出异常，也可能简单地返回 false；某些实现会采用前一种行为，而某些则采用后者。概括地说，试图对不合格元素执行操作时，如果完成该操作后不会导致在列表中插入不合格的元素，则该操作可能抛出一个异常，也可能成功，这取决于实现的选择。此接口的规范中将这样的异常标记为“可选”。 </p>
<h2 id="Java-中初始化-List-的五种方法"><a href="#Java-中初始化-List-的五种方法" class="headerlink" title="Java 中初始化 List 的五种方法"></a>Java 中初始化 List 的五种方法</h2><p>在 Java 中初始化 List 的五种方法</p>
<ol>
<li>构造 List 后使用 List.add 初始化</li>
<li>使用<code>&#123;&#123;&#125;&#125;`双括号语法
3. 使用 Arrays.asList
4. 使用 Stream (JDK8)
5. 使用 Lists （JDK9）

### 1.构造 `List` 后使用 `List.add` 初始化

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; stringList = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">stringList.add(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">stringList.add(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">stringList.add(<span class="string">&quot;c&quot;</span>);</span><br></pre></td></tr></table></figure>

### 2.使用 `&#123;&#123;&#125;&#125;</code> 双括号语法</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; stringList = <span class="keyword">new</span> LinkedList&lt;String&gt;()&#123;&#123;</span><br><span class="line">    add(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">    add(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">    add(<span class="string">&quot;c&quot;</span>);</span><br><span class="line">&#125;&#125;;</span><br></pre></td></tr></table></figure>

<p>外层的 <code>&#123;&#125;</code> 定义了一个 LinkedList 的匿名内部类。内层的 <code>&#123;&#125;</code> 的定义了一个实例初始化代码块。 这个代码块在初始化内部类时执行。所以这里相当于定义了一个匿名内部类，并使用 <code>add</code> 添加元素来初始化。</p>
<p>这种方式有几个缺点：</p>
<ul>
<li>使用匿名内部类，会有效率上的损失。当然在大多数情况下，这点效率都是可接受的。</li>
<li>静态内部类持有所在外部类的引用。如果需要将 List 返回给到其他地方使用，可能造成内存泄漏。</li>
</ul>
<h3 id="3-使用-Arrays-asList"><a href="#3-使用-Arrays-asList" class="headerlink" title="3.使用 Arrays.asList"></a>3.使用 <code>Arrays.asList</code></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; stringList = Arrays.asList(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>这种方式使用了 <code>java.util.Arrays</code> 的静态方法。写法上比之前的两种都更简洁，也没有构造匿名内部类的效率问题。</p>
<p>但也有几点需要注意：</p>
<ul>
<li><code>Arrays.asList</code> 返回的是 <code>Arrays</code> 的静态内部类（静态内部类不持有所在外部类的引用）。</li>
</ul>
<p>这个内部类继承自 <code>AbstractList</code>，实现了 <code>RandomAccess</code>，内部使用了一个数组来存储元素。但是不支持增删元素。这点需要注意。如果只是使用 <code>Arrays.asList</code> 来初始化常量，那么这点就不算什么问题了。</p>
<ul>
<li><code>Arrays.asList</code> 的参数如果是基本类型的数组时，需要留意返回值可能和你预期的不同。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] intArray = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">Integer[] integerArray = <span class="keyword">new</span> Integer[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"> </span><br><span class="line">List&lt;<span class="keyword">int</span>[] &gt; intArrayList = Arrays.asList(intArray);</span><br><span class="line">List&lt;Integer&gt; integerList = Arrays.asList(integerArray);</span><br><span class="line">List&lt;Integer&gt; integerList2 = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<p>这里 <code>Arrays.asList(intArray)</code> 的返回值是 <code>List&lt;int[]&gt;</code> 而不是 <code>List&lt;Integer&gt;</code>。这一点也算不上问题，只是使用时需要留意。如果能在 Java 中做到尽量使用 List 和 Integer，尽量避免使用 int 等基本类型和 <code>[]</code> 这种较为底层的数据结构即可避免。</p>
<h3 id="4-使用-Stream-JDK8"><a href="#4-使用-Stream-JDK8" class="headerlink" title="4. 使用 Stream (JDK8)"></a>4. 使用 <code>Stream</code> (JDK8)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = Stream.of(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>).collect(Collectors.toList());</span><br></pre></td></tr></table></figure>

<p>使用了 JDK8 的 Stream 来初始化。 单纯初始化 List，使用 Stream 有点大材小用了。</p>
<h3 id="5-使用-Lists-（JDK9）"><a href="#5-使用-Lists-（JDK9）" class="headerlink" title="5. 使用 Lists （JDK9）"></a>5. 使用 <code>Lists</code> （JDK9）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = Lists.newArrayList(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>这个和 <code>Arrays.asList</code> 一样简洁清晰。</p>
<h2 id="方法摘要"><a href="#方法摘要" class="headerlink" title="方法摘要"></a>方法摘要</h2><p><strong>add</strong></p>
<p>boolean add(E e)<br>向列表的尾部添加指定的元素（可选操作）。  </p>
<p>参数：<br>e - 要添加到列表的元素   </p>
<p>返回：<br>true（根据 Collection.add(E) 的规定） </p>
<p><strong>add</strong><br>void add(int index, E element)<br>在列表的指定位置插入指定元素（可选操作）。将当前处于该位置的元素（如果有的话）和所有后续元素向右移动（在其索引中加 1）。 </p>
<p>参数：<br>index - 要在其中插入指定元素处的索引<br>element - 要插入的元素 </p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://wenwenhuan.gitee.io/2020/10/17/%E9%80%92%E5%BD%92%E5%92%8C%E8%BF%AD%E4%BB%A3%E7%9A%84%E5%8C%BA%E5%88%AB%E3%80%81%E8%81%94%E7%B3%BB%E3%80%81%E4%BC%98%E7%BC%BA%E7%82%B9/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="温文焕">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wenhuan Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/10/17/%E9%80%92%E5%BD%92%E5%92%8C%E8%BF%AD%E4%BB%A3%E7%9A%84%E5%8C%BA%E5%88%AB%E3%80%81%E8%81%94%E7%B3%BB%E3%80%81%E4%BC%98%E7%BC%BA%E7%82%B9/" class="post-title-link" itemprop="url">递归和迭代的区别、联系、优缺点及实例对比</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-10-17 17:16:00" itemprop="dateCreated datePublished" datetime="2020-10-17T17:16:00+08:00">2020-10-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2021-05-12 12:10:20" itemprop="dateModified" datetime="2021-05-12T12:10:20+08:00">2021-05-12</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="1-概念区分"><a href="#1-概念区分" class="headerlink" title="1.概念区分"></a>1.概念区分</h2><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>程序调用自身的编程技巧称为递归,是函数自己调用自己</p>
<p>一个函数在其定义中直接或间接调用自身的一种方法,它通常把一个大型的复杂的问题转化为一个与原问题相似的规模较小的问题来解决,可以极大的减少代码量.递归的能力在于用有限的语句来定义对象的无限集合</p>
<p>使用递归要注意的有两点:</p>
<ol>
<li><p>递归就是在过程或函数里面调用自身</p>
</li>
<li><p>在使用递归时,必须有一个明确的递归结束条件,称为<strong>递归出口</strong></p>
</li>
</ol>
<p>递归分为两个阶段:</p>
<p>1)递推:把复杂的问题的求解推到比原问题简单一些的问题的求解;</p>
<p>2)回归:当获得最简单的情况后,逐步返回,依次得到复杂的解.</p>
<p>利用递归可以解决很多问题:如背包问题,汉诺塔问题,…等.</p>
<p>斐波那契数列为:0,1,1,2,3,5…</p>
<p><strong>由于递归引起一系列的函数调用,并且有可能会有一系列的重复计算,递归算法的执行效率相对较低.</strong></p>
<h3 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h3><p>利用变量的原值推算出变量的一个新值,如果递归是自己调用自己的话,迭代就是A不停的调用B</p>
<h2 id="2-辩证看递归和迭代"><a href="#2-辩证看递归和迭代" class="headerlink" title="2.辩证看递归和迭代"></a>2.辩证看递归和迭代</h2><p>递归的使用可以使代码更简洁清晰，可读性更好，但由于递归需要系统堆栈，所以空间消耗要比非递归代码要大很多，而且，如果递归深度太大，可能系统资源会不够用。</p>
<p><strong>往往有这样的观点：能不用递归就不用递归，递归都可以用迭代来代替。</strong></p>
<p>在理论上，递归和迭代在时间复杂度方面是等价的（在不考虑函数调用开销和函数调用产生的堆栈开销），但实际上递归确实效率比迭代低，递归没有任何优势，是不是就没有使用递归的必要了，那递归的存在有何意义呢？</p>
<p>从算法结构来说，递归声明的结构并不总能够转换为迭代结构，原因在于结构的引申本身属于递归的概念，<strong>用迭代的方法在设计初期根本无法实现</strong>。这也是为什么在结构设计时，通常采用递归的方式而不是采用迭代的方式的原因，一个极典型的例子类似于链表，使用递归定义及其简单，但对于内存定义(数组方式)其定义及调用处理说明就变得很晦涩，尤其是在遇到环链、图、网格等问题时，使用迭代方式从描述到实现上都变得不现实。因而可以从实际上说，所有的迭代可以转换为递归，但递归不一定可以转换为迭代。</p>
<p>递归其实是方便了程序员难为了机器，递归可以通过数学公式很方便的转换为程序。其优点就是易理解，容易编程。但<strong>递归是用栈机制实现的，每深入一层，都要占去一块栈数据区域，对嵌套层数深的一些算法，递归会力不从心，空间上会以内存崩溃而告终，而且递归也带来了大量的函数调用，这也有许多额外的时间开销。所以在深度大时，它的时空性就不好了。</strong></p>
<p>而迭代虽然效率高，运行时间只因循环次数增加而增加，没什么额外开销，空间上也没有什么增加，但缺点就是不容易理解，编写复杂问题时困难。</p>
<h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3.总结"></a>3.总结</h2><table>
<thead>
<tr>
<th>-</th>
<th align="left">定义</th>
<th align="left">优点</th>
<th align="left">缺点</th>
</tr>
</thead>
<tbody><tr>
<td>递归</td>
<td align="left">程序调用自身的编程技巧称为递归</td>
<td align="left">1）大问题化为小问题,可以极大的减少代码量；<br>2）用有限的语句来定义对象的无限集合<br>3）代码更简洁清晰，可读性更好</td>
<td align="left">1）递归调用函数,浪费空间<br>2）递归太深容易造成堆栈的溢出；</td>
</tr>
<tr>
<td>迭代</td>
<td align="left">利用变量的原值推算出变量的一个新值，迭代就是A不停的调用B</td>
<td align="left">1）迭代效率高，运行时间只因循环次数增加而增加<br>2）没什么额外开销，空间上也没有什么增加，</td>
<td align="left">1） 不容易理解<br>2） 代码不如递归简洁<br>3） 编写复杂问题时困难。</td>
</tr>
</tbody></table>
<p><strong>二者关系</strong></p>
<ol>
<li><p>递归中一定有迭代,但是迭代中不一定有递归,大部分可以相互转换</p>
</li>
<li><p>能用迭代的不用递归,递归调用函数,浪费空间,并且递归太深容易造成堆栈的溢出</p>
</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://wenwenhuan.gitee.io/2020/10/17/springmvc%E4%B8%89%E4%B8%AA%E9%87%8D%E8%A6%81%E6%B3%A8%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="温文焕">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wenhuan Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/10/17/springmvc%E4%B8%89%E4%B8%AA%E9%87%8D%E8%A6%81%E6%B3%A8%E8%A7%A3/" class="post-title-link" itemprop="url">RequestMapping注解</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-10-17 10:00:00" itemprop="dateCreated datePublished" datetime="2020-10-17T10:00:00+08:00">2020-10-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2021-02-28 16:47:14" itemprop="dateModified" datetime="2021-02-28T16:47:14+08:00">2021-02-28</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="RequestMapping注解"><a href="#RequestMapping注解" class="headerlink" title="RequestMapping注解"></a>RequestMapping注解</h2><p><strong>作用：</strong> 用于建立请求URL和处理请求方法之间的对应关系。<br><strong>出现位置：</strong>  </p>
<ul>
<li><strong>类上：</strong><br>请求URL的第一级访问目录。此处不写的话，就相当于应用的根目录。写的话需要以/开头。 它出现的目的是为了使我们的URL可以按照模块化管理:  <ul>
<li>例如：<br>账户模块：  </li>
</ul>
</li>
</ul>
<p>*/account/*add<br>        */account/*update<br>        */account/*delete …<br>订单模块:<br> */order/*add<br>*/order/*update<br>*/order/*delete<br>*/…/*的部分就是把RequsetMappding写在类上，使我们的URL更加精细。  </p>
<ul>
<li><strong>方法上：</strong><br>请求URL的第二级访问目录。</li>
</ul>
<p><strong>属性：</strong>  </p>
<ul>
<li>value：用于指定请求的URL。它和path属性的作用是一样的。</li>
<li>method：用于指定请求的方式。(eg:get请求/post请求)</li>
<li>params：用于指定限制请求参数的条件。它支持简单的表达式。要求请求参数的key和value必须和配置的<strong>一模一样!!!</strong>  <ul>
<li>例如：<br>params = {“accountName”}，表示请求参数必须有accountName<br>params = {“moeny!100”}，表示请求参数中money不能是100。</li>
</ul>
</li>
<li>headers：用于指定限制请求消息头的条件。<br>注意： 以上四个属性只要出现2个或以上时，他们的关系是与的关系。</li>
</ul>
<p><strong>使用示例：</strong></p>
<ul>
<li>出现位置的示例：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*RequestMapping 注解出现的位置</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Controller(&quot;accountController&quot;)</span> <span class="meta">@RequestMapping(&quot;/account&quot;)</span><span class="comment">//RequestMapping作用于类上</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountController</span> </span>&#123;</span><br><span class="line"><span class="meta">@RequestMapping(&quot;/findAccount&quot;)</span><span class="comment">//RequestMapping作用于方法上</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">findAccount</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        System.out.println(<span class="string">&quot;查询了账户。。。。&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">jsp 中的代码：</span><br><span class="line">&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt;</span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;</span> <span class="meta-string">&quot;http://www.w3.org/TR/html4/loose.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;Content-Type&quot;</span> <span class="attr">content</span>=<span class="string">&quot;text/html; charset=UTF-8&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>requestmapping 的使用<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 第一种访问方式 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;$&#123;pageContext.request.contextPath&#125;/account/findAccount&quot;</span>&gt;</span>查询账户<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 第二种访问方式 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;account/findAccount&quot;</span>&gt;</span>查询账户<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line">注意：</span><br><span class="line">当我们使用此种方式配置时，在 jsp 中第二种写法时，不要在访问 URL 前面加/，否则无法找到资源。</span><br></pre></td></tr></table></figure>

<ul>
<li>method 属性的示例：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">控制器代码：</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*保存账户</span></span><br><span class="line"><span class="comment">*<span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@RequestMapping(value=&quot;/saveAccount&quot;,method=RequestMethod.POST)</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">saveAccount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;保存了账户&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">jsp 代码：</span><br><span class="line"><span class="comment">&lt;!-- 请求方式的示例 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;account/saveAccount&quot;</span>&gt;</span>保存账户，get 请求<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;account/saveAccount&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;保存账户，post 请求&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line">当使用 get 请求时，提示错误信息是 405，信息是方法不支持 get 方式请求</span><br></pre></td></tr></table></figure>

<ul>
<li>params 属性的示例：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">控制器的代码：</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*	删除账户</span></span><br><span class="line"><span class="comment">*	<span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@RequestMapping(value=&quot;/removeAccount&quot;,params= &#123;&quot;accountName&quot;,&quot;money&gt;100&quot;&#125;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">removeAccount</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        System.out.println(<span class="string">&quot;删除了账户&quot;</span>); </span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">jsp 中的代码：</span><br><span class="line"><span class="comment">&lt;!-- 请求参数的示例 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;account/removeAccount?accountName=aaa&amp;money&gt;100&quot;</span>&gt;</span>删除账户，金额 100<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;account/removeAccount?accountName=aaa&amp;money&gt;150&quot;</span>&gt;</span>删除账户，金额 150<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">注意：</span><br><span class="line">当我们点击第一个超链接时,可以访问成功。</span><br><span class="line">当我们点击第二个超链接时，提示错误信息是 400,无法访问。</span><br></pre></td></tr></table></figure>

<h2 id="RequestParam"><a href="#RequestParam" class="headerlink" title="RequestParam"></a>RequestParam</h2><p><strong>作用：</strong><br>把请求中指定名称的参数给控制器中的形参赋值。<br><strong>属性：</strong></p>
<ul>
<li>value：请求参数中的名称。</li>
<li>required：请求参数中是否必须提供此参数。默认值：true。表示必须提供，如果不提供将报错。  </li>
</ul>
<p><strong>使用示例：</strong></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">jsp 中的代码：</span><br><span class="line"><span class="comment">&lt;!-- requestParams 注解的使用 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;springmvc/useRequestParam?name=test&quot;</span>&gt;</span>requestParam 注解<span class="tag">&lt;/<span class="name">a</span>&gt;</span> </span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">控制器中的代码：</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*requestParams 注解的使用</span></span><br><span class="line"><span class="comment">*<span class="doctag">@param</span> username</span></span><br><span class="line"><span class="comment">*<span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/useRequestParam&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">useRequestParam</span><span class="params">(<span class="meta">@RequestParam(&quot;name&quot;)</span>String username,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="meta">@RequestParam(value=&quot;age&quot;,required=false)</span>Integer age)</span></span>&#123; </span><br><span class="line">        System.out.println(username+<span class="string">&quot;,&quot;</span>+age);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="RequestBody"><a href="#RequestBody" class="headerlink" title="RequestBody"></a>RequestBody</h2><p><strong>作用：</strong> 用于获取请求体内容。直接使用得到是 key=value&amp;key=value…结构的数据。get 请求方式不适用。<br><strong>属性：</strong>  </p>
<ul>
<li>required：是否必须有请求体。默认值是:true。当取值为 true 时,get 请求方式会报错。如果取值为 false，get 请求得到是 null。</li>
</ul>
<p><strong>使用示例：</strong></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">post 请求 jsp 代码：</span><br><span class="line"><span class="comment">&lt;!-- request body 注解 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;springmvc/useRequestBody&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">用户名称：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> &gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">用户密码：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> &gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">用户年龄：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> &gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;保存&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">get 请求 jsp 代码：（得到是空）</span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;springmvc/use</span></span></span><br><span class="line"><span class="tag"><span class="string">RequestBody?body=test&quot;</span>&gt;</span>requestBody 注解 get 请求<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">控制器代码：</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*RequestBody 注解</span></span><br><span class="line"><span class="comment">*<span class="doctag">@param</span> user</span></span><br><span class="line"><span class="comment">*<span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">*/</span> <span class="meta">@RequestMapping(&quot;/useRequestBody&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">useRequestBody</span><span class="params">(<span class="meta">@RequestBody(required=false)</span> String body)</span> </span>&#123; </span><br><span class="line">        System.out.println(body);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="PathVaribale"><a href="#PathVaribale" class="headerlink" title="PathVaribale"></a>PathVaribale</h2><p><strong>作用：</strong> 用于绑定 url 中的占位符。</p>
<ul>
<li>例如：请求 url 中 /delete/{id}，这个{id}就是 url 占位符。url 支持占位符是 spring3.0 之后加入的。是 springmvc 支持 rest 风格 URL 的一个重要标志。  </li>
</ul>
<p><strong>属性：</strong></p>
<ul>
<li>value：用于指定 url 中占位符名称。</li>
<li>required：是否必须提供占位符。</li>
</ul>
<p><strong>使用示例:</strong>  </p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">jsp 代码：</span><br><span class="line"><span class="comment">&lt;!-- PathVariable 注解 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;springmvc/usePathVariable/100&quot;</span>&gt;</span>pathVariable 注解<span class="tag">&lt;/<span class="name">a</span>&gt;</span> </span><br></pre></td></tr></table></figure>

<pre><code class="java">控制器代码：
/**
*PathVariable 注解
*@param user
* @return
*/ @RequestMapping(&quot;/usePathVariable/&#123;id&#125;&quot;)
public String    usePathVariable(@PathVariable(&quot;id&quot;) Integer id) &#123;
        System.out.println(id);
        return &quot;success&quot;;
&#125;
</code></pre>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://wenwenhuan.gitee.io/2020/10/17/static%E5%85%B3%E9%94%AE%E5%AD%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="温文焕">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wenhuan Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/10/17/static%E5%85%B3%E9%94%AE%E5%AD%97/" class="post-title-link" itemprop="url">static关键字</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-10-17 10:00:00" itemprop="dateCreated datePublished" datetime="2020-10-17T10:00:00+08:00">2020-10-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2021-05-18 00:21:48" itemprop="dateModified" datetime="2021-05-18T00:21:48+08:00">2021-05-18</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a><strong>概念</strong></h2><hr>
<p>java中的<code>static</code>关键字主要用于内存管理。</p>
<p>静态(<code>static</code>)可以是：</p>
<ol>
<li>变量(也称为类变量)</li>
<li>方法(也称为类方法)</li>
<li>代码块</li>
<li>嵌套类</li>
</ol>
<h2 id="1-Java静态变量"><a href="#1-Java静态变量" class="headerlink" title="1. Java静态变量"></a>1. Java静态变量</h2><p>将一个变量声明为<code>static</code>。</p>
<ul>
<li>静态变量可以用于引用所有对象的公共属性(对于每个对象不是唯一的)。如：员工公司名称，学生所在的大学名称。</li>
</ul>
<p><strong>静态变量的优点：</strong></p>
<ul>
<li>它能使程序存储器高效(即它节省内存)。</li>
</ul>
<p><strong>理解不使用静态变量的问题</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;  </span><br><span class="line">     <span class="keyword">int</span> rollno;  </span><br><span class="line">     String name;  </span><br><span class="line">     String college=<span class="string">&quot;ITS&quot;</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设在一所学校有<code>500</code>名学生，现在所有实例数据成员将在每次创建对象时获取内存。所有学生都有其唯一的注册ID：<code>rollno</code>和　<code>name</code> ，因此实例数据成员没有什么问题。<code>college</code> 指的是所有对象的共同属性。如果使它静态化(使用<code>static</code>关键字修饲)，这个字段将只获得内存一次。</p>
<blockquote>
<p>Java静态属性被共享给所有对象。</p>
</blockquote>
<p><strong>静态变量的示例</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Program of static variable  </span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student8</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rollno;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">static</span> String college = <span class="string">&quot;ITS&quot;</span>;</span><br><span class="line"></span><br><span class="line">    Student8(<span class="keyword">int</span> r, String n) &#123;</span><br><span class="line">        rollno = r;</span><br><span class="line">        name = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(rollno + <span class="string">&quot; &quot;</span> + name + <span class="string">&quot; &quot;</span> + college);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        Student8 s1 = <span class="keyword">new</span> Student8(<span class="number">111</span>, <span class="string">&quot;Karan&quot;</span>);</span><br><span class="line">        Student8 s2 = <span class="keyword">new</span> Student8(<span class="number">222</span>, <span class="string">&quot;Aryan&quot;</span>);</span><br><span class="line"></span><br><span class="line">        s1.display();</span><br><span class="line">        s2.display();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码执行结果如下 -</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">111</span> Karan ITS</span><br><span class="line"><span class="number">222</span> Aryan ITS</span><br></pre></td></tr></table></figure>

<p>创建对象示例图如下所示 -</p>
<img src="/2020/10/17/static%E5%85%B3%E9%94%AE%E5%AD%97/117100301_14333.jpg" class="" title="img">

<p><strong>不使用静态变量的计数器程序</strong></p>
<p>在这个例子中，我们创建了一个名为<code>count</code>的实例变量用来统计创建对象的数目，它在构造函数中执行递增。 由于实例变量在创建对象时要获取内存，每个对象都将具有实例变量的副本，如果它被递增了，它也不会反映到其他对象中。所以每个对象在<code>count</code>变量中的值还是<code>1</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;<span class="comment">// will get memory when instance is created</span></span><br><span class="line"></span><br><span class="line">    Counter() &#123;</span><br><span class="line">        count++;</span><br><span class="line">        System.out.println(count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Counter c1 = <span class="keyword">new</span> Counter();</span><br><span class="line">        Counter c2 = <span class="keyword">new</span> Counter();</span><br><span class="line">        Counter c3 = <span class="keyword">new</span> Counter();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Java</span><br></pre></td></tr></table></figure>

<p>上面代码执行结果如下 -</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line">Java</span><br></pre></td></tr></table></figure>

<p><strong>计数器静态变量的程序</strong><br>如上所述，静态变量将只获取一次内存，如果任何对象更改静态变量的值，它将保留其值，所有实例均可访问同一变量值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;<span class="comment">// will get memory only once and retain its value</span></span><br><span class="line"></span><br><span class="line">    Counter2() &#123;</span><br><span class="line">        count++;</span><br><span class="line">        System.out.println(count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Counter2 c1 = <span class="keyword">new</span> Counter2();</span><br><span class="line">        Counter2 c2 = <span class="keyword">new</span> Counter2();</span><br><span class="line">        Counter2 c3 = <span class="keyword">new</span> Counter2();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Java</span><br></pre></td></tr></table></figure>

<p>上面代码执行结果如下 -</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>

<h2 id="2-Java静态方法（无需创建实例、访问静态变量）"><a href="#2-Java静态方法（无需创建实例、访问静态变量）" class="headerlink" title="2. Java静态方法（无需创建实例、访问静态变量）"></a>2. Java静态方法（无需创建实例、访问静态变量）</h2><p>如果在任何方法上应用<code>static</code>关键字，此方法称为静态方法。</p>
<ul>
<li>静态方法属于类，而不属于类的对象。</li>
<li><strong>可以直接调用静态方法，而无需创建类的实例。</strong></li>
<li>静态方法<strong>可以访问静态数据成员，并可以更改静态数据成员的值。</strong></li>
</ul>
<p><strong>静态方法的示例</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Program of changing the common property of all objects(static field).  </span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student9</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rollno;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">static</span> String college = <span class="string">&quot;ITS&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        college = <span class="string">&quot;BBDIT&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Student9(<span class="keyword">int</span> r, String n) &#123;</span><br><span class="line">        rollno = r;</span><br><span class="line">        name = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(rollno + <span class="string">&quot; &quot;</span> + name + <span class="string">&quot; &quot;</span> + college);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        Student9.change();</span><br><span class="line"></span><br><span class="line">        Student9 s1 = <span class="keyword">new</span> Student9(<span class="number">111</span>, <span class="string">&quot;Karan&quot;</span>);</span><br><span class="line">        Student9 s2 = <span class="keyword">new</span> Student9(<span class="number">222</span>, <span class="string">&quot;Aryan&quot;</span>);</span><br><span class="line">        Student9 s3 = <span class="keyword">new</span> Student9(<span class="number">333</span>, <span class="string">&quot;Sonoo&quot;</span>);</span><br><span class="line"></span><br><span class="line">        s1.display();</span><br><span class="line">        s2.display();</span><br><span class="line">        s3.display();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码执行输出以下结果 - </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">111</span> Karan BBDIT</span><br><span class="line"><span class="number">222</span> Aryan BBDIT</span><br><span class="line"><span class="number">333</span> Sonoo BBDIT</span><br></pre></td></tr></table></figure>

<p><strong>执行正常计算的静态方法的另一个示例:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Program to get cube of a given number by static method  </span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Calculate</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">cube</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x * x * x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = Calculate.cube(<span class="number">5</span>);</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码执行输出以下结果 - </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">125</span></span><br></pre></td></tr></table></figure>

<p><strong>静态方法的限制</strong></p>
<p>静态方法有两个主要限制。它们分别是：</p>
<ul>
<li>静态方法<strong>不能直接使用非静态数据成员或调用非静态方法</strong>。</li>
<li><code>this</code>和<code>super</code>两个关键字不能在静态上下文中使用。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">40</span>;<span class="comment">// non static</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        System.out.println(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码执行输出以下结果 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[编译错误！]Compile Time Error</span><br></pre></td></tr></table></figure>

<p><strong>为什么java main方法是静态的？</strong></p>
<p>这是因为对象不需要调用静态方法，如果它是非静态方法，jvm首先要创建对象，然后调用main()方法，这将导致额外的内存分配的问题。</p>
<p>main方法是JVM执行的入口，为了方便JVM调用，所以需要将他的访问权限设置为public，并且静态方法可以方便JVM直接调用，无需实例化对象。</p>
<h2 id="3-Java静态块（在类加载时在main方法之前执行）"><a href="#3-Java静态块（在类加载时在main方法之前执行）" class="headerlink" title="3. Java静态块（在类加载时在main方法之前执行）"></a>3. Java静态块（在类加载时在main方法之前执行）</h2><p>Java中的静态块主要有两个作用：</p>
<ul>
<li>用于初始化静态数据成员。</li>
<li>它在类加载时在main方法之前执行。</li>
</ul>
<p><strong>静态块的示例</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;static block is invoked&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello main&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码执行输出以下结果 - </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> block is invoked</span><br><span class="line">Hello main</span><br></pre></td></tr></table></figure>

<p><strong>可以执行程序没有main()方法吗？</strong><br><strong>答：</strong>是的，一种方式是静态块，但在以前旧的JDK版本中，不是在JDK 1.7。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A3</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;static block is invoked&quot;</span>);</span><br><span class="line">        System.exit(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码执行输出以下结果 - </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> block is invoked</span><br></pre></td></tr></table></figure>

<p>在JDK7及以上版本中，输出将为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">错误: 在类 Main 中找不到 main 方法, 请将 main 方法定义为:</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://wenwenhuan.gitee.io/2020/10/16/Java%E7%9A%84%E5%80%BC%E4%BC%A0%E9%80%92%E6%9C%BA%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="温文焕">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wenhuan Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/10/16/Java%E7%9A%84%E5%80%BC%E4%BC%A0%E9%80%92%E6%9C%BA%E5%88%B6/" class="post-title-link" itemprop="url">Java的值传递机制</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-10-16 10:00:00" itemprop="dateCreated datePublished" datetime="2020-10-16T10:00:00+08:00">2020-10-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2021-04-26 11:36:14" itemprop="dateModified" datetime="2021-04-26T11:36:14+08:00">2021-04-26</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>和C语言一样，Java中也是采用“值传递”，即传递的是原参数的复印件，并不会影响原参数  </p>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>形参：方法声明时，方法小括号内的参数<br>实参：调用方法时，实际传入的参数的值</p>
<h2 id="规则：java中的参数传递机制：值传递机制"><a href="#规则：java中的参数传递机制：值传递机制" class="headerlink" title="规则：java中的参数传递机制：值传递机制"></a>规则：java中的参数传递机制：值传递机制</h2><ol>
<li>形参是基本数据类型的：将实参的值传递给形参的基本数据类型的变量</li>
<li>形参是引用数据类型的：将实参的引用类型变量的值（对应的堆空间的对象实体的首地址值）传递给形参的引用类型变量。</li>
</ol>
<p><strong>代码演示：</strong><br>基本类型的实例变量的传值机制</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Java的值传递问题;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义一个学生类，里面有基本类型引用类型的实例变量方便测试</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Stu</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> age = <span class="number">18</span>;</span><br><span class="line">        String name = <span class="string">&quot;wenhuan&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//构造一个changeAge方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">changeAge</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">        s = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//构造一个changeName方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">changeName</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        s = <span class="string">&quot;null&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Stu s = <span class="keyword">new</span> Stu();</span><br><span class="line">        <span class="comment">//调用changeAge方法来改变stu的age</span></span><br><span class="line">        System.out.println(<span class="string">&quot;尝试改变前的s的age：&quot;</span>+s.age);<span class="comment">//尝试改变前的s的age：18</span></span><br><span class="line">        changeAge(s.age);</span><br><span class="line">        System.out.println(<span class="string">&quot;尝试改变后的s的age：&quot;</span>+s.age);<span class="comment">//尝试改变后的s的age：18</span></span><br><span class="line">        <span class="comment">//age的值没有改变，猜想传入方法中的参数只是age的一个副本而不是age本身。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在main方法中直接更改age</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;尝试改变前的s的age：&quot;</span>+s.age);<span class="comment">//尝试改变前的s的age：18</span></span><br><span class="line"><span class="comment">//        changeAge(s.age);</span></span><br><span class="line">        s.age = <span class="number">0</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;尝试改变后的s的age：&quot;</span>+s.age);<span class="comment">//尝试改变后的s的age：0</span></span><br></pre></td></tr></table></figure>

<p>age发生了改变，证明是传入时出了问题，传的是副本。</p>
<p>引用类型的实例变量的传值机制</p>
<p>尝试将引用类型实例变量name当做参数传入方法，在方法内实例化一个新的对象并将该对象的地址传给参数,从而修改name的指向</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;尝试改变前的s的name：&quot;</span>+s.name);<span class="comment">//尝试改变前的s的name：wenhuan</span></span><br><span class="line">changeName(s.name);</span><br><span class="line">System.out.println(<span class="string">&quot;尝试改变后的s的name：&quot;</span>+s.name);<span class="comment">//尝试改变前的s的name：wenhuan</span></span><br></pre></td></tr></table></figure>

<p>发现name并没有改变，指向的仍旧是原来的那个对象，猜想传入方法的参数不是name本身而是name的一个副本（也就是地址的一个副本）。</p>
<p>在main方法中直接更改name</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;尝试改变前的s的name：&quot;</span>+s.name);<span class="comment">//尝试改变前的s的name：wenhuan</span></span><br><span class="line">s.name = <span class="string">&quot;null&quot;</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;尝试改变后的s的name：&quot;</span>+s.name);<span class="comment">//尝试改变前的s的name：null</span></span><br></pre></td></tr></table></figure>

<p>name发生了改变，证明是传入时出了问题，传的是地址的一个副本。</p>
<p><strong>总结</strong></p>
<p>　　以上所有操作只说明一个结果：Java中传参是值传递，<strong>传入方法的只是一个copy</strong>。传基本类型的变量时传的是数据的一个copy，传引用类型的变量时传的是地址的一个copy。此时注意引用类型的变量承载的只是对象的地址而不是对象本身!</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://wenwenhuan.gitee.io/2020/10/15/%E4%BA%8C%E5%8F%89%E6%A0%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="温文焕">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wenhuan Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/10/15/%E4%BA%8C%E5%8F%89%E6%A0%91/" class="post-title-link" itemprop="url">二叉树</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-10-15 12:07:32" itemprop="dateCreated datePublished" datetime="2020-10-15T12:07:32+08:00">2020-10-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2021-05-07 02:52:56" itemprop="dateModified" datetime="2021-05-07T02:52:56+08:00">2021-05-07</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>树是一种经常用到的数据结构，用来模拟具有树状结构性质的数据集合。</p>
<p>树里的每一个节点有一个值和一个包含所有子节点的列表。从图的观点来看，树也可视为一个拥有N 个节点和N-1 条边的一个有向无环图。</p>
<p>二叉树是一种更为典型的树状结构。如它名字所描述的那样，二叉树是每个节点最多有两个子树的树结构，通常子树被称作“左子树”和“右子树”。</p>
<p><strong>知识点：</strong>  </p>
<ol>
<li>树的节点结构</li>
<li>深度优先搜索（DFS）：树的前序遍历，中序遍历，后续遍历的解法<ul>
<li>递归</li>
<li>迭代</li>
</ul>
</li>
<li>层序顺序遍历（使用队列）</li>
<li>运用递归解决树的相关问题<ul>
<li>“自顶而下”和“自底而上”的解题思路</li>
<li>二叉树的最大深度</li>
<li>对称二叉树</li>
<li>路径总和</li>
</ul>
</li>
<li>总结</li>
</ol>
<h2 id="1-数的节点结构"><a href="#1-数的节点结构" class="headerlink" title="1. 数的节点结构"></a>1. 数的节点结构</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> data;  </span><br><span class="line">    <span class="keyword">private</span> Node leftNode;  </span><br><span class="line">    <span class="keyword">private</span> Node rightNode;  </span><br><span class="line"></span><br><span class="line">    TreeNode(<span class="keyword">int</span> val) &#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> data, Node leftNode, Node rightNode)</span></span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.data = data;  </span><br><span class="line">        <span class="keyword">this</span>.leftNode = leftNode;  </span><br><span class="line">        <span class="keyword">this</span>.rightNode = rightNode;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getData</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> data;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setData</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.data = data;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">getLeftNode</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> leftNode;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLeftNode</span><span class="params">(Node leftNode)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.leftNode = leftNode;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">getRightNode</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> rightNode;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRightNode</span><span class="params">(Node rightNode)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.rightNode = rightNode;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>创建二叉树的时候注意必须逆序建立，先建立子节点，再逆序往上建立，因为非叶子结点会使用到下面的节点，而初始化是按顺序初始化的，不逆序建立会报错 。</p>
<h2 id="2-树的前序遍历，中序遍历，后续遍历的解法"><a href="#2-树的前序遍历，中序遍历，后续遍历的解法" class="headerlink" title="2. 树的前序遍历，中序遍历，后续遍历的解法"></a>2. 树的前序遍历，中序遍历，后续遍历的解法</h2><p>树的前序遍历，中序遍历，后续遍历的解法有递归和迭代两种</p>
<h3 id="递归解法"><a href="#递归解法" class="headerlink" title="递归解法"></a>递归解法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">theFirstTraversal</span><span class="params">(Node root)</span> </span>&#123;  <span class="comment">//先序遍历  </span></span><br><span class="line">        printNode(root);  </span><br><span class="line">        <span class="keyword">if</span> (root.getLeftNode() != <span class="keyword">null</span>) &#123;  <span class="comment">//使用递归进行遍历左孩子  </span></span><br><span class="line">            theFirstTraversal(root.getLeftNode());  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">if</span> (root.getRightNode() != <span class="keyword">null</span>) &#123;  <span class="comment">//递归遍历右孩子  </span></span><br><span class="line">            theFirstTraversal(root.getRightNode());  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">theInOrderTraversal</span><span class="params">(Node root)</span> </span>&#123;  <span class="comment">//中序遍历  </span></span><br><span class="line">    <span class="keyword">if</span> (root.getLeftNode() != <span class="keyword">null</span>) &#123;  </span><br><span class="line">        theInOrderTraversal(root.getLeftNode());  </span><br><span class="line">    &#125;  </span><br><span class="line">    printNode(root);  </span><br><span class="line">    <span class="keyword">if</span> (root.getRightNode() != <span class="keyword">null</span>) &#123;  </span><br><span class="line">        theInOrderTraversal(root.getRightNode());  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">thePostOrderTraversal</span><span class="params">(Node root)</span> </span>&#123;  <span class="comment">//后序遍历  </span></span><br><span class="line">    <span class="keyword">if</span> (root.getLeftNode() != <span class="keyword">null</span>) &#123;  </span><br><span class="line">        thePostOrderTraversal(root.getLeftNode());  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">if</span>(root.getRightNode() != <span class="keyword">null</span>) &#123;  </span><br><span class="line">        thePostOrderTraversal(root.getRightNode());  </span><br><span class="line">    &#125;  </span><br><span class="line">    printNode(root);  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<h3 id="迭代解法"><a href="#迭代解法" class="headerlink" title="迭代解法"></a>迭代解法</h3><h4 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建两个链接列表对象，指定TreeNode类型的作为栈来使用，Integer类型的用作存储排好序的数据</span></span><br><span class="line">    LinkedList&lt;TreeNode&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    LinkedList&lt;Integer&gt; output = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="comment">//判断传进来的参数是否为空，空的话返回空链表</span></span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> output;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//把头节点存入栈</span></span><br><span class="line">    stack.add(root);</span><br><span class="line">    <span class="comment">//while循环的条件很关键，</span></span><br><span class="line">    <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">        <span class="comment">//设置一个临时变量Node,用于操作栈，把栈中的值存入output中，出栈，按先序遍历顺序入栈</span></span><br><span class="line">        TreeNode node = <span class="keyword">new</span> TreeNode();</span><br><span class="line">        <span class="comment">//pollLast方法在出栈的同时还可以返回出栈的元素，非常方便</span></span><br><span class="line">        node = stack.pollLast();</span><br><span class="line">        output.addLast(node.val);</span><br><span class="line">        <span class="comment">//判断节点是否为空很重要</span></span><br><span class="line">        <span class="keyword">if</span>(node.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">            stack.add(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(node.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">            stack.add(node.left);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> output;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结</strong><br>迭代是自己创建并操作一个栈，按照先序遍历的特点，要注意，根结点是个例外，提前入栈，while循环做的第一件事是出栈并记录出栈的val，<strong>然后是右子树入栈</strong>，最后是左子树入栈，然后左子树出栈，其右左子树分别入栈，左子树全部出栈后，右子树出栈，其右左子树分别入栈，以此类推。因为栈是一种先进后出的结构。</p>
<p>入栈的顺序需要注意，栈是先进后出的结构，我们需要先读左子树，所以左子树反而要后入栈。</p>
<h4 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建LinkedList对象stack用来作为栈使用，output用来存储按中序遍历排号顺序的元素</span></span><br><span class="line">        LinkedList&lt;TreeNode&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        LinkedList&lt;Integer&gt; output = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (root != <span class="keyword">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">                stack.add(root);</span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125;</span><br><span class="line">            root = stack.pollLast();</span><br><span class="line">            output.add(root.val);</span><br><span class="line">            root = root.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> output;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结</strong><br>中序遍历和前序遍历不一样，中序遍历是从根结点开始先遍历到最左边的子树，依次入栈，而后出栈，然后<code>root = root.right;</code>检查该节点是否有右节点，有的话按前边的步骤再走一遍。</p>
<p>做了两道迭代遍历之后，其实有一个难点十分相似——<strong>右子树的处理</strong>，前序遍历和中序遍历都有一个向左边不断走的趋向，区别是前序遍历是每到一个节点先遍历本身，而中序遍历是找到最左的子树才开始出栈。两者对右子树的处理不相同，中续遍历是左子树出栈后，立刻其检查右子树，而前序遍历是按右左的顺序依次入栈。这是由其自身的逻辑特点决定的，有一定难度。</p>
<h4 id="后续遍历"><a href="#后续遍历" class="headerlink" title="后续遍历"></a>后续遍历</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        TreeNode prev = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 循环开始的条件是root不为空，或者栈不为空，这点和中序遍历一样。</span></span><br><span class="line">        <span class="keyword">while</span> (root != <span class="keyword">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">                stack.push(root);</span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125;</span><br><span class="line">            root = stack.pop();</span><br><span class="line">            <span class="comment">// res入栈的条件很难理解，先决条件是最左的元素，然后要满足栈顶节点的右子树为空或者为之前遍历过的才可以入栈</span></span><br><span class="line">            <span class="comment">// 为空很容易理解，由左右中的顺序，右为空的话可以直接跳过，开始遍历根结点</span></span><br><span class="line">            <span class="comment">// 同理，之前遍历过了的话则直接遍历根结点。</span></span><br><span class="line">            <span class="keyword">if</span> (root.right == <span class="keyword">null</span> || root.right == prev) &#123;</span><br><span class="line">                <span class="comment">// res入栈之后立刻记录入栈的节点prev，置root为空，使得其不用执行寻找最右节点的步骤，</span></span><br><span class="line">                res.add(root.val);</span><br><span class="line">                prev = root;</span><br><span class="line">                root = <span class="keyword">null</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 不满足条件的节点重新入栈，并把root置为该节点的右节点，</span></span><br><span class="line">                <span class="comment">// 这时该节点不为空且未被遍历。</span></span><br><span class="line">                stack.push(root);</span><br><span class="line">                root = root.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>后序遍历的迭代做法是三种里面最难的一种，左右中里面“右”这个点很难处理，这里关联到了后面“中”的处理，最左边的子树很好找，和前面两种方法一样。但要注意的是，找到最左节点之后还需要确认其右节点是否为空，是否被遍历过，也就是在以该节点为根结点的子树里面“左右中”的顺序依然生效，但其变为了根结点。</p>
<p>综上所述，最关键还是右节点的处理，在一棵最简单的子树里面有四种遍历可能：①左右中、②右中、③左中、④中，如何识别和遍历？</p>
<p>方法：在找到最左节点的时候，根据右节点的情况，判断它是哪一种情况。右节点已经被遍历过了（需要记录上一个遍历的节点做对比）为情况①或②，右节点为空为情况③或④，这些情况都可以直接遍历该节点，如果不符合这两个条件的话，则右节点不为空且还没被遍历，需要把右节点入栈，进行遍历。</p>
<h2 id="3-层序顺序遍历"><a href="#3-层序顺序遍历" class="headerlink" title="3.层序顺序遍历"></a>3.层序顺序遍历</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Map&lt;Integer, TreeNode&gt; ancestor = <span class="keyword">new</span> Hashtable&lt;&gt;();</span><br><span class="line">    Set&lt;Integer&gt; p_ancestor = <span class="keyword">new</span> HashSet&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        preorderTraversal(root);</span><br><span class="line">        <span class="comment">// 寻找p的所有父节点,存入数组</span></span><br><span class="line">        <span class="comment">// LinkedList&lt;TreeNode&gt; p_ancestor = new LinkedList&lt;&gt;();</span></span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            p_ancestor.add(p.val);</span><br><span class="line">            p = ancestor.get(p.val);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 寻找q的祖先并和p的祖先对比，相同则结束，</span></span><br><span class="line">        <span class="keyword">while</span> (q!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (p_ancestor.contains(q.val)) <span class="keyword">return</span> q;</span><br><span class="line">            q = ancestor.get(q.val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用哈希表存储所有子树的父节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//while (root != null) &#123;</span></span><br><span class="line">            <span class="keyword">if</span> (root.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                ancestor.put(root.left.val, root);</span><br><span class="line">                preorderTraversal(root.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (root.right!=<span class="keyword">null</span>) &#123;</span><br><span class="line">                ancestor.put(root.right.val, root);</span><br><span class="line">                preorderTraversal(root.right);</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">//&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>层序遍历的思路是首先把所有节点的父节点都用哈希表记录下来，然后在里面把p的所有祖先找出来（包括p），再开始找q的祖先，当出现一样的节点，即找到。</p>
<p>Q1：哈希表的key和vale的类型</p>
<p>可以两个都选择TreeNode类型，也可以选择&lt;Integer, TreeNode&gt;的形式，这个关系到程序运行的开销。两个都选择TreeNode类型，程序运行开销比&lt;Integer, TreeNode&gt;的形式大，操作基本数据类型开销小。</p>
<p>Q2：寻找祖先节点的条件判断</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(p!=<span class="keyword">null</span>)&#123;</span><br><span class="line">    p_ancestor.add(p.val);</span><br><span class="line">    p = ancestor.get(p.val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>直接使用p！=null，<strong>不需要新建临时存储的数据，直接使用传进来的p引用</strong>，<strong>不需要使用<code>contains(key)</code>方法</strong>通过获取的值不存在时get()返回的null值作为结束的条件，减少代码量。</p>
<p>Q3：数据类型的选择</p>
<p>这个解法中，使用Hashtable类继承Map接口创建存储子节点和父节点一一对应的哈希表，使用Hashset类继承Set接口创建存储p节点所有祖先的集合。</p>
<h2 id="4-运用递归解决树的相关问题"><a href="#4-运用递归解决树的相关问题" class="headerlink" title="4.运用递归解决树的相关问题"></a>4.运用递归解决树的相关问题</h2><p>递归是解决树相关问题的最有效和最常用的方法之一，这里记录两种典型的递归方法。</p>
<p>树可以以递归的方式定义为一个节点（根节点），它包括一个值和一个指向其他节点指针的列表。 递归是树的特性之一。 因此，许多树问题可以通过递归的方式来解决。 对于每个递归层级，我们只能关注单个节点内的问题，并通过递归调用函数来解决其子节点问题。</p>
<h3 id="“自顶而下”和“自底而上”的解题思路"><a href="#“自顶而下”和“自底而上”的解题思路" class="headerlink" title="“自顶而下”和“自底而上”的解题思路"></a>“自顶而下”和“自底而上”的解题思路</h3><h4 id="Part1-“自顶向下”-的解决方案"><a href="#Part1-“自顶向下”-的解决方案" class="headerlink" title="Part1.“自顶向下” 的解决方案"></a>Part1.“自顶向下” 的解决方案</h4><p>“自顶向下” 意味着在每个递归层级，我们将首先访问节点来计算一些值，并在递归调用函数时将这些值传递到子节点。 所以 “自顶向下” 的解决方案可以被认为是一种前序遍历。 具体来说，递归函数 top_down(root, params) 的原理是这样的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="keyword">return</span> specific value <span class="keyword">for</span> <span class="keyword">null</span> node</span><br><span class="line"><span class="number">2.</span> update the answer <span class="keyword">if</span> needed                      <span class="comment">// anwer &lt;-- params</span></span><br><span class="line"><span class="number">3.</span> left_ans = top_down(root.left, left_params)		<span class="comment">// left_params &lt;-- root.val, params</span></span><br><span class="line"><span class="number">4.</span> right_ans = top_down(root.right, right_params)	<span class="comment">// right_params &lt;-- root.val, params</span></span><br><span class="line"><span class="number">5.</span> <span class="keyword">return</span> the answer <span class="keyword">if</span> needed                      <span class="comment">// answer &lt;-- left_ans, right_ans</span></span><br></pre></td></tr></table></figure>

<p>例如，思考这样一个问题：给定一个二叉树，请寻找它的最大深度。</p>
<p>我们知道根节点的深度是1。 <strong>对于每个节点，如果我们知道某节点的深度，那我们将知道它子节点的深度。 因此，在调用递归函数的时候，将节点的深度传递为一个参数，那么所有的节点都知道它们自身的深度。 而对于叶节点，我们可以通过更新深度从而获取最终答案。</strong> 这里是递归函数 maximum_depth(root, depth) 的伪代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="keyword">return</span> <span class="keyword">if</span> root is <span class="keyword">null</span></span><br><span class="line"><span class="number">2.</span> <span class="keyword">if</span> root is a leaf node:</span><br><span class="line"><span class="number">3.</span> 		answer = max(answer, depth)         <span class="comment">// update the answer if needed</span></span><br><span class="line"><span class="number">4.</span> maximum_depth(root.left, depth + <span class="number">1</span>)      <span class="comment">// call the function recursively for left child</span></span><br><span class="line"><span class="number">5.</span> maximum_depth(root.right, depth + <span class="number">1</span>)		<span class="comment">// call the function recursively for right child</span></span><br></pre></td></tr></table></figure>

<p>java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> answer;		<span class="comment">// don&#x27;t forget to initialize answer before call maximum_depth</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">maximum_depth</span><span class="params">(TreeNode root, <span class="keyword">int</span> depth)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">        answer = Math.max(answer, depth);</span><br><span class="line">    &#125;</span><br><span class="line">    maximum_depth(root.left, depth + <span class="number">1</span>);</span><br><span class="line">    maximum_depth(root.right, depth + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Part2-“自底向上”-的解决方案"><a href="#Part2-“自底向上”-的解决方案" class="headerlink" title="Part2.“自底向上” 的解决方案"></a>Part2.“自底向上” 的解决方案</h4><p>“自底向上” 是另一种递归方法。 <strong>在每个递归层次上，我们首先对所有子节点递归地调用函数，然后根据返回值和根节点本身的值得到答案。</strong> 这个过程可以看作是后序遍历的一种。 通常， “自底向上” 的递归函数 bottom_up(root) 为如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="keyword">return</span> specific value <span class="keyword">for</span> <span class="keyword">null</span> node</span><br><span class="line"><span class="number">2.</span> left_ans = bottom_up(root.left)			<span class="comment">// call function recursively for left child</span></span><br><span class="line"><span class="number">3.</span> right_ans = bottom_up(root.right)		<span class="comment">// call function recursively for right child</span></span><br><span class="line"><span class="number">4.</span> <span class="keyword">return</span> answers                           <span class="comment">// answer &lt;-- left_ans, right_ans, root.val</span></span><br></pre></td></tr></table></figure>

<p>继续讨论前面关于树的最大深度的问题，但是使用不同的思维方式：<strong>对于树的单个节点，以节点自身为根的子树的最大深度x是多少？</strong></p>
<p>如果我们知道一个根节点，以其左子节点为根的最大深度为l和以其右子节点为根的最大深度为r，我们是否可以回答前面的问题？ 当然可以，我们可以选择它们之间的最大值，再加上1来获得根节点所在的子树的最大深度。 那就是 x = max（l，r）+ 1。</p>
<p>这意味着对于每一个节点来说，我们都可以在解决它子节点的问题之后得到答案。 因此，我们可以使用“自底向上“的方法。下面是递归函数 maximum_depth(root) 的伪代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="keyword">return</span> <span class="number">0</span> <span class="keyword">if</span> root is <span class="keyword">null</span>                 <span class="comment">// return 0 for null node</span></span><br><span class="line"><span class="number">2.</span> left_depth = maximum_depth(root.left)</span><br><span class="line"><span class="number">3.</span> right_depth = maximum_depth(root.right)</span><br><span class="line"><span class="number">4.</span> <span class="keyword">return</span> max(left_depth, right_depth) + <span class="number">1</span>	<span class="comment">// return depth of the subtree rooted at root</span></span><br></pre></td></tr></table></figure>

<p>java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximum_depth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;                                   <span class="comment">// return 0 for null node</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> left_depth = maximum_depth(root.left);</span><br><span class="line">	<span class="keyword">int</span> right_depth = maximum_depth(root.right);</span><br><span class="line">	<span class="keyword">return</span> Math.max(left_depth, right_depth) + <span class="number">1</span>;	<span class="comment">// return depth of the subtree rooted at root</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结</strong><br>了解递归并利用递归解决问题并不容易。</p>
<p>当遇到树问题时，请先思考一下两个问题：</p>
<ol>
<li>你能确定一些参数，从该节点自身解决出发寻找答案吗？  </li>
<li>你可以<strong>使用这些参数和节点本身的值来决定什么应该是传递给它子节点的参数</strong>吗？<br>如果答案都是肯定的，那么请尝试使用 “自顶向下” 的递归来解决此问题。</li>
</ol>
<p>或者你可以这样思考：对于树中的任意一个节点，如果你知道它子节点的答案，你能计算出该节点的答案吗？ 如果答案是肯定的，那么 “自底向上” 的递归可能是一个不错的解决方法。</p>
<p>在接下来提供几个经典例题，以帮助你更好地理解树的结构和递归。</p>
<h3 id="经典例题一：二叉树的最大深度"><a href="#经典例题一：二叉树的最大深度" class="headerlink" title="经典例题一：二叉树的最大深度"></a>经典例题一：二叉树的最大深度</h3><p>给定一个二叉树，找出其最大深度。</p>
<p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p>
<p>说明: 叶子节点是指没有子节点的节点。</p>
<p>示例：<br>给定二叉树 [3,9,20,null,null,15,7]，</p>
<pre><code>     3
    / \
   9   20
      /  \
     15   7
</code></pre>
<p>返回它的最大深度 3 。</p>
<p>思路一：自顶而下的思想<br>    从根节点开始，设深度为1，每下一层+1，下到最底层的时候选取两个子节点中层数多的那个+1作为最大深度(top_down(root))  </p>
<p>自己设计的伪代码如下：</p>
<pre><code>    top_down(root)&#123;
        if(root==null)&#123;
            return 0;
        &#125;
        depth=1
        if(depth.right!=null)&#123;
            depth+=1;
            top_down(depth.right)
        &#125;
        if(depth.left!=null)&#123;
            depth+=1;
            top_down(depth.left)
        &#125;
        return depth;
    &#125;
</code></pre>
<p>运行后发现问题：<br>问题一：<code>depth=1</code>这个设计还是陷在原来的非递归思维，这样设置的话每一次循环都会重置<code>depth</code>的值，所以不可行。正确的方法应该是不设置<code>depth</code>,而是利用一下代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每迭代一次+1就可以达到目的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> leftHeight = maxDepth(root.left);</span><br><span class="line">            <span class="keyword">int</span> rightHeight = maxDepth(root.right);</span><br><span class="line">            <span class="keyword">return</span> Math.max(leftHeight, rightHeight) + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">错误解法：</span></span><br><span class="line"><span class="comment">        int depth = 1;</span></span><br><span class="line"><span class="comment">        if(root.left != null)&#123;</span></span><br><span class="line"><span class="comment">            depth++;</span></span><br><span class="line"><span class="comment">            maxDepth(root.left);</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        if(root.right != null)&#123;</span></span><br><span class="line"><span class="comment">            depth++;</span></span><br><span class="line"><span class="comment">            maxDepth(root.right);</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        return depth;*/</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>小技巧</strong>：善用<code>math.max()</code>函数可以减少代码量，非常方便。</p>
<h3 id="★经典例题二：对称二叉树"><a href="#★经典例题二：对称二叉树" class="headerlink" title="★经典例题二：对称二叉树"></a>★经典例题二：对称二叉树</h3><p>给定一个二叉树，检查它是否是镜像对称的。</p>
<pre><code>    例如，二叉树[1,2,2,3,4,4,3] 是对称的。

    1
    / \
    2   2
    / \ / \
    3  4 4  3
    
    但是下面这个[1,2,2,null,3,null,3] 则不是镜像对称的:

      1
     / \
    2   2
     \   \
      3    3
    
    进阶：你可以运用递归和迭代两种方法解决这个问题吗？*/
</code></pre>
<h4 id="方法一：递归"><a href="#方法一：递归" class="headerlink" title="方法一：递归"></a>方法一：递归</h4><p>如果一个树的左子树与右子树镜像对称，那么这个树是对称的。<br>因此，该问题可以转化为：两个树在什么情况下互为镜像？</p>
<p>如果同时满足下面的条件，两个树互为镜像：</p>
<ol>
<li>它们的两个根结点具有相同的值</li>
<li>每个树的右子树都与另一个树的左子树镜像对称</li>
</ol>
<p>我们可以实现这样一个递归函数，通<em><strong>过「同步移动」两个指针的方法</strong></em>来遍历这棵树，p 指针和 q 指针一开始都指向这棵树的根，随后 p 右移时，q 左移，p 左移时，q 右移。每次检查当前 p 和 q 节点的值是否相等，如果相等再判断左右子树是否对称。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetric</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> check(root, root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">(TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span> &amp;&amp; q == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span> || q == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p.val == q.val &amp;&amp; check(p.left, q.right) &amp;&amp; check(p.right, q.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p>假设树上一共 nn 个节点。</p>
<ul>
<li>时间复杂度：这里遍历了这棵树，渐进时间复杂度为 O(n)。</li>
<li>空间复杂度：这里的空间复杂度和递归使用的栈空间有关，这里递归层数不超过 n，故渐进空间复杂度为 O(n)。</li>
</ul>
<h4 id="方法二：迭代"><a href="#方法二：迭代" class="headerlink" title="方法二：迭代"></a>方法二：迭代</h4><p>「方法一」中我们用递归的方法实现了对称性的判断，那么如何用迭代的方法实现呢？首先我们引入一个队列，这是把递归程序改写成迭代程序的常用方法。初始化时我们把根节点入队两次。每次提取两个结点并比较它们的值（队列中每两个连续的结点应该是相等的，而且它们的子树互为镜像），然后将两个结点的左右子结点按相反的顺序插入队列中。当队列为空时，或者我们检测到树不对称（即从队列中取出两个不相等的连续结点）时，该算法结束。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetric</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> check(root, root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">(TreeNode u, TreeNode v)</span> </span>&#123;</span><br><span class="line">        Queue&lt;TreeNode&gt; q = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        q.offer(u);</span><br><span class="line">        q.offer(v);</span><br><span class="line">        <span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">            u = q.poll();</span><br><span class="line">            v = q.poll();</span><br><span class="line">            <span class="keyword">if</span> (u == <span class="keyword">null</span> &amp;&amp; v == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ((u == <span class="keyword">null</span> || v == <span class="keyword">null</span>) || (u.val != v.val)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            q.offer(u.left);</span><br><span class="line">            q.offer(v.right);</span><br><span class="line"></span><br><span class="line">            q.offer(u.right);</span><br><span class="line">            q.offer(v.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：O(n)O(n)，同「方法一」。</li>
<li>空间复杂度：这里需要用一个队列来维护节点，每个节点最多进队一次，出队一次，队列中最多不会超过 nn 个点，故渐进空间复杂度为 O(n)O(n)。</li>
</ul>
<h4 id="方法三：递归2"><a href="#方法三：递归2" class="headerlink" title="方法三：递归2"></a>方法三：递归2</h4><ul>
<li>递归的方法是可以中途退出的。处理好各种情况的return顺序。</li>
<li><strong>终止条件</strong><ul>
<li>L.val=R.val ：即此两对称节点值相等。</li>
<li>L.left.val=R.right.val ：即 L 的 左子节点 和 R 的 右子节点 对称；</li>
<li><em>L</em>.right.val*=<em>R</em>.left*.val ：即 L 的 右子节点 和 R 的 左子节点 对称。</li>
</ul>
</li>
<li>特例处理：root == null，</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetric</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> root == <span class="keyword">null</span> || recursion(root.left, root.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">recursion</span><span class="params">(TreeNode l, TreeNode r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l == <span class="keyword">null</span> &amp; r == <span class="keyword">null</span>)<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (l == <span class="keyword">null</span> || r == <span class="keyword">null</span> || l.val !=r.val)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> recursion(l.left, r.right) &amp;&amp; recursion(l.right, r.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="★经典例题三：路径总和"><a href="#★经典例题三：路径总和" class="headerlink" title="★经典例题三：路径总和"></a>★经典例题三：路径总和</h3><p>给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。</p>
<pre><code>    说明:叶子节点是指没有子节点的节点。

    示例:
    给定如下二叉树，以及目标和 sum = 22，

             5
            / \
           4   8
          /   / \
        11  13   4
       /  \       \
       7    2      1
    返回 true, 因为存在目标和为 22 的根节点到叶子节点的路径 5-&gt;4-&gt;11-&gt;2。*/
</code></pre>
<p>解答：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPathSum</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sum -= root.val;</span><br><span class="line">        <span class="keyword">if</span>(sum == <span class="number">0</span> &amp;&amp; root.right == <span class="keyword">null</span> &amp;&amp; root.left == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> hasPathSum(root.left, sum) || hasPathSum(root.right, sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>做题总结</strong>：<br>一开始的时候思路是按前序遍历的思路做，和前序遍历不同的地方是这道题目每遍历一个节点都要把他从sum减掉，一开始的解决方法是想设一个标记之类的，但后来发现由于Java的值传递机制，根本不需要。 </p>
<p>细节一：sum减到零的时候要确保他是叶子节点，而不是中间节点才符合题意。</p>
<h3 id="★经典例题四：从中序与后序遍历序列构造二叉树"><a href="#★经典例题四：从中序与后序遍历序列构造二叉树" class="headerlink" title="★经典例题四：从中序与后序遍历序列构造二叉树"></a>★经典例题四：从中序与后序遍历序列构造二叉树</h3><pre><code>根据一棵树的中序遍历与后序遍历构造二叉树。

    注意:你可以假设树中没有重复的元素。

    例如，给出

    中序遍历 inorder =[9,3,15,20,7]
    后序遍历 postorder = [9,15,7,20,3]
    返回如下的二叉树：

     3
    / \
   9   20
      /  \
     15   7
</code></pre>
<p><strong>利用后序遍历和中序遍历的特点解题</strong>  </p>
<p>后续遍历的顺序是：左右中<br>中序遍历的顺序是：左中右</p>
<p>关键点1：后续遍历的最后一个元素为根结点<br>关键点2：找出根结点后可以在中序遍历中划分左右子树<br>关键点3：利用1、2点通过递归的方法解决问题</p>
<p><strong>自己的思考方向：</strong></p>
<ol>
<li><p>由于要经常查找根节点元素在中序遍历数组中的下标，数据结构应该用<code>hashtable</code>比较高效。</p>
</li>
<li><p>大概的递归流程：</p>
<pre><code> 后.last为根，获取index
 中.[0,index-1]为左子树
 中.[index+1,last]为右子树
</code></pre>
</li>
<li><p>遇到的问题及之后看答案求解：</p>
<ul>
<li>递归到叶子节点的情况做什么：创建节点，返回节点</li>
<li>如何连接节点：直接定义root.right和root.left</li>
<li>定义递归函数时，哪里是递归入口，传什么参数，返回什么类型的值：用index作为参数，返回节点类型的值。</li>
</ul>
</li>
</ol>
<p>Java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Hashtable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义全局变量，方便递归函数操作</span></span><br><span class="line">    <span class="keyword">int</span> post_idx;<span class="comment">// post_idx</span></span><br><span class="line">    <span class="keyword">int</span>[] postorder;</span><br><span class="line">    <span class="keyword">int</span>[] inorder;</span><br><span class="line">    Hashtable&lt;Integer, Integer&gt; table = <span class="keyword">new</span> Hashtable&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] inorder, <span class="keyword">int</span>[] postorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.inorder = inorder;</span><br><span class="line">        <span class="keyword">this</span>.postorder = postorder;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; inorder.length; i++) &#123;</span><br><span class="line">            table.put(inorder[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        post_idx = postorder.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> helper(<span class="number">0</span>, post_idx);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">helper</span><span class="params">(<span class="keyword">int</span> in_left, <span class="keyword">int</span> in_right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (in_left &gt; in_right) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 选择 post_idx 位置的元素作为当前子树根节点</span></span><br><span class="line">        <span class="keyword">int</span> root_val = postorder[post_idx];</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(root_val);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据 root 所在位置分成左右两棵子树</span></span><br><span class="line">        <span class="keyword">int</span> index = table.get(root_val);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 下标减一</span></span><br><span class="line">        post_idx--;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构建左右子树,理解这里参数in_right和in_left有难度</span></span><br><span class="line">        root.right = helper(index + <span class="number">1</span>, in_right);</span><br><span class="line">        root.left = helper(in_left, index - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> root;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>关于运用递归解决二叉树问题的一些总结</strong></p>
<ul>
<li>递归函数里的第一步都是判断是否递归到叶子节点的子节点，如果是就结束，但怎么判断这个是叶子节点的子节点要根据递归函数的参数来判断，比如这道题目，传的参数是数组的下标，那么根据左边不可能比右边大为条件写if条件</li>
<li>递归函数最后的返回值一般都是节点。</li>
<li>在递归的过程有一些变量是每次递归都需要的，可这些变量是一直不变的，可以用全局变量来达到目的，避免多次传参。还可以直接把要传进去的参数先用全局变量定义好，再在方法里面使用传进来的参数进行初始化。适用于方法里面要用到传参，可又不方便定义。比如这道题目，递归函数里不方便进行定义和引用，用传参的方法每次都要copy一样的值，花销应该会比较大，代码量也会增加。</li>
<li>这道题题还有一个注意点是左右子树的创建顺序是不能随意互换的，一定要先创建右子树，这是由于后序遍历的特点——“左右中”的顺序，我们根节点的选取是从最后面开始的，所以要先创建右子树。而下面的题目则正好相反。</li>
</ul>
<h3 id="★经典例题五：从前序与中序遍历序列构造二叉树"><a href="#★经典例题五：从前序与中序遍历序列构造二叉树" class="headerlink" title="★经典例题五：从前序与中序遍历序列构造二叉树"></a>★经典例题五：从前序与中序遍历序列构造二叉树</h3><pre><code>根据一棵树的前序遍历与中序遍历构造二叉树。

    注意:
    你可以假设树中没有重复的元素。

    例如，给出

    前序遍历 preorder = [3,9,20,15,7]
    中序遍历 inorder = [9,3,15,20,7]
    返回如下的二叉树：

     3
    / \
   9   20
      /  \
     15   7
</code></pre>
<p>Java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Hashtable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//定义全局变量</span></span><br><span class="line">    <span class="keyword">int</span> first_index;</span><br><span class="line">    <span class="keyword">int</span>[] preorder;</span><br><span class="line">    <span class="keyword">int</span>[] inorder;</span><br><span class="line">    Hashtable&lt;Integer, Integer&gt; idx_map = <span class="keyword">new</span> Hashtable&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.preorder = preorder;</span><br><span class="line">        <span class="keyword">this</span>.inorder = inorder;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; preorder.length; i++) &#123;</span><br><span class="line">            idx_map.put(inorder[i], i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        first_index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> helper(<span class="number">0</span>, inorder.length-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//递归函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">helper</span><span class="params">(<span class="keyword">int</span> in_left, <span class="keyword">int</span> in_right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(in_left &gt; in_right)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//分开左右子树</span></span><br><span class="line">        <span class="keyword">int</span> index = idx_map.get(preorder[first_index]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建根节点</span></span><br><span class="line">        <span class="keyword">int</span> root_val = preorder[first_index];</span><br><span class="line">        first_index++;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(root_val);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 理解这里参数in_right和in_left有难度,这两个参数分别保证在子树划分之后，左子树的最右边界，和右子树的最左边界在正确的位置</span></span><br><span class="line">        root.left = helper(in_left, index - <span class="number">1</span>);</span><br><span class="line">        root.right = helper(index + <span class="number">1</span>, in_right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这道题目的解法和上一道题目大同小异，只需要更改根结点的下标和左右子树的创建顺序就可以。</p>
<h3 id="例题六：填充每个节点的下一个右侧节点指针"><a href="#例题六：填充每个节点的下一个右侧节点指针" class="headerlink" title="例题六：填充每个节点的下一个右侧节点指针"></a>例题六：填充每个节点的下一个右侧节点指针</h3><pre><code>给定一个完美二叉树，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：

    struct Node &#123;
    int val;
    Node *left;
    Node *right;
    Node *next;
    &#125;
    填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。

    初始状态下，所有next 指针都被设置为 NULL。
</code></pre>
<h4 id="方法一：使用已建立的-next-指针"><a href="#方法一：使用已建立的-next-指针" class="headerlink" title="方法一：使用已建立的 next 指针"></a>方法一：使用已建立的 next 指针</h4><p><strong>思路</strong></p>
<p>一棵树中，存在两种类型的 next 指针。</p>
<p>1.第一种情况是连接同一个父节点的两个子节点。它们可以通过同一个节点直接访问到，因此执行下面操作即可完成连接。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node.left.next = node.right</span><br></pre></td></tr></table></figure>

<p>2.第二种情况在不同父亲的子节点之间建立连接，这种情况不能直接连接。</p>
<p>如果每个节点有指向父节点的指针，可以通过该指针找到 next 节点。如果不存在该指针，则按照下面思路建立连接：</p>
<blockquote>
<p>第 N 层节点之间建立 next 指针后，再建立第 N+1 层节点的 next 指针。可<br>以通过 next 指针访问同一层的所有节点，因此可以使用第 N 层的 next 指<br>针，为第 N+1 层节点建立 next 指针。</p>
</blockquote>
<p>算法</p>
<p>从根节点开始，由于第 00 层只有一个节点，所以不需要连接，直接为第 11 层节点建立 next 指针即可。该算法中需要注意的一点是，当我们为第 NN 层节点建立 next 指针时，处于第 N-1N−1 层。当第 NN 层节点的 next 指针全部建立完成后，移至第 NN 层，建立第 N+1N+1 层节点的 next 指针。</p>
<p>遍历某一层的节点时，这层节点的 next 指针已经建立。因此我们只需要知道这一层的最左节点，就可以按照链表方式遍历，不需要使用队列。</p>
<p>上面思路的伪代码如下：  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">leftmost = root</span><br><span class="line"><span class="keyword">while</span> (leftmost.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">    head = leftmost</span><br><span class="line">    <span class="keyword">while</span> (head.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="number">1</span>) Establish Connection <span class="number">1</span></span><br><span class="line">        <span class="number">2</span>) Establish Connection <span class="number">2</span> using next pointers</span><br><span class="line">        head = head.next</span><br><span class="line">    &#125;</span><br><span class="line">    leftmost = leftmost.left</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>Java代码如下:</p>
<p><strong>迭代做法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">connect</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 从根节点开始</span></span><br><span class="line">        Node leftmost = root;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (leftmost.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// ★遍历这一层节点组织成的链表，为下一层的节点更新 next 指针</span></span><br><span class="line">            <span class="comment">// 新建的head是用来做每一层的遍历，而原来的leftmost则用来控制换层</span></span><br><span class="line">            Node head = leftmost;</span><br><span class="line">            <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// CONNECTION 1</span></span><br><span class="line">                head.left.next = head.right;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// CONNECTION 2</span></span><br><span class="line">                <span class="keyword">if</span> (head.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    head.right.next = head.next.left;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 指针向后移动</span></span><br><span class="line">                head = head.next;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 去下一层的最左的节点</span></span><br><span class="line">            leftmost = leftmost.left;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>复杂度分析</p>
<ul>
<li><p>时间复杂度：O(N)，每个节点只访问一次。</p>
</li>
<li><p>空间复杂度：O(1)，不需要存储额外的节点。</p>
</li>
</ul>
<p><strong>自己的总结</strong></p>
<ul>
<li>迭代的方法解题，一般写法都是两个while循环嵌套</li>
<li>这道题有一个隐藏知识可以使用，创建对象时如果没有赋值，会默认进行赋值，可以看作最左侧的节点的next都是设定好了为null，只需要把剩下的节点弄好就可以</li>
<li>层序遍历只需要使用两个变量来控制，一个是从根节点不断转到下一层的最左边的节点，另一个则是最左节点的复制，用来做每一层的遍历。</li>
</ul>
<p><strong>递归做法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">connect</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            root.left.next = root.right;</span><br><span class="line">            root.right.next = root.next != <span class="keyword">null</span> ? root.next.left : <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">/*if (root.next != null) &#123;</span></span><br><span class="line"><span class="comment">                root.right.next = root.next.left;</span></span><br><span class="line"><span class="comment">            &#125; else &#123;</span></span><br><span class="line"><span class="comment">                root.right.next = null;</span></span><br><span class="line"><span class="comment">            &#125;*/</span></span><br><span class="line">            connect(root.left);</span><br><span class="line">            connect(root.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="例题七：填充每个节点的下一个右侧节点指针-II"><a href="#例题七：填充每个节点的下一个右侧节点指针-II" class="headerlink" title="例题七：填充每个节点的下一个右侧节点指针 II"></a>例题七：填充每个节点的下一个右侧节点指针 II</h3><p>给定一个二叉树</p>
<pre><code>    struct Node &#123;
        int val;
        Node *left;
        Node *right;
        Node *next;
    &#125;
    填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，
    则将 next 指针设置为 NULL。

    初始状态下，所有next 指针都被设置为 NULL。

    进阶：
        你只能使用常量级额外空间。
        使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。
</code></pre>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">connect</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Node leftmost = root;</span><br><span class="line">        <span class="keyword">while</span> (leftmost != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Node head = leftmost;</span><br><span class="line">            <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// connection1：head存在左右子树，左子树直接连接</span></span><br><span class="line">                <span class="keyword">if</span> (head.left != <span class="keyword">null</span> &amp;&amp; head.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    head.left.next = head.right;</span><br><span class="line">                    head.right = connectDifTree(head,head.right);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// connection2：head存在左子树，但不存在右子树</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(head.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    head.left = connectDifTree(head,head.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// connection3:head不存在左子树，存在右子树</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (head.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    head.right = connectDifTree(head, head.right);</span><br><span class="line">                &#125;</span><br><span class="line">                head = head.next;</span><br><span class="line">            &#125;</span><br><span class="line">            leftmost = fineLeftMost(leftmost);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">connectDifTree</span><span class="params">(Node head,Node child)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//非同父节点子树间的连接</span></span><br><span class="line">        Node tempN = head.next;</span><br><span class="line">        <span class="keyword">if</span> (tempN == <span class="keyword">null</span>) &#123;</span><br><span class="line">            child.next = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">return</span> child;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (tempN.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            child.next = tempN.left;</span><br><span class="line">            <span class="keyword">return</span> child;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tempN.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            child.next = tempN.right;</span><br><span class="line">            <span class="keyword">return</span> child;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> connectDifTree(head.next,child);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">fineLeftMost</span><span class="params">(Node l)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(l != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (l.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> l.left;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(l.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> l.right;</span><br><span class="line">            &#125;</span><br><span class="line">            l = l.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>个人总结</strong></p>
<ol>
<li>这一道题和上道题的思路和算法和上一道题很像，但这道题要复杂很多。依旧是使用层序遍历的思想来解题，但由于题中二叉树不是完全二叉树，子树的情况不可预测，需要比第一道题多很多的判断条件。</li>
<li>寻找一层当中的最左子树，即层序遍历的起点，要注意遍历该层的所有子树。</li>
<li>虽然比上道题复杂，但整体来说并不难，我在解题的过程由于受到上一道题目的定势思维影响，很多情况都没有考虑妥当，采用了和上一题一样的解法，导致做题花费时间非常多。这道题做完我最大的收获可能是“做题要顾整体而言”，就是做题的时候，要清楚整体的思路，不要在某个条件的判断里面陷进去，做题之前最好在脑海里面走一遍伪代码，写条件的时候要细心仔细，拿出测试软件的劲设想好所有会出现的情况，其中要留意哪几种情况可以合并，哪些情况可以简化。</li>
</ol>
<h3 id="例题八：填充每个节点的下一个右侧节点指针"><a href="#例题八：填充每个节点的下一个右侧节点指针" class="headerlink" title="例题八：填充每个节点的下一个右侧节点指针"></a>例题八：填充每个节点的下一个右侧节点指针</h3><pre><code>    给定一个完美二叉树，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：
    struct Node &#123;
        int val;
        Node *left;
        Node *right;
        Node *next;
    &#125;
    填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。

    初始状态下，所有next 指针都被设置为 NULL。
</code></pre>
<p><strong>递归解法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">connect</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            root.left.next = root.right;</span><br><span class="line">            root.right.next = root.next != <span class="keyword">null</span> ? root.next.left : <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">/*if (root.next != null) &#123;</span></span><br><span class="line"><span class="comment">                root.right.next = root.next.left;</span></span><br><span class="line"><span class="comment">            &#125; else &#123;</span></span><br><span class="line"><span class="comment">                root.right.next = null;</span></span><br><span class="line"><span class="comment">            &#125;*/</span></span><br><span class="line">            connect(root.left);</span><br><span class="line">            connect(root.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>迭代解法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">connect</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Node leftmost = root;</span><br><span class="line">        <span class="keyword">while</span> (leftmost != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Node head = leftmost;</span><br><span class="line">            <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// connection1：head存在左右子树，左子树直接连接</span></span><br><span class="line">                <span class="keyword">if</span> (head.left != <span class="keyword">null</span> &amp;&amp; head.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    head.left.next = head.right;</span><br><span class="line">                    head.right = connectDifTree(head,head.right);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// connection2：head存在左子树，但不存在右子树，左子树连接head.next的子树或者为null</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(head.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    head.left = connectDifTree(head,head.left);</span><br><span class="line">                &#125;</span><br><span class="line"><span class="comment">/*                else if(head.left!=null)&#123;</span></span><br><span class="line"><span class="comment">                    Node tempN = head.next;</span></span><br><span class="line"><span class="comment">                    if (tempN==null)&#123;</span></span><br><span class="line"><span class="comment">                        head.left.next = null;</span></span><br><span class="line"><span class="comment">                    &#125;else if (tempN.left!=null)&#123;</span></span><br><span class="line"><span class="comment">                        head.left.next = tempN.left;</span></span><br><span class="line"><span class="comment">                    &#125;else(tempN.right!=null)&#123;</span></span><br><span class="line"><span class="comment">                        head.left.next = tempN.right;</span></span><br><span class="line"><span class="comment">                    &#125;</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">                <span class="comment">// connection3:head不存在左子树，存在右子树</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (head.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    head.right = connectDifTree(head, head.right);</span><br><span class="line">                &#125;</span><br><span class="line"><span class="comment">/*                else (head.right!=null)&#123;</span></span><br><span class="line"><span class="comment">                    Node tempN1 = head.next;</span></span><br><span class="line"><span class="comment">                    if (tempN1==null)&#123;</span></span><br><span class="line"><span class="comment">                        head.right.next = null;</span></span><br><span class="line"><span class="comment">                    &#125;else if (tempN1.left!=null)&#123;</span></span><br><span class="line"><span class="comment">                        head.right.next = tempN1.left;</span></span><br><span class="line"><span class="comment">                    &#125;else(tempN1.right!=null)&#123;</span></span><br><span class="line"><span class="comment">                        head.right.next = tempN1.right;</span></span><br><span class="line"><span class="comment">                    &#125;</span></span><br><span class="line"><span class="comment">                &#125;*/</span></span><br><span class="line">                <span class="comment">// 尝试合并connection2和3</span></span><br><span class="line"><span class="comment">/*                else if (head.left!=null||head.right!=null)&#123;</span></span><br><span class="line"><span class="comment">                    Node temp;</span></span><br><span class="line"><span class="comment">                    if(head.left!=null)&#123;</span></span><br><span class="line"><span class="comment">                        temp=head.left;</span></span><br><span class="line"><span class="comment">                    &#125;else temp = head.right;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">                &#125;*/</span></span><br><span class="line">                head = head.next;</span><br><span class="line">            &#125;</span><br><span class="line">            leftmost = fineLeftMost(leftmost);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">connectDifTree</span><span class="params">(Node head,Node child)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//非同父节点子树间的连接</span></span><br><span class="line">        Node tempN = head.next;</span><br><span class="line">        <span class="keyword">if</span> (tempN == <span class="keyword">null</span>) &#123;</span><br><span class="line">            child.next = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">return</span> child;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (tempN.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            child.next = tempN.left;</span><br><span class="line">            <span class="keyword">return</span> child;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tempN.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            child.next = tempN.right;</span><br><span class="line">            <span class="keyword">return</span> child;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> connectDifTree(head.next,child);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">fineLeftMost</span><span class="params">(Node l)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(l != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (l.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> l.left;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(l.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> l.right;</span><br><span class="line">            &#125;</span><br><span class="line">            l = l.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://wenwenhuan.gitee.io/2020/10/13/%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="温文焕">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wenhuan Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/10/13/%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/" class="post-title-link" itemprop="url">替换空格</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-10-13 14:39:32" itemprop="dateCreated datePublished" datetime="2020-10-13T14:39:32+08:00">2020-10-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2021-05-17 11:10:06" itemprop="dateModified" datetime="2021-05-17T11:10:06+08:00">2021-05-17</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>请实现一个函数，把字符串 s 中的每个空格替换成”%20”。</p>
<pre><code>示例 1：

输入：s = &quot;We are happy.&quot;
输出：&quot;We%20are%20happy.&quot;

限制：    0 &lt;= s 的长度 &lt;= 10000
</code></pre>
<p><strong>解题思路：</strong> </p>
<ol>
<li>暴力方法，把输入的对象存到数组，遍历替换</li>
<li>利用String类的replace方法</li>
</ol>
<p><strong>Java 中的字符串是不变的，所以直接替换是不行的。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">replaceSpace</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 统计出字符串中空格的数目</span></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt; s.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) == <span class="string">&#x27; &#x27;</span>)&#123; <span class="comment">// charAt()方法用于返回指定索引处的字符</span></span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 新建一个字符数组，长度为原来字符串的长度+空格数⽬*2</span></span><br><span class="line">        <span class="keyword">char</span>[] ch = <span class="keyword">new</span> <span class="keyword">char</span>[s.length()+ count*<span class="number">2</span>];</span><br><span class="line">        <span class="comment">// 定义两个指针，分别指向原始字符串的末尾、替换之后的字符串的末尾</span></span><br><span class="line">        <span class="keyword">int</span> p1 = s.length() -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> p2 = ch.length -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (p1 &gt;=<span class="number">0</span> &amp;&amp; p2 &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">// 若碰到空格，把p1向前移动一格，在p2之前插入字符串“%20”，然后把p2向前移动三格</span></span><br><span class="line">            <span class="keyword">if</span> (s.charAt(p1) == <span class="string">&#x27; &#x27;</span>)&#123; </span><br><span class="line">                ch[p2] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                ch[p2-<span class="number">1</span>] = <span class="string">&#x27;2&#x27;</span>;</span><br><span class="line">                ch[p2-<span class="number">2</span>] = <span class="string">&#x27;%&#x27;</span>;</span><br><span class="line">                p1 -= <span class="number">1</span>;</span><br><span class="line">                p2 -= <span class="number">3</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 否则，逐个把p1指向的字符复制到P2指向的位置</span></span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                ch[p2] = s.charAt(p1);</span><br><span class="line">                p1 -= <span class="number">1</span>;</span><br><span class="line">                p2 -= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        char数组转成字符串的方法有两种：</span></span><br><span class="line"><span class="comment">            一种是直接将字符数组作为参数，通过new()构造String对象;</span></span><br><span class="line"><span class="comment">            另一种是使用String的valueOf()方法</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">// return new String(ch);</span></span><br><span class="line">        <span class="keyword">return</span> String.valueOf(ch);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol>
<li>接触了String的方法charAt()，用于返回指定索引处的字符</li>
<li>复习String的知识，Java 中的字符串是不变的，还有char数组转成字符串的两种方法  </li>
<li>双引号与单引号的区别，Java中，单引号(‘ ‘)引的是char类型；双引号（” “）引的是String类型。</li>
<li>获取字符串长度的是方法，带括号（<code>s.length()</code>），而数组则不用(<code>ch.length</code>)，一个是方法，一个是变量。</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://wenwenhuan.gitee.io/2020/10/13/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="温文焕">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wenhuan Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/10/13/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/" class="post-title-link" itemprop="url">二维数组的查找</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-10-13 11:42:32" itemprop="dateCreated datePublished" datetime="2020-10-13T11:42:32+08:00">2020-10-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2021-05-17 11:10:10" itemprop="dateModified" datetime="2021-05-17T11:10:10+08:00">2021-05-17</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>
<pre><code>    示例:

    现有矩阵 matrix 如下：

    [
    [1,   4,  7, 11, 15],
    [2,   5,  8, 12, 19],
    [3,   6,  9, 16, 22],
    [10, 13, 14, 17, 24],
    [18, 21, 23, 26, 30]
    ]
    给定 target = 5，返回 true。

    给定 target = 20，返回 false。

    限制：

    0 &lt;= n &lt;= 1000

    0 &lt;= m &lt;= 1000
</code></pre>
<p><strong>问题一</strong>：如何创建并初始化二维数组</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[][] matrix = &#123;&#123;<span class="number">1</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">15</span>&#125;,</span><br><span class="line">            &#123;<span class="number">2</span>,  <span class="number">5</span>, <span class="number">8</span>,  <span class="number">12</span>, <span class="number">19</span>&#125;,</span><br><span class="line">            &#123;<span class="number">3</span>,  <span class="number">6</span>, <span class="number">9</span>,  <span class="number">16</span>, <span class="number">22</span>&#125;,</span><br><span class="line">            &#123;<span class="number">10</span>,  <span class="number">13</span>, <span class="number">14</span>, <span class="number">17</span>, <span class="number">24</span>&#125;,</span><br><span class="line">            &#123;<span class="number">18</span>,  <span class="number">21</span>, <span class="number">23</span>, <span class="number">26</span>, <span class="number">30</span>&#125;&#125;;</span><br></pre></td></tr></table></figure>

<p>★利用有序性从数组右上方开始查询：只可以从左下角或者右上角开始！</p>
<ul>
<li>若数组为空，返回 false  </li>
<li> 初始化行下标为 0，列下标为二维数组的列数减 1</li>
<li>重复下列步骤，直到行下标或列下标超出边界  <ul>
<li> 获得当前下标位置的元素 num</li>
<li>如果 num 和 target 相等，返回 true</li>
<li>如果 num 大于 target，列下标减 1</li>
<li>如果 num 小于 target，行下标加 1</li>
</ul>
</li>
<li>循环体执行完毕仍未找到元素等于 target ，说明不存在这样的元素，返回 false</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> 二维数组中的查找;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] matrix = &#123;&#123;<span class="number">1</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">15</span>&#125;,</span><br><span class="line">                &#123;<span class="number">2</span>,  <span class="number">5</span>, <span class="number">8</span>,  <span class="number">12</span>, <span class="number">19</span>&#125;,</span><br><span class="line">                &#123;<span class="number">3</span>,  <span class="number">6</span>, <span class="number">9</span>,  <span class="number">16</span>, <span class="number">22</span>&#125;,</span><br><span class="line">                &#123;<span class="number">10</span>,  <span class="number">13</span>, <span class="number">14</span>, <span class="number">17</span>, <span class="number">24</span>&#125;,</span><br><span class="line">                &#123;<span class="number">18</span>,  <span class="number">21</span>, <span class="number">23</span>, <span class="number">26</span>, <span class="number">30</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">int</span> target = -<span class="number">5</span>;</span><br><span class="line">        System.out.println(findNumberIn2DArray(matrix,target));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">findNumberIn2DArray</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1、在使用数组前一定要判断数组是否为空</span></span><br><span class="line">        <span class="comment">//2、二维数组的判断方法特殊</span></span><br><span class="line">        <span class="keyword">if</span> (matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j = matrix[<span class="number">0</span>].length - <span class="number">1</span>;<span class="comment">// 如果传入数组为空时,会发生数组索引超出范围异常</span></span><br><span class="line">        <span class="keyword">while</span>(i &lt; matrix.length &amp;&amp; j &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(matrix[i][j] == target)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(matrix[i][j] &gt; target)&#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(matrix[i][j] &lt; target)&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>犯错一</strong>：忽略空数组的情况</p>
<p><strong>新问题一</strong>：如何判断二维数组为空</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>犯错二</strong>：当target在matrix[0][0]到[4][4]之间的时候可以用最长路径来划定最多比较次数，但当target超出matrix的范围时，这种做法会导致<code>ArrayIndexOutOfBoundsException</code>错误</p>
<p><strong>新问题二</strong>：如何限定比较的条件，避免ArrayIndexOutOfBoundsException错误</p>
<pre><code>使用while循环语句
</code></pre>
<p><strong>犯错三</strong>：没有考虑输入数组为{[-5]}的情况,这个二维数组只有一行一列，</p>
<p>解决办法：所有涉及数组长度的变量都用length方法获取得到。</p>
<p>获取行数： <code>int rowLength = array.length;</code></p>
<p>获取列数： <code>int colLength = array[0].length;</code></p>
<p><strong>犯错四</strong>：输入空数组时在<code>int j = matrix[0].length - 1</code>出现ArrayIndexOutOfBoundsException错误，二维数组实质上只是每个元素都为一个数组的一维数组，当要读取数组长度时应该先判断数组是否为空。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://wenwenhuan.gitee.io/2020/10/12/03_%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="温文焕">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wenhuan Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/10/12/03_%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/" class="post-title-link" itemprop="url">找出数组中重复的数字</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-10-12 17:29:32" itemprop="dateCreated datePublished" datetime="2020-10-12T17:29:32+08:00">2020-10-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2021-05-17 11:10:10" itemprop="dateModified" datetime="2021-05-17T11:10:10+08:00">2021-05-17</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。</p>
<p>示例 1</p>
<p>输入：<br>[2, 3, 1, 0, 2, 5, 3]<br>输出：2 或 3 
 </p>
<p>限制：<br>2 &lt;= n &lt;= 100000</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] nums = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">3</span>&#125;;</span><br><span class="line">        System.out.println(findRepeatNumber(nums));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findRepeatNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        Set set = <span class="keyword">new</span> HashSet&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">int</span> repeat = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!set.add(num))&#123;</span><br><span class="line">                repeat = num;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> repeat;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    第一次解题，超时！！</span></span><br><span class="line"><span class="comment">    public static int findRepeatNumber(int[] nums) &#123;</span></span><br><span class="line"><span class="comment">        Hashtable&lt;Integer, Integer&gt; table = new Hashtable&lt;Integer, Integer&gt;();</span></span><br><span class="line"><span class="comment">        for(int i = 0; i &lt; nums.length; i++)&#123;</span></span><br><span class="line"><span class="comment">            if(table.contains(nums[i]))&#123;</span></span><br><span class="line"><span class="comment">                return nums[i];</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            table.put(i, nums[i]);</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        throw new IllegalArgumentException(&quot;No Repeat Number&quot;);</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>问题一</strong>：为什么用Hashtable超时，而HasSet不会。</p>
<p>第一次解题超时并不是Hashtable的问题，使用Hashtable、HashMap都可以解题。超时的原因是&lt;key, value&gt;的设置，把数组里的元素设置成value就会发生超时，因为<code>contains(Object value)</code>的时间复杂度为O(n),而<code>containsKey(Object key) </code>的时间复杂度为O(1)</p>
<ul>
<li><code>contains(Object value)</code>：需要一个一个对比遍历</li>
<li><code>containsKey(Object key) </code>：计算key对应的地址，如果地址不为空则代表存在。</li>
</ul>
<p>综上，在建立字典的时候应该仔细考虑什么存为key，什么存为value。</p>
<p><strong>拓展</strong><br>HashSet源码几乎就是HashMap来做的，只是把元素存放在Key上，而完全没有用到map的Value，其他的所有操作都是几乎简单的调用了HashMap的。</p>
<p>他们俩都必须计算哈希码，但要考虑HashMap的键的性质-它通常是一个简单的String甚至是一个数字。而String和Integer的计算哈希码的速度比整个对象的默认哈希码计算要快得多</p>
<p>如果HashMap的键与存储在HashSet中的键是相同的对象，则性能将没有真正的区别。区别在于HashMap的键是哪种对象。</p>
<p><strong>新知识</strong>：Set类,HashSet类,foreach句式。</p>
<p><strong>面试注意点</strong>：它考察的是程序员的沟通能力，先问面试官要时间/空间需求！！！</p>
<p><strong>总结</strong>：解题利用了<code>HashSet</code>中不允许集合中有重复的值这个特点，依次把数组的元素加入集合中，当有重复的数字加入的时候，<code>add()</code>函数会返回false，这时候根据返回值可以判断是否为重复数字。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/5/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/7/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">温文焕</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  





  





</body>
</html>
