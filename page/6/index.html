<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"wenwenhuan.gitee.io","root":"/","images":"/images","scheme":"Gemini","darkmode":true,"version":"8.8.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>
<meta property="og:type" content="website">
<meta property="og:title" content="Wenhuan Blog">
<meta property="og:url" content="https://wenwenhuan.gitee.io/page/6/index.html">
<meta property="og:site_name" content="Wenhuan Blog">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="温文焕">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://wenwenhuan.gitee.io/page/6/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/6/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Wenhuan Blog</title>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Wenhuan Blog</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">即使天无雨 我亦留此地</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">温文焕</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">61</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://wenwenhuan.gitee.io/2020/10/17/springmvc%E4%B8%89%E4%B8%AA%E9%87%8D%E8%A6%81%E6%B3%A8%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="温文焕">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wenhuan Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/10/17/springmvc%E4%B8%89%E4%B8%AA%E9%87%8D%E8%A6%81%E6%B3%A8%E8%A7%A3/" class="post-title-link" itemprop="url">RequestMapping注解</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-10-17 10:00:00" itemprop="dateCreated datePublished" datetime="2020-10-17T10:00:00+08:00">2020-10-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2021-02-28 16:47:14" itemprop="dateModified" datetime="2021-02-28T16:47:14+08:00">2021-02-28</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="RequestMapping注解"><a href="#RequestMapping注解" class="headerlink" title="RequestMapping注解"></a>RequestMapping注解</h2><p><strong>作用：</strong> 用于建立请求URL和处理请求方法之间的对应关系。<br><strong>出现位置：</strong>  </p>
<ul>
<li><strong>类上：</strong><br>请求URL的第一级访问目录。此处不写的话，就相当于应用的根目录。写的话需要以/开头。 它出现的目的是为了使我们的URL可以按照模块化管理:  <ul>
<li>例如：<br>账户模块：  </li>
</ul>
</li>
</ul>
<p>*/account/*add<br>        */account/*update<br>        */account/*delete …<br>订单模块:<br> */order/*add<br>*/order/*update<br>*/order/*delete<br>*/…/*的部分就是把RequsetMappding写在类上，使我们的URL更加精细。  </p>
<ul>
<li><strong>方法上：</strong><br>请求URL的第二级访问目录。</li>
</ul>
<p><strong>属性：</strong>  </p>
<ul>
<li>value：用于指定请求的URL。它和path属性的作用是一样的。</li>
<li>method：用于指定请求的方式。(eg:get请求/post请求)</li>
<li>params：用于指定限制请求参数的条件。它支持简单的表达式。要求请求参数的key和value必须和配置的<strong>一模一样!!!</strong>  <ul>
<li>例如：<br>params = {“accountName”}，表示请求参数必须有accountName<br>params = {“moeny!100”}，表示请求参数中money不能是100。</li>
</ul>
</li>
<li>headers：用于指定限制请求消息头的条件。<br>注意： 以上四个属性只要出现2个或以上时，他们的关系是与的关系。</li>
</ul>
<p><strong>使用示例：</strong></p>
<ul>
<li>出现位置的示例：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*RequestMapping 注解出现的位置</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Controller(&quot;accountController&quot;)</span> <span class="meta">@RequestMapping(&quot;/account&quot;)</span><span class="comment">//RequestMapping作用于类上</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountController</span> </span>&#123;</span><br><span class="line"><span class="meta">@RequestMapping(&quot;/findAccount&quot;)</span><span class="comment">//RequestMapping作用于方法上</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">findAccount</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        System.out.println(<span class="string">&quot;查询了账户。。。。&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">jsp 中的代码：</span><br><span class="line">&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt;</span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;</span> <span class="meta-string">&quot;http://www.w3.org/TR/html4/loose.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;Content-Type&quot;</span> <span class="attr">content</span>=<span class="string">&quot;text/html; charset=UTF-8&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>requestmapping 的使用<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 第一种访问方式 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;$&#123;pageContext.request.contextPath&#125;/account/findAccount&quot;</span>&gt;</span>查询账户<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 第二种访问方式 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;account/findAccount&quot;</span>&gt;</span>查询账户<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line">注意：</span><br><span class="line">当我们使用此种方式配置时，在 jsp 中第二种写法时，不要在访问 URL 前面加/，否则无法找到资源。</span><br></pre></td></tr></table></figure>

<ul>
<li>method 属性的示例：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">控制器代码：</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*保存账户</span></span><br><span class="line"><span class="comment">*<span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@RequestMapping(value=&quot;/saveAccount&quot;,method=RequestMethod.POST)</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">saveAccount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;保存了账户&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">jsp 代码：</span><br><span class="line"><span class="comment">&lt;!-- 请求方式的示例 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;account/saveAccount&quot;</span>&gt;</span>保存账户，get 请求<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;account/saveAccount&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;保存账户，post 请求&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line">当使用 get 请求时，提示错误信息是 405，信息是方法不支持 get 方式请求</span><br></pre></td></tr></table></figure>

<ul>
<li>params 属性的示例：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">控制器的代码：</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*	删除账户</span></span><br><span class="line"><span class="comment">*	<span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@RequestMapping(value=&quot;/removeAccount&quot;,params= &#123;&quot;accountName&quot;,&quot;money&gt;100&quot;&#125;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">removeAccount</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        System.out.println(<span class="string">&quot;删除了账户&quot;</span>); </span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">jsp 中的代码：</span><br><span class="line"><span class="comment">&lt;!-- 请求参数的示例 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;account/removeAccount?accountName=aaa&amp;money&gt;100&quot;</span>&gt;</span>删除账户，金额 100<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;account/removeAccount?accountName=aaa&amp;money&gt;150&quot;</span>&gt;</span>删除账户，金额 150<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">注意：</span><br><span class="line">当我们点击第一个超链接时,可以访问成功。</span><br><span class="line">当我们点击第二个超链接时，提示错误信息是 400,无法访问。</span><br></pre></td></tr></table></figure>

<h2 id="RequestParam"><a href="#RequestParam" class="headerlink" title="RequestParam"></a>RequestParam</h2><p><strong>作用：</strong><br>把请求中指定名称的参数给控制器中的形参赋值。<br><strong>属性：</strong></p>
<ul>
<li>value：请求参数中的名称。</li>
<li>required：请求参数中是否必须提供此参数。默认值：true。表示必须提供，如果不提供将报错。  </li>
</ul>
<p><strong>使用示例：</strong></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">jsp 中的代码：</span><br><span class="line"><span class="comment">&lt;!-- requestParams 注解的使用 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;springmvc/useRequestParam?name=test&quot;</span>&gt;</span>requestParam 注解<span class="tag">&lt;/<span class="name">a</span>&gt;</span> </span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">控制器中的代码：</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*requestParams 注解的使用</span></span><br><span class="line"><span class="comment">*<span class="doctag">@param</span> username</span></span><br><span class="line"><span class="comment">*<span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/useRequestParam&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">useRequestParam</span><span class="params">(<span class="meta">@RequestParam(&quot;name&quot;)</span>String username,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="meta">@RequestParam(value=&quot;age&quot;,required=false)</span>Integer age)</span></span>&#123; </span><br><span class="line">        System.out.println(username+<span class="string">&quot;,&quot;</span>+age);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="RequestBody"><a href="#RequestBody" class="headerlink" title="RequestBody"></a>RequestBody</h2><p><strong>作用：</strong> 用于获取请求体内容。直接使用得到是 key=value&amp;key=value…结构的数据。get 请求方式不适用。<br><strong>属性：</strong>  </p>
<ul>
<li>required：是否必须有请求体。默认值是:true。当取值为 true 时,get 请求方式会报错。如果取值为 false，get 请求得到是 null。</li>
</ul>
<p><strong>使用示例：</strong></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">post 请求 jsp 代码：</span><br><span class="line"><span class="comment">&lt;!-- request body 注解 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;springmvc/useRequestBody&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">用户名称：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> &gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">用户密码：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> &gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">用户年龄：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> &gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;保存&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">get 请求 jsp 代码：（得到是空）</span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;springmvc/use</span></span></span><br><span class="line"><span class="tag"><span class="string">RequestBody?body=test&quot;</span>&gt;</span>requestBody 注解 get 请求<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">控制器代码：</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*RequestBody 注解</span></span><br><span class="line"><span class="comment">*<span class="doctag">@param</span> user</span></span><br><span class="line"><span class="comment">*<span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">*/</span> <span class="meta">@RequestMapping(&quot;/useRequestBody&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">useRequestBody</span><span class="params">(<span class="meta">@RequestBody(required=false)</span> String body)</span> </span>&#123; </span><br><span class="line">        System.out.println(body);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="PathVaribale"><a href="#PathVaribale" class="headerlink" title="PathVaribale"></a>PathVaribale</h2><p><strong>作用：</strong> 用于绑定 url 中的占位符。</p>
<ul>
<li>例如：请求 url 中 /delete/{id}，这个{id}就是 url 占位符。url 支持占位符是 spring3.0 之后加入的。是 springmvc 支持 rest 风格 URL 的一个重要标志。  </li>
</ul>
<p><strong>属性：</strong></p>
<ul>
<li>value：用于指定 url 中占位符名称。</li>
<li>required：是否必须提供占位符。</li>
</ul>
<p><strong>使用示例:</strong>  </p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">jsp 代码：</span><br><span class="line"><span class="comment">&lt;!-- PathVariable 注解 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;springmvc/usePathVariable/100&quot;</span>&gt;</span>pathVariable 注解<span class="tag">&lt;/<span class="name">a</span>&gt;</span> </span><br></pre></td></tr></table></figure>

<pre><code class="java">控制器代码：
/**
*PathVariable 注解
*@param user
* @return
*/ @RequestMapping(&quot;/usePathVariable/&#123;id&#125;&quot;)
public String    usePathVariable(@PathVariable(&quot;id&quot;) Integer id) &#123;
        System.out.println(id);
        return &quot;success&quot;;
&#125;
</code></pre>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://wenwenhuan.gitee.io/2020/10/16/Java%E7%9A%84%E5%80%BC%E4%BC%A0%E9%80%92%E6%9C%BA%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="温文焕">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wenhuan Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/10/16/Java%E7%9A%84%E5%80%BC%E4%BC%A0%E9%80%92%E6%9C%BA%E5%88%B6/" class="post-title-link" itemprop="url">Java的值传递机制</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-10-16 10:00:00" itemprop="dateCreated datePublished" datetime="2020-10-16T10:00:00+08:00">2020-10-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2021-04-26 11:36:14" itemprop="dateModified" datetime="2021-04-26T11:36:14+08:00">2021-04-26</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>和C语言一样，Java中也是采用“值传递”，即传递的是原参数的复印件，并不会影响原参数  </p>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>形参：方法声明时，方法小括号内的参数<br>实参：调用方法时，实际传入的参数的值</p>
<h2 id="规则：java中的参数传递机制：值传递机制"><a href="#规则：java中的参数传递机制：值传递机制" class="headerlink" title="规则：java中的参数传递机制：值传递机制"></a>规则：java中的参数传递机制：值传递机制</h2><ol>
<li>形参是基本数据类型的：将实参的值传递给形参的基本数据类型的变量</li>
<li>形参是引用数据类型的：将实参的引用类型变量的值（对应的堆空间的对象实体的首地址值）传递给形参的引用类型变量。</li>
</ol>
<p><strong>代码演示：</strong><br>基本类型的实例变量的传值机制</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Java的值传递问题;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义一个学生类，里面有基本类型引用类型的实例变量方便测试</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Stu</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> age = <span class="number">18</span>;</span><br><span class="line">        String name = <span class="string">&quot;wenhuan&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//构造一个changeAge方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">changeAge</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">        s = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//构造一个changeName方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">changeName</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        s = <span class="string">&quot;null&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Stu s = <span class="keyword">new</span> Stu();</span><br><span class="line">        <span class="comment">//调用changeAge方法来改变stu的age</span></span><br><span class="line">        System.out.println(<span class="string">&quot;尝试改变前的s的age：&quot;</span>+s.age);<span class="comment">//尝试改变前的s的age：18</span></span><br><span class="line">        changeAge(s.age);</span><br><span class="line">        System.out.println(<span class="string">&quot;尝试改变后的s的age：&quot;</span>+s.age);<span class="comment">//尝试改变后的s的age：18</span></span><br><span class="line">        <span class="comment">//age的值没有改变，猜想传入方法中的参数只是age的一个副本而不是age本身。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在main方法中直接更改age</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;尝试改变前的s的age：&quot;</span>+s.age);<span class="comment">//尝试改变前的s的age：18</span></span><br><span class="line"><span class="comment">//        changeAge(s.age);</span></span><br><span class="line">        s.age = <span class="number">0</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;尝试改变后的s的age：&quot;</span>+s.age);<span class="comment">//尝试改变后的s的age：0</span></span><br></pre></td></tr></table></figure>

<p>age发生了改变，证明是传入时出了问题，传的是副本。</p>
<p>引用类型的实例变量的传值机制</p>
<p>尝试将引用类型实例变量name当做参数传入方法，在方法内实例化一个新的对象并将该对象的地址传给参数,从而修改name的指向</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;尝试改变前的s的name：&quot;</span>+s.name);<span class="comment">//尝试改变前的s的name：wenhuan</span></span><br><span class="line">changeName(s.name);</span><br><span class="line">System.out.println(<span class="string">&quot;尝试改变后的s的name：&quot;</span>+s.name);<span class="comment">//尝试改变前的s的name：wenhuan</span></span><br></pre></td></tr></table></figure>

<p>发现name并没有改变，指向的仍旧是原来的那个对象，猜想传入方法的参数不是name本身而是name的一个副本（也就是地址的一个副本）。</p>
<p>在main方法中直接更改name</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;尝试改变前的s的name：&quot;</span>+s.name);<span class="comment">//尝试改变前的s的name：wenhuan</span></span><br><span class="line">s.name = <span class="string">&quot;null&quot;</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;尝试改变后的s的name：&quot;</span>+s.name);<span class="comment">//尝试改变前的s的name：null</span></span><br></pre></td></tr></table></figure>

<p>name发生了改变，证明是传入时出了问题，传的是地址的一个副本。</p>
<p><strong>总结</strong></p>
<p>　　以上所有操作只说明一个结果：Java中传参是值传递，<strong>传入方法的只是一个copy</strong>。传基本类型的变量时传的是数据的一个copy，传引用类型的变量时传的是地址的一个copy。此时注意引用类型的变量承载的只是对象的地址而不是对象本身!</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://wenwenhuan.gitee.io/2020/10/15/%E4%BA%8C%E5%8F%89%E6%A0%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="温文焕">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wenhuan Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/10/15/%E4%BA%8C%E5%8F%89%E6%A0%91/" class="post-title-link" itemprop="url">二叉树</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-10-15 12:07:32" itemprop="dateCreated datePublished" datetime="2020-10-15T12:07:32+08:00">2020-10-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2021-05-07 02:52:56" itemprop="dateModified" datetime="2021-05-07T02:52:56+08:00">2021-05-07</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>树是一种经常用到的数据结构，用来模拟具有树状结构性质的数据集合。</p>
<p>树里的每一个节点有一个值和一个包含所有子节点的列表。从图的观点来看，树也可视为一个拥有N 个节点和N-1 条边的一个有向无环图。</p>
<p>二叉树是一种更为典型的树状结构。如它名字所描述的那样，二叉树是每个节点最多有两个子树的树结构，通常子树被称作“左子树”和“右子树”。</p>
<p><strong>知识点：</strong>  </p>
<ol>
<li>树的节点结构</li>
<li>深度优先搜索（DFS）：树的前序遍历，中序遍历，后续遍历的解法<ul>
<li>递归</li>
<li>迭代</li>
</ul>
</li>
<li>层序顺序遍历（使用队列）</li>
<li>运用递归解决树的相关问题<ul>
<li>“自顶而下”和“自底而上”的解题思路</li>
<li>二叉树的最大深度</li>
<li>对称二叉树</li>
<li>路径总和</li>
</ul>
</li>
<li>总结</li>
</ol>
<h2 id="1-数的节点结构"><a href="#1-数的节点结构" class="headerlink" title="1. 数的节点结构"></a>1. 数的节点结构</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> data;  </span><br><span class="line">    <span class="keyword">private</span> Node leftNode;  </span><br><span class="line">    <span class="keyword">private</span> Node rightNode;  </span><br><span class="line"></span><br><span class="line">    TreeNode(<span class="keyword">int</span> val) &#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> data, Node leftNode, Node rightNode)</span></span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.data = data;  </span><br><span class="line">        <span class="keyword">this</span>.leftNode = leftNode;  </span><br><span class="line">        <span class="keyword">this</span>.rightNode = rightNode;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getData</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> data;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setData</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.data = data;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">getLeftNode</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> leftNode;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLeftNode</span><span class="params">(Node leftNode)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.leftNode = leftNode;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">getRightNode</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> rightNode;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRightNode</span><span class="params">(Node rightNode)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.rightNode = rightNode;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>创建二叉树的时候注意必须逆序建立，先建立子节点，再逆序往上建立，因为非叶子结点会使用到下面的节点，而初始化是按顺序初始化的，不逆序建立会报错 。</p>
<h2 id="2-树的前序遍历，中序遍历，后续遍历的解法"><a href="#2-树的前序遍历，中序遍历，后续遍历的解法" class="headerlink" title="2. 树的前序遍历，中序遍历，后续遍历的解法"></a>2. 树的前序遍历，中序遍历，后续遍历的解法</h2><p>树的前序遍历，中序遍历，后续遍历的解法有递归和迭代两种</p>
<h3 id="递归解法"><a href="#递归解法" class="headerlink" title="递归解法"></a>递归解法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">theFirstTraversal</span><span class="params">(Node root)</span> </span>&#123;  <span class="comment">//先序遍历  </span></span><br><span class="line">        printNode(root);  </span><br><span class="line">        <span class="keyword">if</span> (root.getLeftNode() != <span class="keyword">null</span>) &#123;  <span class="comment">//使用递归进行遍历左孩子  </span></span><br><span class="line">            theFirstTraversal(root.getLeftNode());  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">if</span> (root.getRightNode() != <span class="keyword">null</span>) &#123;  <span class="comment">//递归遍历右孩子  </span></span><br><span class="line">            theFirstTraversal(root.getRightNode());  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">theInOrderTraversal</span><span class="params">(Node root)</span> </span>&#123;  <span class="comment">//中序遍历  </span></span><br><span class="line">    <span class="keyword">if</span> (root.getLeftNode() != <span class="keyword">null</span>) &#123;  </span><br><span class="line">        theInOrderTraversal(root.getLeftNode());  </span><br><span class="line">    &#125;  </span><br><span class="line">    printNode(root);  </span><br><span class="line">    <span class="keyword">if</span> (root.getRightNode() != <span class="keyword">null</span>) &#123;  </span><br><span class="line">        theInOrderTraversal(root.getRightNode());  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">thePostOrderTraversal</span><span class="params">(Node root)</span> </span>&#123;  <span class="comment">//后序遍历  </span></span><br><span class="line">    <span class="keyword">if</span> (root.getLeftNode() != <span class="keyword">null</span>) &#123;  </span><br><span class="line">        thePostOrderTraversal(root.getLeftNode());  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">if</span>(root.getRightNode() != <span class="keyword">null</span>) &#123;  </span><br><span class="line">        thePostOrderTraversal(root.getRightNode());  </span><br><span class="line">    &#125;  </span><br><span class="line">    printNode(root);  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<h3 id="迭代解法"><a href="#迭代解法" class="headerlink" title="迭代解法"></a>迭代解法</h3><h4 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建两个链接列表对象，指定TreeNode类型的作为栈来使用，Integer类型的用作存储排好序的数据</span></span><br><span class="line">    LinkedList&lt;TreeNode&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    LinkedList&lt;Integer&gt; output = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="comment">//判断传进来的参数是否为空，空的话返回空链表</span></span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> output;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//把头节点存入栈</span></span><br><span class="line">    stack.add(root);</span><br><span class="line">    <span class="comment">//while循环的条件很关键，</span></span><br><span class="line">    <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">        <span class="comment">//设置一个临时变量Node,用于操作栈，把栈中的值存入output中，出栈，按先序遍历顺序入栈</span></span><br><span class="line">        TreeNode node = <span class="keyword">new</span> TreeNode();</span><br><span class="line">        <span class="comment">//pollLast方法在出栈的同时还可以返回出栈的元素，非常方便</span></span><br><span class="line">        node = stack.pollLast();</span><br><span class="line">        output.addLast(node.val);</span><br><span class="line">        <span class="comment">//判断节点是否为空很重要</span></span><br><span class="line">        <span class="keyword">if</span>(node.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">            stack.add(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(node.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">            stack.add(node.left);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> output;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结</strong><br>迭代是自己创建并操作一个栈，按照先序遍历的特点，要注意，根结点是个例外，提前入栈，while循环做的第一件事是出栈并记录出栈的val，<strong>然后是右子树入栈</strong>，最后是左子树入栈，然后左子树出栈，其右左子树分别入栈，左子树全部出栈后，右子树出栈，其右左子树分别入栈，以此类推。因为栈是一种先进后出的结构。</p>
<p>入栈的顺序需要注意，栈是先进后出的结构，我们需要先读左子树，所以左子树反而要后入栈。</p>
<h4 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建LinkedList对象stack用来作为栈使用，output用来存储按中序遍历排号顺序的元素</span></span><br><span class="line">        LinkedList&lt;TreeNode&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        LinkedList&lt;Integer&gt; output = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (root != <span class="keyword">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">                stack.add(root);</span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125;</span><br><span class="line">            root = stack.pollLast();</span><br><span class="line">            output.add(root.val);</span><br><span class="line">            root = root.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> output;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结</strong><br>中序遍历和前序遍历不一样，中序遍历是从根结点开始先遍历到最左边的子树，依次入栈，而后出栈，然后<code>root = root.right;</code>检查该节点是否有右节点，有的话按前边的步骤再走一遍。</p>
<p>做了两道迭代遍历之后，其实有一个难点十分相似——<strong>右子树的处理</strong>，前序遍历和中序遍历都有一个向左边不断走的趋向，区别是前序遍历是每到一个节点先遍历本身，而中序遍历是找到最左的子树才开始出栈。两者对右子树的处理不相同，中续遍历是左子树出栈后，立刻其检查右子树，而前序遍历是按右左的顺序依次入栈。这是由其自身的逻辑特点决定的，有一定难度。</p>
<h4 id="后续遍历"><a href="#后续遍历" class="headerlink" title="后续遍历"></a>后续遍历</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        TreeNode prev = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 循环开始的条件是root不为空，或者栈不为空，这点和中序遍历一样。</span></span><br><span class="line">        <span class="keyword">while</span> (root != <span class="keyword">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">                stack.push(root);</span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125;</span><br><span class="line">            root = stack.pop();</span><br><span class="line">            <span class="comment">// res入栈的条件很难理解，先决条件是最左的元素，然后要满足栈顶节点的右子树为空或者为之前遍历过的才可以入栈</span></span><br><span class="line">            <span class="comment">// 为空很容易理解，由左右中的顺序，右为空的话可以直接跳过，开始遍历根结点</span></span><br><span class="line">            <span class="comment">// 同理，之前遍历过了的话则直接遍历根结点。</span></span><br><span class="line">            <span class="keyword">if</span> (root.right == <span class="keyword">null</span> || root.right == prev) &#123;</span><br><span class="line">                <span class="comment">// res入栈之后立刻记录入栈的节点prev，置root为空，使得其不用执行寻找最右节点的步骤，</span></span><br><span class="line">                res.add(root.val);</span><br><span class="line">                prev = root;</span><br><span class="line">                root = <span class="keyword">null</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 不满足条件的节点重新入栈，并把root置为该节点的右节点，</span></span><br><span class="line">                <span class="comment">// 这时该节点不为空且未被遍历。</span></span><br><span class="line">                stack.push(root);</span><br><span class="line">                root = root.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>后序遍历的迭代做法是三种里面最难的一种，左右中里面“右”这个点很难处理，这里关联到了后面“中”的处理，最左边的子树很好找，和前面两种方法一样。但要注意的是，找到最左节点之后还需要确认其右节点是否为空，是否被遍历过，也就是在以该节点为根结点的子树里面“左右中”的顺序依然生效，但其变为了根结点。</p>
<p>综上所述，最关键还是右节点的处理，在一棵最简单的子树里面有四种遍历可能：①左右中、②右中、③左中、④中，如何识别和遍历？</p>
<p>方法：在找到最左节点的时候，根据右节点的情况，判断它是哪一种情况。右节点已经被遍历过了（需要记录上一个遍历的节点做对比）为情况①或②，右节点为空为情况③或④，这些情况都可以直接遍历该节点，如果不符合这两个条件的话，则右节点不为空且还没被遍历，需要把右节点入栈，进行遍历。</p>
<h2 id="3-层序顺序遍历"><a href="#3-层序顺序遍历" class="headerlink" title="3.层序顺序遍历"></a>3.层序顺序遍历</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Map&lt;Integer, TreeNode&gt; ancestor = <span class="keyword">new</span> Hashtable&lt;&gt;();</span><br><span class="line">    Set&lt;Integer&gt; p_ancestor = <span class="keyword">new</span> HashSet&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        preorderTraversal(root);</span><br><span class="line">        <span class="comment">// 寻找p的所有父节点,存入数组</span></span><br><span class="line">        <span class="comment">// LinkedList&lt;TreeNode&gt; p_ancestor = new LinkedList&lt;&gt;();</span></span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            p_ancestor.add(p.val);</span><br><span class="line">            p = ancestor.get(p.val);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 寻找q的祖先并和p的祖先对比，相同则结束，</span></span><br><span class="line">        <span class="keyword">while</span> (q!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (p_ancestor.contains(q.val)) <span class="keyword">return</span> q;</span><br><span class="line">            q = ancestor.get(q.val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用哈希表存储所有子树的父节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//while (root != null) &#123;</span></span><br><span class="line">            <span class="keyword">if</span> (root.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                ancestor.put(root.left.val, root);</span><br><span class="line">                preorderTraversal(root.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (root.right!=<span class="keyword">null</span>) &#123;</span><br><span class="line">                ancestor.put(root.right.val, root);</span><br><span class="line">                preorderTraversal(root.right);</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">//&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>层序遍历的思路是首先把所有节点的父节点都用哈希表记录下来，然后在里面把p的所有祖先找出来（包括p），再开始找q的祖先，当出现一样的节点，即找到。</p>
<p>Q1：哈希表的key和vale的类型</p>
<p>可以两个都选择TreeNode类型，也可以选择&lt;Integer, TreeNode&gt;的形式，这个关系到程序运行的开销。两个都选择TreeNode类型，程序运行开销比&lt;Integer, TreeNode&gt;的形式大，操作基本数据类型开销小。</p>
<p>Q2：寻找祖先节点的条件判断</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(p!=<span class="keyword">null</span>)&#123;</span><br><span class="line">    p_ancestor.add(p.val);</span><br><span class="line">    p = ancestor.get(p.val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>直接使用p！=null，<strong>不需要新建临时存储的数据，直接使用传进来的p引用</strong>，<strong>不需要使用<code>contains(key)</code>方法</strong>通过获取的值不存在时get()返回的null值作为结束的条件，减少代码量。</p>
<p>Q3：数据类型的选择</p>
<p>这个解法中，使用Hashtable类继承Map接口创建存储子节点和父节点一一对应的哈希表，使用Hashset类继承Set接口创建存储p节点所有祖先的集合。</p>
<h2 id="4-运用递归解决树的相关问题"><a href="#4-运用递归解决树的相关问题" class="headerlink" title="4.运用递归解决树的相关问题"></a>4.运用递归解决树的相关问题</h2><p>递归是解决树相关问题的最有效和最常用的方法之一，这里记录两种典型的递归方法。</p>
<p>树可以以递归的方式定义为一个节点（根节点），它包括一个值和一个指向其他节点指针的列表。 递归是树的特性之一。 因此，许多树问题可以通过递归的方式来解决。 对于每个递归层级，我们只能关注单个节点内的问题，并通过递归调用函数来解决其子节点问题。</p>
<h3 id="“自顶而下”和“自底而上”的解题思路"><a href="#“自顶而下”和“自底而上”的解题思路" class="headerlink" title="“自顶而下”和“自底而上”的解题思路"></a>“自顶而下”和“自底而上”的解题思路</h3><h4 id="Part1-“自顶向下”-的解决方案"><a href="#Part1-“自顶向下”-的解决方案" class="headerlink" title="Part1.“自顶向下” 的解决方案"></a>Part1.“自顶向下” 的解决方案</h4><p>“自顶向下” 意味着在每个递归层级，我们将首先访问节点来计算一些值，并在递归调用函数时将这些值传递到子节点。 所以 “自顶向下” 的解决方案可以被认为是一种前序遍历。 具体来说，递归函数 top_down(root, params) 的原理是这样的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="keyword">return</span> specific value <span class="keyword">for</span> <span class="keyword">null</span> node</span><br><span class="line"><span class="number">2.</span> update the answer <span class="keyword">if</span> needed                      <span class="comment">// anwer &lt;-- params</span></span><br><span class="line"><span class="number">3.</span> left_ans = top_down(root.left, left_params)		<span class="comment">// left_params &lt;-- root.val, params</span></span><br><span class="line"><span class="number">4.</span> right_ans = top_down(root.right, right_params)	<span class="comment">// right_params &lt;-- root.val, params</span></span><br><span class="line"><span class="number">5.</span> <span class="keyword">return</span> the answer <span class="keyword">if</span> needed                      <span class="comment">// answer &lt;-- left_ans, right_ans</span></span><br></pre></td></tr></table></figure>

<p>例如，思考这样一个问题：给定一个二叉树，请寻找它的最大深度。</p>
<p>我们知道根节点的深度是1。 <strong>对于每个节点，如果我们知道某节点的深度，那我们将知道它子节点的深度。 因此，在调用递归函数的时候，将节点的深度传递为一个参数，那么所有的节点都知道它们自身的深度。 而对于叶节点，我们可以通过更新深度从而获取最终答案。</strong> 这里是递归函数 maximum_depth(root, depth) 的伪代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="keyword">return</span> <span class="keyword">if</span> root is <span class="keyword">null</span></span><br><span class="line"><span class="number">2.</span> <span class="keyword">if</span> root is a leaf node:</span><br><span class="line"><span class="number">3.</span> 		answer = max(answer, depth)         <span class="comment">// update the answer if needed</span></span><br><span class="line"><span class="number">4.</span> maximum_depth(root.left, depth + <span class="number">1</span>)      <span class="comment">// call the function recursively for left child</span></span><br><span class="line"><span class="number">5.</span> maximum_depth(root.right, depth + <span class="number">1</span>)		<span class="comment">// call the function recursively for right child</span></span><br></pre></td></tr></table></figure>

<p>java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> answer;		<span class="comment">// don&#x27;t forget to initialize answer before call maximum_depth</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">maximum_depth</span><span class="params">(TreeNode root, <span class="keyword">int</span> depth)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">        answer = Math.max(answer, depth);</span><br><span class="line">    &#125;</span><br><span class="line">    maximum_depth(root.left, depth + <span class="number">1</span>);</span><br><span class="line">    maximum_depth(root.right, depth + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Part2-“自底向上”-的解决方案"><a href="#Part2-“自底向上”-的解决方案" class="headerlink" title="Part2.“自底向上” 的解决方案"></a>Part2.“自底向上” 的解决方案</h4><p>“自底向上” 是另一种递归方法。 <strong>在每个递归层次上，我们首先对所有子节点递归地调用函数，然后根据返回值和根节点本身的值得到答案。</strong> 这个过程可以看作是后序遍历的一种。 通常， “自底向上” 的递归函数 bottom_up(root) 为如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="keyword">return</span> specific value <span class="keyword">for</span> <span class="keyword">null</span> node</span><br><span class="line"><span class="number">2.</span> left_ans = bottom_up(root.left)			<span class="comment">// call function recursively for left child</span></span><br><span class="line"><span class="number">3.</span> right_ans = bottom_up(root.right)		<span class="comment">// call function recursively for right child</span></span><br><span class="line"><span class="number">4.</span> <span class="keyword">return</span> answers                           <span class="comment">// answer &lt;-- left_ans, right_ans, root.val</span></span><br></pre></td></tr></table></figure>

<p>继续讨论前面关于树的最大深度的问题，但是使用不同的思维方式：<strong>对于树的单个节点，以节点自身为根的子树的最大深度x是多少？</strong></p>
<p>如果我们知道一个根节点，以其左子节点为根的最大深度为l和以其右子节点为根的最大深度为r，我们是否可以回答前面的问题？ 当然可以，我们可以选择它们之间的最大值，再加上1来获得根节点所在的子树的最大深度。 那就是 x = max（l，r）+ 1。</p>
<p>这意味着对于每一个节点来说，我们都可以在解决它子节点的问题之后得到答案。 因此，我们可以使用“自底向上“的方法。下面是递归函数 maximum_depth(root) 的伪代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="keyword">return</span> <span class="number">0</span> <span class="keyword">if</span> root is <span class="keyword">null</span>                 <span class="comment">// return 0 for null node</span></span><br><span class="line"><span class="number">2.</span> left_depth = maximum_depth(root.left)</span><br><span class="line"><span class="number">3.</span> right_depth = maximum_depth(root.right)</span><br><span class="line"><span class="number">4.</span> <span class="keyword">return</span> max(left_depth, right_depth) + <span class="number">1</span>	<span class="comment">// return depth of the subtree rooted at root</span></span><br></pre></td></tr></table></figure>

<p>java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximum_depth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;                                   <span class="comment">// return 0 for null node</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> left_depth = maximum_depth(root.left);</span><br><span class="line">	<span class="keyword">int</span> right_depth = maximum_depth(root.right);</span><br><span class="line">	<span class="keyword">return</span> Math.max(left_depth, right_depth) + <span class="number">1</span>;	<span class="comment">// return depth of the subtree rooted at root</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结</strong><br>了解递归并利用递归解决问题并不容易。</p>
<p>当遇到树问题时，请先思考一下两个问题：</p>
<ol>
<li>你能确定一些参数，从该节点自身解决出发寻找答案吗？  </li>
<li>你可以<strong>使用这些参数和节点本身的值来决定什么应该是传递给它子节点的参数</strong>吗？<br>如果答案都是肯定的，那么请尝试使用 “自顶向下” 的递归来解决此问题。</li>
</ol>
<p>或者你可以这样思考：对于树中的任意一个节点，如果你知道它子节点的答案，你能计算出该节点的答案吗？ 如果答案是肯定的，那么 “自底向上” 的递归可能是一个不错的解决方法。</p>
<p>在接下来提供几个经典例题，以帮助你更好地理解树的结构和递归。</p>
<h3 id="经典例题一：二叉树的最大深度"><a href="#经典例题一：二叉树的最大深度" class="headerlink" title="经典例题一：二叉树的最大深度"></a>经典例题一：二叉树的最大深度</h3><p>给定一个二叉树，找出其最大深度。</p>
<p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p>
<p>说明: 叶子节点是指没有子节点的节点。</p>
<p>示例：<br>给定二叉树 [3,9,20,null,null,15,7]，</p>
<pre><code>     3
    / \
   9   20
      /  \
     15   7
</code></pre>
<p>返回它的最大深度 3 。</p>
<p>思路一：自顶而下的思想<br>    从根节点开始，设深度为1，每下一层+1，下到最底层的时候选取两个子节点中层数多的那个+1作为最大深度(top_down(root))  </p>
<p>自己设计的伪代码如下：</p>
<pre><code>    top_down(root)&#123;
        if(root==null)&#123;
            return 0;
        &#125;
        depth=1
        if(depth.right!=null)&#123;
            depth+=1;
            top_down(depth.right)
        &#125;
        if(depth.left!=null)&#123;
            depth+=1;
            top_down(depth.left)
        &#125;
        return depth;
    &#125;
</code></pre>
<p>运行后发现问题：<br>问题一：<code>depth=1</code>这个设计还是陷在原来的非递归思维，这样设置的话每一次循环都会重置<code>depth</code>的值，所以不可行。正确的方法应该是不设置<code>depth</code>,而是利用一下代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每迭代一次+1就可以达到目的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> leftHeight = maxDepth(root.left);</span><br><span class="line">            <span class="keyword">int</span> rightHeight = maxDepth(root.right);</span><br><span class="line">            <span class="keyword">return</span> Math.max(leftHeight, rightHeight) + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">错误解法：</span></span><br><span class="line"><span class="comment">        int depth = 1;</span></span><br><span class="line"><span class="comment">        if(root.left != null)&#123;</span></span><br><span class="line"><span class="comment">            depth++;</span></span><br><span class="line"><span class="comment">            maxDepth(root.left);</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        if(root.right != null)&#123;</span></span><br><span class="line"><span class="comment">            depth++;</span></span><br><span class="line"><span class="comment">            maxDepth(root.right);</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        return depth;*/</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>小技巧</strong>：善用<code>math.max()</code>函数可以减少代码量，非常方便。</p>
<h3 id="★经典例题二：对称二叉树"><a href="#★经典例题二：对称二叉树" class="headerlink" title="★经典例题二：对称二叉树"></a>★经典例题二：对称二叉树</h3><p>给定一个二叉树，检查它是否是镜像对称的。</p>
<pre><code>    例如，二叉树[1,2,2,3,4,4,3] 是对称的。

    1
    / \
    2   2
    / \ / \
    3  4 4  3
    
    但是下面这个[1,2,2,null,3,null,3] 则不是镜像对称的:

      1
     / \
    2   2
     \   \
      3    3
    
    进阶：你可以运用递归和迭代两种方法解决这个问题吗？*/
</code></pre>
<h4 id="方法一：递归"><a href="#方法一：递归" class="headerlink" title="方法一：递归"></a>方法一：递归</h4><p>如果一个树的左子树与右子树镜像对称，那么这个树是对称的。<br>因此，该问题可以转化为：两个树在什么情况下互为镜像？</p>
<p>如果同时满足下面的条件，两个树互为镜像：</p>
<ol>
<li>它们的两个根结点具有相同的值</li>
<li>每个树的右子树都与另一个树的左子树镜像对称</li>
</ol>
<p>我们可以实现这样一个递归函数，通<em><strong>过「同步移动」两个指针的方法</strong></em>来遍历这棵树，p 指针和 q 指针一开始都指向这棵树的根，随后 p 右移时，q 左移，p 左移时，q 右移。每次检查当前 p 和 q 节点的值是否相等，如果相等再判断左右子树是否对称。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetric</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> check(root, root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">(TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span> &amp;&amp; q == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span> || q == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p.val == q.val &amp;&amp; check(p.left, q.right) &amp;&amp; check(p.right, q.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p>假设树上一共 nn 个节点。</p>
<ul>
<li>时间复杂度：这里遍历了这棵树，渐进时间复杂度为 O(n)。</li>
<li>空间复杂度：这里的空间复杂度和递归使用的栈空间有关，这里递归层数不超过 n，故渐进空间复杂度为 O(n)。</li>
</ul>
<h4 id="方法二：迭代"><a href="#方法二：迭代" class="headerlink" title="方法二：迭代"></a>方法二：迭代</h4><p>「方法一」中我们用递归的方法实现了对称性的判断，那么如何用迭代的方法实现呢？首先我们引入一个队列，这是把递归程序改写成迭代程序的常用方法。初始化时我们把根节点入队两次。每次提取两个结点并比较它们的值（队列中每两个连续的结点应该是相等的，而且它们的子树互为镜像），然后将两个结点的左右子结点按相反的顺序插入队列中。当队列为空时，或者我们检测到树不对称（即从队列中取出两个不相等的连续结点）时，该算法结束。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetric</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> check(root, root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">(TreeNode u, TreeNode v)</span> </span>&#123;</span><br><span class="line">        Queue&lt;TreeNode&gt; q = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        q.offer(u);</span><br><span class="line">        q.offer(v);</span><br><span class="line">        <span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">            u = q.poll();</span><br><span class="line">            v = q.poll();</span><br><span class="line">            <span class="keyword">if</span> (u == <span class="keyword">null</span> &amp;&amp; v == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ((u == <span class="keyword">null</span> || v == <span class="keyword">null</span>) || (u.val != v.val)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            q.offer(u.left);</span><br><span class="line">            q.offer(v.right);</span><br><span class="line"></span><br><span class="line">            q.offer(u.right);</span><br><span class="line">            q.offer(v.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：O(n)O(n)，同「方法一」。</li>
<li>空间复杂度：这里需要用一个队列来维护节点，每个节点最多进队一次，出队一次，队列中最多不会超过 nn 个点，故渐进空间复杂度为 O(n)O(n)。</li>
</ul>
<h4 id="方法三：递归2"><a href="#方法三：递归2" class="headerlink" title="方法三：递归2"></a>方法三：递归2</h4><ul>
<li>递归的方法是可以中途退出的。处理好各种情况的return顺序。</li>
<li><strong>终止条件</strong><ul>
<li>L.val=R.val ：即此两对称节点值相等。</li>
<li>L.left.val=R.right.val ：即 L 的 左子节点 和 R 的 右子节点 对称；</li>
<li><em>L</em>.right.val*=<em>R</em>.left*.val ：即 L 的 右子节点 和 R 的 左子节点 对称。</li>
</ul>
</li>
<li>特例处理：root == null，</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetric</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> root == <span class="keyword">null</span> || recursion(root.left, root.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">recursion</span><span class="params">(TreeNode l, TreeNode r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l == <span class="keyword">null</span> &amp; r == <span class="keyword">null</span>)<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (l == <span class="keyword">null</span> || r == <span class="keyword">null</span> || l.val !=r.val)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> recursion(l.left, r.right) &amp;&amp; recursion(l.right, r.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="★经典例题三：路径总和"><a href="#★经典例题三：路径总和" class="headerlink" title="★经典例题三：路径总和"></a>★经典例题三：路径总和</h3><p>给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。</p>
<pre><code>    说明:叶子节点是指没有子节点的节点。

    示例:
    给定如下二叉树，以及目标和 sum = 22，

             5
            / \
           4   8
          /   / \
        11  13   4
       /  \       \
       7    2      1
    返回 true, 因为存在目标和为 22 的根节点到叶子节点的路径 5-&gt;4-&gt;11-&gt;2。*/
</code></pre>
<p>解答：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPathSum</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sum -= root.val;</span><br><span class="line">        <span class="keyword">if</span>(sum == <span class="number">0</span> &amp;&amp; root.right == <span class="keyword">null</span> &amp;&amp; root.left == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> hasPathSum(root.left, sum) || hasPathSum(root.right, sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>做题总结</strong>：<br>一开始的时候思路是按前序遍历的思路做，和前序遍历不同的地方是这道题目每遍历一个节点都要把他从sum减掉，一开始的解决方法是想设一个标记之类的，但后来发现由于Java的值传递机制，根本不需要。 </p>
<p>细节一：sum减到零的时候要确保他是叶子节点，而不是中间节点才符合题意。</p>
<h3 id="★经典例题四：从中序与后序遍历序列构造二叉树"><a href="#★经典例题四：从中序与后序遍历序列构造二叉树" class="headerlink" title="★经典例题四：从中序与后序遍历序列构造二叉树"></a>★经典例题四：从中序与后序遍历序列构造二叉树</h3><pre><code>根据一棵树的中序遍历与后序遍历构造二叉树。

    注意:你可以假设树中没有重复的元素。

    例如，给出

    中序遍历 inorder =[9,3,15,20,7]
    后序遍历 postorder = [9,15,7,20,3]
    返回如下的二叉树：

     3
    / \
   9   20
      /  \
     15   7
</code></pre>
<p><strong>利用后序遍历和中序遍历的特点解题</strong>  </p>
<p>后续遍历的顺序是：左右中<br>中序遍历的顺序是：左中右</p>
<p>关键点1：后续遍历的最后一个元素为根结点<br>关键点2：找出根结点后可以在中序遍历中划分左右子树<br>关键点3：利用1、2点通过递归的方法解决问题</p>
<p><strong>自己的思考方向：</strong></p>
<ol>
<li><p>由于要经常查找根节点元素在中序遍历数组中的下标，数据结构应该用<code>hashtable</code>比较高效。</p>
</li>
<li><p>大概的递归流程：</p>
<pre><code> 后.last为根，获取index
 中.[0,index-1]为左子树
 中.[index+1,last]为右子树
</code></pre>
</li>
<li><p>遇到的问题及之后看答案求解：</p>
<ul>
<li>递归到叶子节点的情况做什么：创建节点，返回节点</li>
<li>如何连接节点：直接定义root.right和root.left</li>
<li>定义递归函数时，哪里是递归入口，传什么参数，返回什么类型的值：用index作为参数，返回节点类型的值。</li>
</ul>
</li>
</ol>
<p>Java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Hashtable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义全局变量，方便递归函数操作</span></span><br><span class="line">    <span class="keyword">int</span> post_idx;<span class="comment">// post_idx</span></span><br><span class="line">    <span class="keyword">int</span>[] postorder;</span><br><span class="line">    <span class="keyword">int</span>[] inorder;</span><br><span class="line">    Hashtable&lt;Integer, Integer&gt; table = <span class="keyword">new</span> Hashtable&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] inorder, <span class="keyword">int</span>[] postorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.inorder = inorder;</span><br><span class="line">        <span class="keyword">this</span>.postorder = postorder;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; inorder.length; i++) &#123;</span><br><span class="line">            table.put(inorder[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        post_idx = postorder.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> helper(<span class="number">0</span>, post_idx);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">helper</span><span class="params">(<span class="keyword">int</span> in_left, <span class="keyword">int</span> in_right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (in_left &gt; in_right) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 选择 post_idx 位置的元素作为当前子树根节点</span></span><br><span class="line">        <span class="keyword">int</span> root_val = postorder[post_idx];</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(root_val);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据 root 所在位置分成左右两棵子树</span></span><br><span class="line">        <span class="keyword">int</span> index = table.get(root_val);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 下标减一</span></span><br><span class="line">        post_idx--;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构建左右子树,理解这里参数in_right和in_left有难度</span></span><br><span class="line">        root.right = helper(index + <span class="number">1</span>, in_right);</span><br><span class="line">        root.left = helper(in_left, index - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> root;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>关于运用递归解决二叉树问题的一些总结</strong></p>
<ul>
<li>递归函数里的第一步都是判断是否递归到叶子节点的子节点，如果是就结束，但怎么判断这个是叶子节点的子节点要根据递归函数的参数来判断，比如这道题目，传的参数是数组的下标，那么根据左边不可能比右边大为条件写if条件</li>
<li>递归函数最后的返回值一般都是节点。</li>
<li>在递归的过程有一些变量是每次递归都需要的，可这些变量是一直不变的，可以用全局变量来达到目的，避免多次传参。还可以直接把要传进去的参数先用全局变量定义好，再在方法里面使用传进来的参数进行初始化。适用于方法里面要用到传参，可又不方便定义。比如这道题目，递归函数里不方便进行定义和引用，用传参的方法每次都要copy一样的值，花销应该会比较大，代码量也会增加。</li>
<li>这道题题还有一个注意点是左右子树的创建顺序是不能随意互换的，一定要先创建右子树，这是由于后序遍历的特点——“左右中”的顺序，我们根节点的选取是从最后面开始的，所以要先创建右子树。而下面的题目则正好相反。</li>
</ul>
<h3 id="★经典例题五：从前序与中序遍历序列构造二叉树"><a href="#★经典例题五：从前序与中序遍历序列构造二叉树" class="headerlink" title="★经典例题五：从前序与中序遍历序列构造二叉树"></a>★经典例题五：从前序与中序遍历序列构造二叉树</h3><pre><code>根据一棵树的前序遍历与中序遍历构造二叉树。

    注意:
    你可以假设树中没有重复的元素。

    例如，给出

    前序遍历 preorder = [3,9,20,15,7]
    中序遍历 inorder = [9,3,15,20,7]
    返回如下的二叉树：

     3
    / \
   9   20
      /  \
     15   7
</code></pre>
<p>Java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Hashtable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//定义全局变量</span></span><br><span class="line">    <span class="keyword">int</span> first_index;</span><br><span class="line">    <span class="keyword">int</span>[] preorder;</span><br><span class="line">    <span class="keyword">int</span>[] inorder;</span><br><span class="line">    Hashtable&lt;Integer, Integer&gt; idx_map = <span class="keyword">new</span> Hashtable&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.preorder = preorder;</span><br><span class="line">        <span class="keyword">this</span>.inorder = inorder;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; preorder.length; i++) &#123;</span><br><span class="line">            idx_map.put(inorder[i], i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        first_index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> helper(<span class="number">0</span>, inorder.length-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//递归函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">helper</span><span class="params">(<span class="keyword">int</span> in_left, <span class="keyword">int</span> in_right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(in_left &gt; in_right)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//分开左右子树</span></span><br><span class="line">        <span class="keyword">int</span> index = idx_map.get(preorder[first_index]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建根节点</span></span><br><span class="line">        <span class="keyword">int</span> root_val = preorder[first_index];</span><br><span class="line">        first_index++;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(root_val);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 理解这里参数in_right和in_left有难度,这两个参数分别保证在子树划分之后，左子树的最右边界，和右子树的最左边界在正确的位置</span></span><br><span class="line">        root.left = helper(in_left, index - <span class="number">1</span>);</span><br><span class="line">        root.right = helper(index + <span class="number">1</span>, in_right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这道题目的解法和上一道题目大同小异，只需要更改根结点的下标和左右子树的创建顺序就可以。</p>
<h3 id="例题六：填充每个节点的下一个右侧节点指针"><a href="#例题六：填充每个节点的下一个右侧节点指针" class="headerlink" title="例题六：填充每个节点的下一个右侧节点指针"></a>例题六：填充每个节点的下一个右侧节点指针</h3><pre><code>给定一个完美二叉树，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：

    struct Node &#123;
    int val;
    Node *left;
    Node *right;
    Node *next;
    &#125;
    填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。

    初始状态下，所有next 指针都被设置为 NULL。
</code></pre>
<h4 id="方法一：使用已建立的-next-指针"><a href="#方法一：使用已建立的-next-指针" class="headerlink" title="方法一：使用已建立的 next 指针"></a>方法一：使用已建立的 next 指针</h4><p><strong>思路</strong></p>
<p>一棵树中，存在两种类型的 next 指针。</p>
<p>1.第一种情况是连接同一个父节点的两个子节点。它们可以通过同一个节点直接访问到，因此执行下面操作即可完成连接。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node.left.next = node.right</span><br></pre></td></tr></table></figure>

<p>2.第二种情况在不同父亲的子节点之间建立连接，这种情况不能直接连接。</p>
<p>如果每个节点有指向父节点的指针，可以通过该指针找到 next 节点。如果不存在该指针，则按照下面思路建立连接：</p>
<blockquote>
<p>第 N 层节点之间建立 next 指针后，再建立第 N+1 层节点的 next 指针。可<br>以通过 next 指针访问同一层的所有节点，因此可以使用第 N 层的 next 指<br>针，为第 N+1 层节点建立 next 指针。</p>
</blockquote>
<p>算法</p>
<p>从根节点开始，由于第 00 层只有一个节点，所以不需要连接，直接为第 11 层节点建立 next 指针即可。该算法中需要注意的一点是，当我们为第 NN 层节点建立 next 指针时，处于第 N-1N−1 层。当第 NN 层节点的 next 指针全部建立完成后，移至第 NN 层，建立第 N+1N+1 层节点的 next 指针。</p>
<p>遍历某一层的节点时，这层节点的 next 指针已经建立。因此我们只需要知道这一层的最左节点，就可以按照链表方式遍历，不需要使用队列。</p>
<p>上面思路的伪代码如下：  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">leftmost = root</span><br><span class="line"><span class="keyword">while</span> (leftmost.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">    head = leftmost</span><br><span class="line">    <span class="keyword">while</span> (head.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="number">1</span>) Establish Connection <span class="number">1</span></span><br><span class="line">        <span class="number">2</span>) Establish Connection <span class="number">2</span> using next pointers</span><br><span class="line">        head = head.next</span><br><span class="line">    &#125;</span><br><span class="line">    leftmost = leftmost.left</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>Java代码如下:</p>
<p><strong>迭代做法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">connect</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 从根节点开始</span></span><br><span class="line">        Node leftmost = root;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (leftmost.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// ★遍历这一层节点组织成的链表，为下一层的节点更新 next 指针</span></span><br><span class="line">            <span class="comment">// 新建的head是用来做每一层的遍历，而原来的leftmost则用来控制换层</span></span><br><span class="line">            Node head = leftmost;</span><br><span class="line">            <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// CONNECTION 1</span></span><br><span class="line">                head.left.next = head.right;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// CONNECTION 2</span></span><br><span class="line">                <span class="keyword">if</span> (head.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    head.right.next = head.next.left;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 指针向后移动</span></span><br><span class="line">                head = head.next;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 去下一层的最左的节点</span></span><br><span class="line">            leftmost = leftmost.left;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>复杂度分析</p>
<ul>
<li><p>时间复杂度：O(N)，每个节点只访问一次。</p>
</li>
<li><p>空间复杂度：O(1)，不需要存储额外的节点。</p>
</li>
</ul>
<p><strong>自己的总结</strong></p>
<ul>
<li>迭代的方法解题，一般写法都是两个while循环嵌套</li>
<li>这道题有一个隐藏知识可以使用，创建对象时如果没有赋值，会默认进行赋值，可以看作最左侧的节点的next都是设定好了为null，只需要把剩下的节点弄好就可以</li>
<li>层序遍历只需要使用两个变量来控制，一个是从根节点不断转到下一层的最左边的节点，另一个则是最左节点的复制，用来做每一层的遍历。</li>
</ul>
<p><strong>递归做法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">connect</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            root.left.next = root.right;</span><br><span class="line">            root.right.next = root.next != <span class="keyword">null</span> ? root.next.left : <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">/*if (root.next != null) &#123;</span></span><br><span class="line"><span class="comment">                root.right.next = root.next.left;</span></span><br><span class="line"><span class="comment">            &#125; else &#123;</span></span><br><span class="line"><span class="comment">                root.right.next = null;</span></span><br><span class="line"><span class="comment">            &#125;*/</span></span><br><span class="line">            connect(root.left);</span><br><span class="line">            connect(root.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="例题七：填充每个节点的下一个右侧节点指针-II"><a href="#例题七：填充每个节点的下一个右侧节点指针-II" class="headerlink" title="例题七：填充每个节点的下一个右侧节点指针 II"></a>例题七：填充每个节点的下一个右侧节点指针 II</h3><p>给定一个二叉树</p>
<pre><code>    struct Node &#123;
        int val;
        Node *left;
        Node *right;
        Node *next;
    &#125;
    填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，
    则将 next 指针设置为 NULL。

    初始状态下，所有next 指针都被设置为 NULL。

    进阶：
        你只能使用常量级额外空间。
        使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。
</code></pre>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">connect</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Node leftmost = root;</span><br><span class="line">        <span class="keyword">while</span> (leftmost != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Node head = leftmost;</span><br><span class="line">            <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// connection1：head存在左右子树，左子树直接连接</span></span><br><span class="line">                <span class="keyword">if</span> (head.left != <span class="keyword">null</span> &amp;&amp; head.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    head.left.next = head.right;</span><br><span class="line">                    head.right = connectDifTree(head,head.right);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// connection2：head存在左子树，但不存在右子树</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(head.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    head.left = connectDifTree(head,head.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// connection3:head不存在左子树，存在右子树</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (head.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    head.right = connectDifTree(head, head.right);</span><br><span class="line">                &#125;</span><br><span class="line">                head = head.next;</span><br><span class="line">            &#125;</span><br><span class="line">            leftmost = fineLeftMost(leftmost);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">connectDifTree</span><span class="params">(Node head,Node child)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//非同父节点子树间的连接</span></span><br><span class="line">        Node tempN = head.next;</span><br><span class="line">        <span class="keyword">if</span> (tempN == <span class="keyword">null</span>) &#123;</span><br><span class="line">            child.next = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">return</span> child;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (tempN.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            child.next = tempN.left;</span><br><span class="line">            <span class="keyword">return</span> child;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tempN.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            child.next = tempN.right;</span><br><span class="line">            <span class="keyword">return</span> child;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> connectDifTree(head.next,child);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">fineLeftMost</span><span class="params">(Node l)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(l != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (l.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> l.left;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(l.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> l.right;</span><br><span class="line">            &#125;</span><br><span class="line">            l = l.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>个人总结</strong></p>
<ol>
<li>这一道题和上道题的思路和算法和上一道题很像，但这道题要复杂很多。依旧是使用层序遍历的思想来解题，但由于题中二叉树不是完全二叉树，子树的情况不可预测，需要比第一道题多很多的判断条件。</li>
<li>寻找一层当中的最左子树，即层序遍历的起点，要注意遍历该层的所有子树。</li>
<li>虽然比上道题复杂，但整体来说并不难，我在解题的过程由于受到上一道题目的定势思维影响，很多情况都没有考虑妥当，采用了和上一题一样的解法，导致做题花费时间非常多。这道题做完我最大的收获可能是“做题要顾整体而言”，就是做题的时候，要清楚整体的思路，不要在某个条件的判断里面陷进去，做题之前最好在脑海里面走一遍伪代码，写条件的时候要细心仔细，拿出测试软件的劲设想好所有会出现的情况，其中要留意哪几种情况可以合并，哪些情况可以简化。</li>
</ol>
<h3 id="例题八：填充每个节点的下一个右侧节点指针"><a href="#例题八：填充每个节点的下一个右侧节点指针" class="headerlink" title="例题八：填充每个节点的下一个右侧节点指针"></a>例题八：填充每个节点的下一个右侧节点指针</h3><pre><code>    给定一个完美二叉树，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：
    struct Node &#123;
        int val;
        Node *left;
        Node *right;
        Node *next;
    &#125;
    填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。

    初始状态下，所有next 指针都被设置为 NULL。
</code></pre>
<p><strong>递归解法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">connect</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            root.left.next = root.right;</span><br><span class="line">            root.right.next = root.next != <span class="keyword">null</span> ? root.next.left : <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">/*if (root.next != null) &#123;</span></span><br><span class="line"><span class="comment">                root.right.next = root.next.left;</span></span><br><span class="line"><span class="comment">            &#125; else &#123;</span></span><br><span class="line"><span class="comment">                root.right.next = null;</span></span><br><span class="line"><span class="comment">            &#125;*/</span></span><br><span class="line">            connect(root.left);</span><br><span class="line">            connect(root.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>迭代解法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">connect</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Node leftmost = root;</span><br><span class="line">        <span class="keyword">while</span> (leftmost != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Node head = leftmost;</span><br><span class="line">            <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// connection1：head存在左右子树，左子树直接连接</span></span><br><span class="line">                <span class="keyword">if</span> (head.left != <span class="keyword">null</span> &amp;&amp; head.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    head.left.next = head.right;</span><br><span class="line">                    head.right = connectDifTree(head,head.right);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// connection2：head存在左子树，但不存在右子树，左子树连接head.next的子树或者为null</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(head.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    head.left = connectDifTree(head,head.left);</span><br><span class="line">                &#125;</span><br><span class="line"><span class="comment">/*                else if(head.left!=null)&#123;</span></span><br><span class="line"><span class="comment">                    Node tempN = head.next;</span></span><br><span class="line"><span class="comment">                    if (tempN==null)&#123;</span></span><br><span class="line"><span class="comment">                        head.left.next = null;</span></span><br><span class="line"><span class="comment">                    &#125;else if (tempN.left!=null)&#123;</span></span><br><span class="line"><span class="comment">                        head.left.next = tempN.left;</span></span><br><span class="line"><span class="comment">                    &#125;else(tempN.right!=null)&#123;</span></span><br><span class="line"><span class="comment">                        head.left.next = tempN.right;</span></span><br><span class="line"><span class="comment">                    &#125;</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">                <span class="comment">// connection3:head不存在左子树，存在右子树</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (head.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    head.right = connectDifTree(head, head.right);</span><br><span class="line">                &#125;</span><br><span class="line"><span class="comment">/*                else (head.right!=null)&#123;</span></span><br><span class="line"><span class="comment">                    Node tempN1 = head.next;</span></span><br><span class="line"><span class="comment">                    if (tempN1==null)&#123;</span></span><br><span class="line"><span class="comment">                        head.right.next = null;</span></span><br><span class="line"><span class="comment">                    &#125;else if (tempN1.left!=null)&#123;</span></span><br><span class="line"><span class="comment">                        head.right.next = tempN1.left;</span></span><br><span class="line"><span class="comment">                    &#125;else(tempN1.right!=null)&#123;</span></span><br><span class="line"><span class="comment">                        head.right.next = tempN1.right;</span></span><br><span class="line"><span class="comment">                    &#125;</span></span><br><span class="line"><span class="comment">                &#125;*/</span></span><br><span class="line">                <span class="comment">// 尝试合并connection2和3</span></span><br><span class="line"><span class="comment">/*                else if (head.left!=null||head.right!=null)&#123;</span></span><br><span class="line"><span class="comment">                    Node temp;</span></span><br><span class="line"><span class="comment">                    if(head.left!=null)&#123;</span></span><br><span class="line"><span class="comment">                        temp=head.left;</span></span><br><span class="line"><span class="comment">                    &#125;else temp = head.right;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">                &#125;*/</span></span><br><span class="line">                head = head.next;</span><br><span class="line">            &#125;</span><br><span class="line">            leftmost = fineLeftMost(leftmost);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">connectDifTree</span><span class="params">(Node head,Node child)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//非同父节点子树间的连接</span></span><br><span class="line">        Node tempN = head.next;</span><br><span class="line">        <span class="keyword">if</span> (tempN == <span class="keyword">null</span>) &#123;</span><br><span class="line">            child.next = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">return</span> child;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (tempN.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            child.next = tempN.left;</span><br><span class="line">            <span class="keyword">return</span> child;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tempN.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            child.next = tempN.right;</span><br><span class="line">            <span class="keyword">return</span> child;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> connectDifTree(head.next,child);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">fineLeftMost</span><span class="params">(Node l)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(l != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (l.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> l.left;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(l.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> l.right;</span><br><span class="line">            &#125;</span><br><span class="line">            l = l.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://wenwenhuan.gitee.io/2020/10/13/%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="温文焕">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wenhuan Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/10/13/%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/" class="post-title-link" itemprop="url">替换空格</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-10-13 14:39:32" itemprop="dateCreated datePublished" datetime="2020-10-13T14:39:32+08:00">2020-10-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2021-05-17 11:10:06" itemprop="dateModified" datetime="2021-05-17T11:10:06+08:00">2021-05-17</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>请实现一个函数，把字符串 s 中的每个空格替换成”%20”。</p>
<pre><code>示例 1：

输入：s = &quot;We are happy.&quot;
输出：&quot;We%20are%20happy.&quot;

限制：    0 &lt;= s 的长度 &lt;= 10000
</code></pre>
<p><strong>解题思路：</strong> </p>
<ol>
<li>暴力方法，把输入的对象存到数组，遍历替换</li>
<li>利用String类的replace方法</li>
</ol>
<p><strong>Java 中的字符串是不变的，所以直接替换是不行的。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">replaceSpace</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 统计出字符串中空格的数目</span></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt; s.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) == <span class="string">&#x27; &#x27;</span>)&#123; <span class="comment">// charAt()方法用于返回指定索引处的字符</span></span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 新建一个字符数组，长度为原来字符串的长度+空格数⽬*2</span></span><br><span class="line">        <span class="keyword">char</span>[] ch = <span class="keyword">new</span> <span class="keyword">char</span>[s.length()+ count*<span class="number">2</span>];</span><br><span class="line">        <span class="comment">// 定义两个指针，分别指向原始字符串的末尾、替换之后的字符串的末尾</span></span><br><span class="line">        <span class="keyword">int</span> p1 = s.length() -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> p2 = ch.length -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (p1 &gt;=<span class="number">0</span> &amp;&amp; p2 &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">// 若碰到空格，把p1向前移动一格，在p2之前插入字符串“%20”，然后把p2向前移动三格</span></span><br><span class="line">            <span class="keyword">if</span> (s.charAt(p1) == <span class="string">&#x27; &#x27;</span>)&#123; </span><br><span class="line">                ch[p2] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                ch[p2-<span class="number">1</span>] = <span class="string">&#x27;2&#x27;</span>;</span><br><span class="line">                ch[p2-<span class="number">2</span>] = <span class="string">&#x27;%&#x27;</span>;</span><br><span class="line">                p1 -= <span class="number">1</span>;</span><br><span class="line">                p2 -= <span class="number">3</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 否则，逐个把p1指向的字符复制到P2指向的位置</span></span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                ch[p2] = s.charAt(p1);</span><br><span class="line">                p1 -= <span class="number">1</span>;</span><br><span class="line">                p2 -= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        char数组转成字符串的方法有两种：</span></span><br><span class="line"><span class="comment">            一种是直接将字符数组作为参数，通过new()构造String对象;</span></span><br><span class="line"><span class="comment">            另一种是使用String的valueOf()方法</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">// return new String(ch);</span></span><br><span class="line">        <span class="keyword">return</span> String.valueOf(ch);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol>
<li>接触了String的方法charAt()，用于返回指定索引处的字符</li>
<li>复习String的知识，Java 中的字符串是不变的，还有char数组转成字符串的两种方法  </li>
<li>双引号与单引号的区别，Java中，单引号(‘ ‘)引的是char类型；双引号（” “）引的是String类型。</li>
<li>获取字符串长度的是方法，带括号（<code>s.length()</code>），而数组则不用(<code>ch.length</code>)，一个是方法，一个是变量。</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://wenwenhuan.gitee.io/2020/10/13/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="温文焕">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wenhuan Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/10/13/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/" class="post-title-link" itemprop="url">二维数组的查找</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-10-13 11:42:32" itemprop="dateCreated datePublished" datetime="2020-10-13T11:42:32+08:00">2020-10-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2021-05-17 11:10:10" itemprop="dateModified" datetime="2021-05-17T11:10:10+08:00">2021-05-17</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>
<pre><code>    示例:

    现有矩阵 matrix 如下：

    [
    [1,   4,  7, 11, 15],
    [2,   5,  8, 12, 19],
    [3,   6,  9, 16, 22],
    [10, 13, 14, 17, 24],
    [18, 21, 23, 26, 30]
    ]
    给定 target = 5，返回 true。

    给定 target = 20，返回 false。

    限制：

    0 &lt;= n &lt;= 1000

    0 &lt;= m &lt;= 1000
</code></pre>
<p><strong>问题一</strong>：如何创建并初始化二维数组</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[][] matrix = &#123;&#123;<span class="number">1</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">15</span>&#125;,</span><br><span class="line">            &#123;<span class="number">2</span>,  <span class="number">5</span>, <span class="number">8</span>,  <span class="number">12</span>, <span class="number">19</span>&#125;,</span><br><span class="line">            &#123;<span class="number">3</span>,  <span class="number">6</span>, <span class="number">9</span>,  <span class="number">16</span>, <span class="number">22</span>&#125;,</span><br><span class="line">            &#123;<span class="number">10</span>,  <span class="number">13</span>, <span class="number">14</span>, <span class="number">17</span>, <span class="number">24</span>&#125;,</span><br><span class="line">            &#123;<span class="number">18</span>,  <span class="number">21</span>, <span class="number">23</span>, <span class="number">26</span>, <span class="number">30</span>&#125;&#125;;</span><br></pre></td></tr></table></figure>

<p>★利用有序性从数组右上方开始查询：只可以从左下角或者右上角开始！</p>
<ul>
<li>若数组为空，返回 false  </li>
<li> 初始化行下标为 0，列下标为二维数组的列数减 1</li>
<li>重复下列步骤，直到行下标或列下标超出边界  <ul>
<li> 获得当前下标位置的元素 num</li>
<li>如果 num 和 target 相等，返回 true</li>
<li>如果 num 大于 target，列下标减 1</li>
<li>如果 num 小于 target，行下标加 1</li>
</ul>
</li>
<li>循环体执行完毕仍未找到元素等于 target ，说明不存在这样的元素，返回 false</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> 二维数组中的查找;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] matrix = &#123;&#123;<span class="number">1</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">15</span>&#125;,</span><br><span class="line">                &#123;<span class="number">2</span>,  <span class="number">5</span>, <span class="number">8</span>,  <span class="number">12</span>, <span class="number">19</span>&#125;,</span><br><span class="line">                &#123;<span class="number">3</span>,  <span class="number">6</span>, <span class="number">9</span>,  <span class="number">16</span>, <span class="number">22</span>&#125;,</span><br><span class="line">                &#123;<span class="number">10</span>,  <span class="number">13</span>, <span class="number">14</span>, <span class="number">17</span>, <span class="number">24</span>&#125;,</span><br><span class="line">                &#123;<span class="number">18</span>,  <span class="number">21</span>, <span class="number">23</span>, <span class="number">26</span>, <span class="number">30</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">int</span> target = -<span class="number">5</span>;</span><br><span class="line">        System.out.println(findNumberIn2DArray(matrix,target));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">findNumberIn2DArray</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1、在使用数组前一定要判断数组是否为空</span></span><br><span class="line">        <span class="comment">//2、二维数组的判断方法特殊</span></span><br><span class="line">        <span class="keyword">if</span> (matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j = matrix[<span class="number">0</span>].length - <span class="number">1</span>;<span class="comment">// 如果传入数组为空时,会发生数组索引超出范围异常</span></span><br><span class="line">        <span class="keyword">while</span>(i &lt; matrix.length &amp;&amp; j &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(matrix[i][j] == target)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(matrix[i][j] &gt; target)&#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(matrix[i][j] &lt; target)&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>犯错一</strong>：忽略空数组的情况</p>
<p><strong>新问题一</strong>：如何判断二维数组为空</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>犯错二</strong>：当target在matrix[0][0]到[4][4]之间的时候可以用最长路径来划定最多比较次数，但当target超出matrix的范围时，这种做法会导致<code>ArrayIndexOutOfBoundsException</code>错误</p>
<p><strong>新问题二</strong>：如何限定比较的条件，避免ArrayIndexOutOfBoundsException错误</p>
<pre><code>使用while循环语句
</code></pre>
<p><strong>犯错三</strong>：没有考虑输入数组为{[-5]}的情况,这个二维数组只有一行一列，</p>
<p>解决办法：所有涉及数组长度的变量都用length方法获取得到。</p>
<p>获取行数： <code>int rowLength = array.length;</code></p>
<p>获取列数： <code>int colLength = array[0].length;</code></p>
<p><strong>犯错四</strong>：输入空数组时在<code>int j = matrix[0].length - 1</code>出现ArrayIndexOutOfBoundsException错误，二维数组实质上只是每个元素都为一个数组的一维数组，当要读取数组长度时应该先判断数组是否为空。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://wenwenhuan.gitee.io/2020/10/12/03_%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="温文焕">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wenhuan Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/10/12/03_%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/" class="post-title-link" itemprop="url">找出数组中重复的数字</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-10-12 17:29:32" itemprop="dateCreated datePublished" datetime="2020-10-12T17:29:32+08:00">2020-10-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2021-05-17 11:10:10" itemprop="dateModified" datetime="2021-05-17T11:10:10+08:00">2021-05-17</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。</p>
<p>示例 1</p>
<p>输入：<br>[2, 3, 1, 0, 2, 5, 3]<br>输出：2 或 3 
 </p>
<p>限制：<br>2 &lt;= n &lt;= 100000</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] nums = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">3</span>&#125;;</span><br><span class="line">        System.out.println(findRepeatNumber(nums));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findRepeatNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        Set set = <span class="keyword">new</span> HashSet&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">int</span> repeat = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!set.add(num))&#123;</span><br><span class="line">                repeat = num;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> repeat;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    第一次解题，超时！！</span></span><br><span class="line"><span class="comment">    public static int findRepeatNumber(int[] nums) &#123;</span></span><br><span class="line"><span class="comment">        Hashtable&lt;Integer, Integer&gt; table = new Hashtable&lt;Integer, Integer&gt;();</span></span><br><span class="line"><span class="comment">        for(int i = 0; i &lt; nums.length; i++)&#123;</span></span><br><span class="line"><span class="comment">            if(table.contains(nums[i]))&#123;</span></span><br><span class="line"><span class="comment">                return nums[i];</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            table.put(i, nums[i]);</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        throw new IllegalArgumentException(&quot;No Repeat Number&quot;);</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>问题一</strong>：为什么用Hashtable超时，而HasSet不会。</p>
<p>第一次解题超时并不是Hashtable的问题，使用Hashtable、HashMap都可以解题。超时的原因是&lt;key, value&gt;的设置，把数组里的元素设置成value就会发生超时，因为<code>contains(Object value)</code>的时间复杂度为O(n),而<code>containsKey(Object key) </code>的时间复杂度为O(1)</p>
<ul>
<li><code>contains(Object value)</code>：需要一个一个对比遍历</li>
<li><code>containsKey(Object key) </code>：计算key对应的地址，如果地址不为空则代表存在。</li>
</ul>
<p>综上，在建立字典的时候应该仔细考虑什么存为key，什么存为value。</p>
<p><strong>拓展</strong><br>HashSet源码几乎就是HashMap来做的，只是把元素存放在Key上，而完全没有用到map的Value，其他的所有操作都是几乎简单的调用了HashMap的。</p>
<p>他们俩都必须计算哈希码，但要考虑HashMap的键的性质-它通常是一个简单的String甚至是一个数字。而String和Integer的计算哈希码的速度比整个对象的默认哈希码计算要快得多</p>
<p>如果HashMap的键与存储在HashSet中的键是相同的对象，则性能将没有真正的区别。区别在于HashMap的键是哪种对象。</p>
<p><strong>新知识</strong>：Set类,HashSet类,foreach句式。</p>
<p><strong>面试注意点</strong>：它考察的是程序员的沟通能力，先问面试官要时间/空间需求！！！</p>
<p><strong>总结</strong>：解题利用了<code>HashSet</code>中不允许集合中有重复的值这个特点，依次把数组的元素加入集合中，当有重复的数字加入的时候，<code>add()</code>函数会返回false，这时候根据返回值可以判断是否为重复数字。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://wenwenhuan.gitee.io/2020/10/12/java%E4%B8%AD%E7%9A%84HashTable,HashMap%E5%92%8CHashSet/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="温文焕">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wenhuan Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/10/12/java%E4%B8%AD%E7%9A%84HashTable,HashMap%E5%92%8CHashSet/" class="post-title-link" itemprop="url">java中的HashTable,HashMap和HashSet</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-10-12 17:29:32" itemprop="dateCreated datePublished" datetime="2020-10-12T17:29:32+08:00">2020-10-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2021-05-17 11:09:04" itemprop="dateModified" datetime="2021-05-17T11:09:04+08:00">2021-05-17</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="HashTable和HashMap的区别"><a href="#HashTable和HashMap的区别" class="headerlink" title="HashTable和HashMap的区别"></a>HashTable和HashMap的区别</h2><p><code> HashMap</code>和<code>Hashtable</code>都实现了Map接口，但决定用哪一个之前先要弄清楚它们之间的分别。<strong>主要的区别有：线程安全性，同步(synchronization)，以及速度。</strong></p>
<h3 id="线程安全性，同步"><a href="#线程安全性，同步" class="headerlink" title="线程安全性，同步"></a>线程安全性，同步</h3><p><code>HashMap</code>几乎可以等价于<code>Hashtable</code>，除了<code>HashMap</code>是<strong>非synchronized的</strong>，并<strong>可以接受null</strong>(HashMap allows one null key and any number of null values.，而Hashtable则不行)。这就是说，<code>HashMap</code>中如果在表中没有发现搜索键，或者如果发现了搜索键，但它是一个空的值，那么get()将返回null。如果有必要，<em>用containKey()方法来区别这两种情况。</em></p>
<p><strong><code>HashMap</code>是非synchronized，而<code>Hashtable</code>是synchronized</strong>，这意味着<strong>Hashtable是线程安全的，多个线程可以共享一个Hashtable</strong>；而如果没有正确的同步的话，多个线程是不能共享<code>HashMap</code>的。 即是说，在多线程应用程序中，不用专门的操作就安全地可以使用<code>Hashtable</code>了；而对于<code>HashMap</code>，则需要额外的同步机制。但<code>HashMap</code>的同步问题可通过Collections的一个静态方法得到解决：<code>Map Collections.synchronizedMap(Map m)</code>这个方法返回一个同步的Map，这个Map封装了底层的<code>HashMap</code>的所有方法，使得底层的<code>HashMap</code>即使是在多线程的环境中也是安全的。</p>
<p><em>另一个区别是<code>HashMap</code>的迭代器(Iterator)是fail-fast迭代器，而Hashtable的enumerator迭代器不是fail-fast的。</em>所以当有其它线程改变了<code>HashMap</code>的结构（增加或者移除元素），将会抛出<code>ConcurrentModificationException</code>，但迭代器本身的remove()方法移除元素则不会抛出<code>ConcurrentModificationException</code>异常。但这并不是一个一定发生的行为，要看JVM。这条同样也是Enumeration和Iterator的区别。</p>
<h3 id="速度"><a href="#速度" class="headerlink" title="速度"></a>速度</h3><p>由于<code>Hashtable</code>是线程安全的也是synchronized，所以<strong>在单线程环境下它比HashMap要慢</strong>。如果你不需要同步，只需要单一线程，那么使用<code>HashMap</code>性能要好过<code>Hashtable</code>。</p>
<p><code>HashMap</code>不能保证随着时间的推移Map中的元素次序是不变的。<br>哈希值的使用不同，<code>HashTable</code>直接使用对象的hashCode，代码是这样的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> hash = key.hashCode();</span><br><span class="line"><span class="keyword">int</span> index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br></pre></td></tr></table></figure>
<p>而<code>HashMap</code>重新计算hash值，而且用与代替求模：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> hash = hash(k);</span><br><span class="line"><span class="keyword">int</span> i = indexFor(hash, table.length);</span><br></pre></td></tr></table></figure>

<p>要注意的一些重要术语：</p>
<ol>
<li><p>sychronized意味着在一次仅有一个线程能够更改<code>Hashtable</code>。就是说任何线程要更新<code>Hashtable</code>时要首先获得同步锁，其它线程要等到同步锁被释放之后才能再次获得同步锁更新<code>Hashtable</code>。</p>
</li>
<li><p>Fail-safe和iterator迭代器相关。如果某个集合对象创建了Iterator或者ListIterator，然后其它的线程试图“结构上”更改集合对象，将会抛出ConcurrentModificationException异常。但其它是假如已经从结构上进行了更改，再调用set()方法，将会抛出IllegalArgumentException异常。</p>
</li>
<li><p>结构上的更改指的是删除或者插入一个元素，这样会影响到map的结构。</p>
</li>
</ol>
<h2 id="HashSet和HashMap的区别"><a href="#HashSet和HashMap的区别" class="headerlink" title="HashSet和HashMap的区别"></a>HashSet和HashMap的区别</h2><h3 id="什么是HashSet？"><a href="#什么是HashSet？" class="headerlink" title="什么是HashSet？"></a>什么是HashSet？</h3><p>HashSet实现了Set接口，<strong>它不允许集合中有重复的值</strong>，当我们提到HashSet时，第一件事情就是在将对象存储在HashSet之前，要先确保对象重写equals()和hashCode()方法，这样才能比较对象的值是否相等，以确保set中没有储存相等的对象。如果我们没有重写这两个方法，将会使用这个方法的默认实现。详见《探索equals()和hashCode()方法》。</p>
<p>public boolean add(Object o)方法用来在Set中添加元素，当元素值重复时则会立即返回false，如果成功添加的话会返回true。</p>
<p><strong>什么是HashMap？</strong><br>HashMap实现了Map接口，Map接口对键值对进行映射。<strong>Map中不允许重复的键</strong>。Map接口有两个基本的实现，HashMap和TreeMap。TreeMap保存了对象的排列次序，而HashMap则不能。HashMap允许键和值为null。HashMap是非synchronized的，但collection框架提供方法能保证HashMap synchronized，这样多个线程同时访问HashMap时，能保证只有一个线程更改Map。</p>
<p><code>public Object put(Object Key,Object value)</code>方法用来将元素添加到map中。</p>
<p><strong>HashSet和HashMap的区别</strong><br>HashMap | HashSet<br>—|—<br>HashMap实现了Map接口 |HashSet实现了Set接口<br>HashMap储存键值对 |HashSet仅仅存储对象（且无重复对象）<br>使用put()方法将元素放入map中|使用add()方法将元素放入set中<br>HashMap中使用键对象来计算hashcode值|HashSet使用成员对象来计算hashcode值，对于两个对象来说hashcode可能相同，所以equals()方法用来判断对象的相等性，如果两个对象不同的话，那么返回false<br>HashMap比较快，因为是使用唯一的键来获取对象    |HashSet较HashMap来说比较慢</p>
<h2 id="HashMap工作原理"><a href="#HashMap工作原理" class="headerlink" title="HashMap工作原理"></a>HashMap工作原理</h2><p>待补充</p>
<h2 id="HashSet工作原理"><a href="#HashSet工作原理" class="headerlink" title="HashSet工作原理"></a>HashSet工作原理</h2><p>待补充</p>
<p>参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/speedme/article/details/22485681">https://blog.csdn.net/speedme/article/details/22485681</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://wenwenhuan.gitee.io/2020/05/14/IDEA%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="温文焕">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wenhuan Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/05/14/IDEA%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/" class="post-title-link" itemprop="url">idea常用的快捷键</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-05-14 20:23:32" itemprop="dateCreated datePublished" datetime="2020-05-14T20:23:32+08:00">2020-05-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2021-02-28 20:07:46" itemprop="dateModified" datetime="2021-02-28T20:07:46+08:00">2021-02-28</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>Alt+回车 导入包,自动修正</p>
<p>Ctrl+N   查找类</p>
<p>Ctrl+Shift+N 查找文件</p>
<p>Ctrl+Alt+L  格式化代码</p>
<p>Ctrl+Alt+O 优化导入的类和包</p>
<p>Alt+Insert 生成代码(如get,set方法,构造函数等)</p>
<p>Ctrl+E或者Alt+Shift+C  最近更改的代码</p>
<p>Ctrl+R 替换文本</p>
<p>Ctrl+F 查找文本</p>
<p>Ctrl+Shift+Space 自动补全代码</p>
<p>Ctrl+空格 代码提示</p>
<p>Ctrl+Alt+Space 类名或接口名提示</p>
<p>Ctrl+P 方法参数提示</p>
<p>Ctrl+Shift+Alt+N 查找类中的方法或变量</p>
<p>Alt+Shift+C 对比最近修改的代码</p>
<p>Shift+F6  重构-重命名</p>
<p>Ctrl+Shift+先上键</p>
<p>Ctrl+X 删除行</p>
<p>Ctrl+D 复制行</p>
<p>Ctrl+/ 或 Ctrl+Shift+/  注释（// 或者/<em>…</em>/ ）</p>
<p>Ctrl+J  自动代码</p>
<p>Ctrl+E 最近打开的文件</p>
<p>Ctrl+H 显示类结构图</p>
<p>Ctrl+Q 显示注释文档</p>
<p>Alt+F1 查找代码所在位置</p>
<p>Alt+1 快速打开或隐藏工程面板</p>
<p>Ctrl+Alt+ left/right 返回至上次浏览的位置</p>
<p>Alt+ left/right 切换代码视图</p>
<p>Alt+ Up/Down 在方法间快速移动定位</p>
<p>Ctrl+Shift+Up/Down 代码向上/下移动。</p>
<p>F2 或Shift+F2 高亮错误或警告快速定位</p>
<p>代码标签输入完成后，按Tab，生成代码。</p>
<p>选中文本，按Ctrl+Shift+F7 ，高亮显示所有该文本，按Esc高亮消失。</p>
<p>Ctrl+W 选中代码，连续按会有其他效果</p>
<p>选中文本，按Alt+F3 ，逐个往下查找相同文本，并高亮显示。</p>
<p>Ctrl+Up/Down 光标跳转到第一行或最后一行下</p>
<p>Ctrl+B 快速打开光标处的类或方法 </p>
<p>Intellij IDEA最常用快捷键</p>
<p>1.Ctrl＋E，可以显示最近编辑的文件列表</p>
<p>2.Shift＋Click可以关闭文件</p>
<p>3.Ctrl＋[或]可以跳到大括号的开头结尾</p>
<p>4.Ctrl＋Shift＋Backspace可以跳转到上次编辑的地方</p>
<p>5.Ctrl＋F12，可以显示当前文件的结构</p>
<p>6.Ctrl＋F7可以查询当前元素在当前文件中的引用，然后按F3可以选择</p>
<p>7.Ctrl＋N，可以快速打开类</p>
<p>8.Ctrl＋Shift＋N，可以快速打开文件</p>
<p>9.Alt＋Q可以看到当前方法的声明</p>
<p>10.Ctrl＋W可以选择单词继而语句继而行继而函数</p>
<p>11.Alt＋F1可以将正在编辑的元素在各个面板中定位</p>
<p>12.Ctrl＋P，可以显示参数信息</p>
<p>13.Ctrl＋Shift＋Insert可以选择剪贴板内容并插入</p>
<p>14.Alt＋Insert可以生成构造器/Getter/Setter等</p>
<p>15.Ctrl＋Alt＋V 可以引入变量。例如把括号内的SQL赋成一个变量</p>
<p>16.Ctrl＋Alt＋T可以把代码包在一块内，例如try/catch</p>
<p>17.Alt＋Up and Alt＋Down可在方法间快速移动</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://wenwenhuan.gitee.io/2020/05/14/hexo%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="温文焕">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wenhuan Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/05/14/hexo%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2/" class="post-title-link" itemprop="url">hexo博客部署</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-05-14 20:23:32" itemprop="dateCreated datePublished" datetime="2020-05-14T20:23:32+08:00">2020-05-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2021-10-28 17:25:42" itemprop="dateModified" datetime="2021-10-28T17:25:42+08:00">2021-10-28</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h4 id="搭建要求："><a href="#搭建要求：" class="headerlink" title="搭建要求："></a>搭建要求：</h4><p>git——下载地址：<a target="_blank" rel="noopener" href="https://git-scm.com/downloads">https://git-scm.com/downloads</a></p>
<p>安装及使用教程：<a target="_blank" rel="noopener" href="https://www.runoob.com/git/git-tutorial.html">https://www.runoob.com/git/git-tutorial.html</a></p>
<p>Node.js——下载地址：<a target="_blank" rel="noopener" href="https://nodejs.org/zh-cn/">https://nodejs.org/zh-cn/</a></p>
<p>使用教程：<a target="_blank" rel="noopener" href="https://www.runoob.com/nodejs/nodejs-tutorial.html">https://www.runoob.com/nodejs/nodejs-tutorial.html</a></p>
<h4 id="开始搭建："><a href="#开始搭建：" class="headerlink" title="开始搭建："></a>开始搭建：</h4><h5 id="1-检查环境"><a href="#1-检查环境" class="headerlink" title="1.检查环境"></a>1.检查环境</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">node -v     #查看node版本</span><br><span class="line">npm -v     #查看npm版本</span><br><span class="line">npm无加速器下载资源较慢，这里建议改成淘宝的cnpm工具</span><br><span class="line">npm install -g cnpm --registry&#x3D;http:&#x2F;&#x2F;registry.npm.taobao.org #安装淘宝的管理器</span><br><span class="line">cnpm -v    #查看cnpm版本</span><br></pre></td></tr></table></figure>

<h5 id="2-安装Hexo"><a href="#2-安装Hexo" class="headerlink" title="2.安装Hexo"></a>2.安装Hexo</h5><p>选择一个磁盘，新建一个用来保存hexo框架的文件夹</p>
<p><code>cnpm install -g hexo-cli    #安装hexo框架</code></p>
<p><code>hexo init    #生成博客，初始化博客/注意   linux的用户需要加 sudo获取权限</code></p>
<h5 id="3-获取博客主题以aircloud为例"><a href="#3-获取博客主题以aircloud为例" class="headerlink" title="3.获取博客主题以aircloud为例"></a>3.获取博客主题以aircloud为例</h5><p>在主题文件夹执行</p>
<p><code>git clone https://github.com/aircloud/hexo-theme-airclou</code></p>
<p>修改文件名为aircloud，修改_config.yml文件的主题参数为aircloud。</p>
<p>搜索功能等插件在主题的github上有详细描述，不一一赘述。</p>
<h5 id="4-Typroa-Hexo"><a href="#4-Typroa-Hexo" class="headerlink" title="4.Typroa+Hexo"></a>4.Typroa+Hexo</h5><p>参考<a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1600295">https://cloud.tencent.com/developer/article/1600295</a></p>
<ul>
<li>Typroa图像设置</li>
</ul>
<img src="/2020/05/14/hexo%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2/image-20211028172438810.png" class="" title="image-20211028172438810">

<ul>
<li>修改<code>post_asset_folder: true</code></li>
<li>生成一篇新的博客 <code>hexo new blog-name</code></li>
<li>通过typora向博客中插入一张图片，此时可以到<code>source/_posts</code>目录下看图片是否拷贝到了对应的目录</li>
<li><code>cnpm install hexo-image-link --save</code>安装插件</li>
<li><code>hexo server -debug</code> 预览图片是否能正常显示</li>
</ul>
<h5 id="5-发布到gitee"><a href="#5-发布到gitee" class="headerlink" title="5.发布到gitee"></a>5.发布到gitee</h5><p>配置_config.yml中的关键参数</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">url:</span> <span class="string">https://wenwenhuan.gitee.io</span></span><br><span class="line"><span class="attr">root:</span> <span class="string">/</span></span><br><span class="line"></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">git@gitee.com:wenwenhuan/wenwenhuan.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure>

<p>输入命令<code>npm install hexo-deployer-git --save</code> 安装自动部署发布工具<br>输入命令<code>hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</code> 发布博客，首次发布需要在shell中输入账号和密码。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://wenwenhuan.gitee.io/2020/03/02/%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="温文焕">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wenhuan Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/03/02/%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9/" class="post-title-link" itemprop="url">数值的整数次方</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-03-02 10:00:00" itemprop="dateCreated datePublished" datetime="2020-03-02T10:00:00+08:00">2020-03-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2021-03-03 15:58:34" itemprop="dateModified" datetime="2021-03-03T15:58:34+08:00">2021-03-03</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>实现函数double Power(double base, int exponent)，求base的exponent次方。不得使用库函数，同时不需要考虑大数问题。</p>
<p>示例 1:</p>
<p>输入: 2.00000, 10<br>输出: 1024.00000</p>
<p>示例 2:</p>
<p>输入: 2.00000, -2<br>输出: 0.25000<br>解释: 2-2 = 1/22 = 1/4 = 0.25</p>
<p>说明:</p>
<p>-100.0 &lt; x &lt; 100.0<br>n 是 32 位有符号整数，其数值范围是 [−231, 231 − 1] 。</p>
<p>利用快速幂解题（二分法角度）：<br>算法流程： </p>
<ol>
<li><p>当 x = 0时：直接返回 0 （避免后续 x=1/x 操作报错）。</p>
</li>
<li><p>初始化 res = 1res=1 ；</p>
</li>
<li><p>当 n &lt; 0n&lt;0 时：把问题转化至 n \geq 0n≥0 的范围内，即执行 x = 1/xx=1/x ，n = - nn=−n ；</p>
</li>
<li><p>循环计算：当 n=0 时跳出；</p>
<ol>
<li>当 n &amp; 1 = 1 时：将当前 x 乘入 res（即 res∗=x ）；</li>
<li>执行 x = x^2即 （x∗=x ）；</li>
<li>执行 n 右移一位（即 n &gt;&gt;= 1）。</li>
</ol>
</li>
<li><p>返回 res 。</p>
</li>
</ol>
<p>Java 代码中 int32 变量 n∈[−2147483648,2147483647] ，因此当 n = -2147483648时执行 n = -n 会因越界而赋值出错。解决方法是先将 n存入 long 变量 b ，后面用 b 操作即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> b = n;</span><br><span class="line">        <span class="keyword">double</span> res = <span class="number">1.0</span>;</span><br><span class="line">        <span class="keyword">if</span>(b &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            x = <span class="number">1</span> / x;</span><br><span class="line">            b = -b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(b &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>((b &amp; <span class="number">1</span>) == <span class="number">1</span>) res *= x;</span><br><span class="line">            x *= x;</span><br><span class="line">            b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>知识扩展：</p>
<ul>
<li><p>向下整除 n // 2 等价于位移运算的右移一位n&gt;&gt;1 ；</p>
<p>java中有三种移位运算符</p>
<p>&lt;&lt;    :   左移运算符，num &lt;&lt; 1,相当于num乘以2</p>
<p>&gt;&gt;    :   右移运算符，num &gt;&gt; 1,相当于num除以2</p>
<p>&gt;&gt;&gt;   :   无符号右移，忽略符号位，空位都以0补齐</p>
</li>
<li><p>取余数 n % 2 <strong>等价于</strong> 判断二进制最右一位值 n &amp; 1 ；</p>
<p>位运算符&amp;–两个为真才为真</p>
<p>&amp;按位与的运算规则是将两边的数转换为二进制位，然后运算最终值，运算规则即(两个为真才为真)1&amp;1=1 , 1&amp;0=0 , 0&amp;1=0 , 0&amp;0=0</p>
<p>3的二进制位是0000 0011 ， 5的二进制位是0000 0101 ， 那么就是011 &amp; 101，由按位与运算规则得知，001 &amp; 101等于0000 0001，最终值为1</p>
<p>7的二进制位是0000 0111，那就是111 &amp; 101等于101，也就是0000 0101，故值为5</p>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/5/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/7/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">温文焕</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  





  





</body>
</html>
