<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"wenwenhuan.gitee.io","root":"/","images":"/images","scheme":"Gemini","darkmode":true,"version":"8.8.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>
<meta property="og:type" content="website">
<meta property="og:title" content="Wenhuan Blog">
<meta property="og:url" content="https://wenwenhuan.gitee.io/page/2/index.html">
<meta property="og:site_name" content="Wenhuan Blog">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="温文焕">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://wenwenhuan.gitee.io/page/2/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/2/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Wenhuan Blog</title>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Wenhuan Blog</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">即使天无雨 我亦留此地</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">温文焕</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">65</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://wenwenhuan.gitee.io/2021/07/28/Nginx%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="温文焕">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wenhuan Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/07/28/Nginx%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/" class="post-title-link" itemprop="url">Nginx学习记录</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-07-28 16:17:20 / 修改时间：18:04:36" itemprop="dateCreated datePublished" datetime="2021-07-28T16:17:20+08:00">2021-07-28</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><hr>
<h3 id="1-Windows"><a href="#1-Windows" class="headerlink" title="1.Windows"></a>1.Windows</h3><ol>
<li><p>在官网下载解压后运行cmd，使用命令进行操作，不要直接双击nginx.exe，不要直接双击nginx.exe，不要直接双击nginx.exe</p>
<p>一定要在dos窗口启动，不要直接双击nginx.exe，这样会导致修改配置后重启、停止nginx无效，需要手动关闭任务管理器内的所有nginx进程，再启动才可以</p>
</li>
<li><p>启动</p>
<p><code>start nginx</code></p>
</li>
<li><p>查看任务进程是否存在，dos或打开任务管理器确认后即可，出现错误可以看错误日志。（注意端口被占用的情况）</p>
</li>
<li><p>修改配置：nginx.conf</p>
</li>
<li><p>访问域名及端口，出现欢迎页就说明部署成功了</p>
</li>
<li><p><strong>在Windows下使用Nginx</strong></p>
<ul>
<li><p>启动</p>
<p><code>start nginx</code></p>
<p>或</p>
<p><code>nginx.exe</code></p>
<p>注：建议使用第一种，第二种会使你的cmd窗口一直处于执行中，不能进行其他命令操作。</p>
</li>
<li><p>停止</p>
<p><code>nginx.exe -s stop</code></p>
<p>或</p>
<p><code>nginx.exe -s quit</code></p>
<p>注：stop是快速停止nginx，可能并不保存相关信息；quit是完整有序的停止nginx，并保存相关信息。</p>
</li>
<li><p>重新载入Nginx</p>
<p><code>nginx.exe -s reload</code></p>
<p>当配置信息修改，需要重新载入这些配置时使用此命令。</p>
</li>
<li><p>重新打开日志文件</p>
<p><code>nginx.exe -s reopen</code></p>
</li>
</ul>
</li>
</ol>
<h3 id="2-Ubantu"><a href="#2-Ubantu" class="headerlink" title="2.Ubantu"></a>2.Ubantu</h3><ol>
<li><p>更新软件安装包</p>
<p>Nginx 在默认的 Ubuntu 源仓库中可用。想要安装它，运行下面的命令：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt install nginx</span><br></pre></td></tr></table></figure>

<p>一旦安装完成，Nginx 将会自动被启动。你可以运行下面的命令来验证它：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl status nginx</span><br></pre></td></tr></table></figure></li>
<li><p>配置防火墙？</p>
</li>
<li><p>测试安装</p>
</li>
</ol>
<h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><hr>
<h3 id="配置文件详解"><a href="#配置文件详解" class="headerlink" title="配置文件详解"></a>配置文件详解</h3><ul>
<li>全局块：配置影响nginx全局的指令。一般有运行nginx服务器的用户组，nginx进程pid存放路径，日志存放路径，配置文件引入，允许生成worker process数等。</li>
<li>events块：配置影响nginx服务器或与用户的网络连接。有每个进程的最大连接数，选取哪种事件驱动模型处理连接请求，是否允许同时接受多个网路连接，开启多个网络连接序列化等。</li>
<li>http块：可以嵌套多个server，配置代理，缓存，日志定义等绝大多数功能和第三方模块的配置。如文件引入，mime-type定义，日志自定义，是否使用sendfile传输文件，连接超时时间，单连接请求数等。</li>
<li>server块：配置虚拟主机的相关参数，一个http中可以有多个server。</li>
<li>location块：配置请求的路由，以及各种页面的处理情况。<br>server 部分的指令主要用于制定虚拟主机域名、IP 和端口号；location 部分用于匹配网页位置（比如，根目录“/”，“/images”，等等）。他们之间的关系：server 继承 main，location 继承 server。</li>
</ul>
<h3 id="一些配置资料"><a href="#一些配置资料" class="headerlink" title="一些配置资料"></a>一些配置资料</h3><p>​    #user administrator administrators;  # 配置用户或者组，默认为nobody nobody。<br>​    </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line">#pid &#x2F;nginx&#x2F;pid&#x2F;nginx.pid;  # 指定nginx进程运行文件存放地址</span><br><span class="line"></span><br><span class="line">worker_processes  1;  # 允许生成的进程数，默认为1，一般设置为cpu核心数,值越大可以支持的并发处理量越多</span><br><span class="line"></span><br><span class="line">#error_log  logs&#x2F;error.log;</span><br><span class="line">#error_log  logs&#x2F;error.log  notice;</span><br><span class="line">#error_log  logs&#x2F;error.log  info;</span><br><span class="line"></span><br><span class="line">#进程pid文件</span><br><span class="line">#pid        logs&#x2F;nginx.pid;</span><br><span class="line">events &#123;</span><br><span class="line"></span><br><span class="line">    # 最大连接数，一般设置为cpu*2048</span><br><span class="line">    worker_connections  1024;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">    include mime.types;  # 注1</span><br><span class="line">    default_type  application&#x2F;octet-stream; # 默认文件类型，默认为text&#x2F;plain</span><br><span class="line"></span><br><span class="line">    #log_format  main  &#39;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#39;</span><br><span class="line">    #                  &#39;$status $body_bytes_sent &quot;$http_referer&quot; &#39;</span><br><span class="line">    #                  &#39;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#39;;</span><br><span class="line"></span><br><span class="line">    #access_log  logs&#x2F;access.log  main;</span><br><span class="line"></span><br><span class="line">    sendfile        on;  # 允许sendfile方式传输文件，默认为off，可以在http块，server块，location块。</span><br><span class="line">    sendfile_max_chunk 100k;  #每个进程每次调用传输数量不能大于设定的值，默认为0，即不设上限。</span><br><span class="line">    keepalive_timeout 65;  #连接超时时间，默认为75s，可以在http，server，location块。</span><br><span class="line">    #tcp_nopush     on;</span><br><span class="line"></span><br><span class="line">    #keepalive_timeout  0;</span><br><span class="line"></span><br><span class="line">    #gzip  on;</span><br><span class="line"></span><br><span class="line">    #当配置多个server节点时，默认server names的缓存区大小就不够了，需要手动设置大一点</span><br><span class="line">    server_names_hash_bucket_size 512;</span><br><span class="line"></span><br><span class="line">    #server表示虚拟主机可以理解为一个站点，可以配置多个server节点搭建多个站点</span><br><span class="line">    #每一个请求进来确定使用哪个server由server_name确定</span><br><span class="line">    server &#123;</span><br><span class="line">        #站点监听端口</span><br><span class="line">        #80端口是网站默认端口号，如果你在浏览器你直接输入网址，不带端口号，那么浏览器就会请求服务器的80端口。</span><br><span class="line">        listen       80;</span><br><span class="line">        #站点访问域名</span><br><span class="line">        server_name  localhost;</span><br><span class="line">        </span><br><span class="line">        #编码格式，避免url参数乱码</span><br><span class="line">        charset utf-8;</span><br><span class="line"></span><br><span class="line">        #access_log  logs&#x2F;host.access.log  main;</span><br><span class="line"></span><br><span class="line">        #location用来匹配同一域名下多个URI的访问规则</span><br><span class="line">        #比如动态资源如何跳转，静态资源如何跳转等</span><br><span class="line">        #location后面跟着的&#x2F;代表匹配规则</span><br><span class="line">        location &#x2F; &#123;</span><br><span class="line">            #站点根目录，可以是相对路径，也可以使绝对路径</span><br><span class="line">            root   html;</span><br><span class="line">            #默认主页</span><br><span class="line">            index  index.html index.htm;</span><br><span class="line">            </span><br><span class="line">            #转发后端站点地址，一般用于做软负载，轮询后端服务器</span><br><span class="line">            #proxy_pass http:&#x2F;&#x2F;10.11.12.237:8080;</span><br><span class="line"></span><br><span class="line">            #拒绝请求，返回403，一般用于某些目录禁止访问</span><br><span class="line">            #deny all;</span><br><span class="line">            </span><br><span class="line">            #允许请求</span><br><span class="line">            #allow all;</span><br><span class="line">            </span><br><span class="line">            add_header &#39;Access-Control-Allow-Origin&#39; &#39;*&#39;;</span><br><span class="line">            add_header &#39;Access-Control-Allow-Credentials&#39; &#39;true&#39;;</span><br><span class="line">            add_header &#39;Access-Control-Allow-Methods&#39; &#39;GET, POST, OPTIONS&#39;;</span><br><span class="line">            add_header &#39;Access-Control-Allow-Headers&#39; &#39;DNT,X-CustomHeader,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type&#39;;</span><br><span class="line">            #重新定义或者添加发往后端服务器的请求头</span><br><span class="line">            #给请求头中添加客户请求主机名</span><br><span class="line">            proxy_set_header Host $host;</span><br><span class="line">            #给请求头中添加客户端IP</span><br><span class="line">            proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">            #将$remote_addr变量值添加在客户端“X-Forwarded-For”请求头的后面，并以逗号分隔。 如果客户端请求未携带“X-Forwarded-For”请求头，$proxy_add_x_forwarded_for变量值将与$remote_addr变量相同  </span><br><span class="line">            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">            #给请求头中添加客户端的Cookie</span><br><span class="line">            proxy_set_header Cookie $http_cookie;</span><br><span class="line">            #将使用代理服务器的主域名和端口号来替换。如果端口是80，可以不加。</span><br><span class="line">            proxy_redirect off;</span><br><span class="line">            </span><br><span class="line">            #浏览器对 Cookie 有很多限制，如果 Cookie 的 Domain 部分与当前页面的 Domain 不匹配就无法写入。</span><br><span class="line">            #所以如果请求 A 域名，服务器 proxy_pass 到 B 域名，然后 B 服务器输出 Domian&#x3D;B 的 Cookie，</span><br><span class="line">            #前端的页面依然停留在 A 域名上，于是浏览器就无法将 Cookie 写入。</span><br><span class="line">            </span><br><span class="line">　　         #不仅是域名，浏览器对 Path 也有限制。我们经常会 proxy_pass 到目标服务器的某个 Path 下，</span><br><span class="line">            #不把这个 Path 暴露给浏览器。这时候如果目标服务器的 Cookie 写死了 Path 也会出现 Cookie 无法写入的问题。</span><br><span class="line">            </span><br><span class="line">            #设置“Set-Cookie”响应头中的domain属性的替换文本，其值可以为一个字符串、正则表达式的模式或一个引用的变量</span><br><span class="line">            #转发后端服务器如果需要Cookie则需要将cookie domain也进行转换，否则前端域名与后端域名不一致cookie就会无法存取</span><br><span class="line">　　　　　　  #配置规则：proxy_cookie_domain serverDomain(后端服务器域) nginxDomain(nginx服务器域)</span><br><span class="line">            proxy_cookie_domain localhost .testcaigou800.com;</span><br><span class="line">            </span><br><span class="line">            #取消当前配置级别的所有proxy_cookie_domain指令</span><br><span class="line">            #proxy_cookie_domain off;</span><br><span class="line">            #与后端服务器建立连接的超时时间。一般不可能大于75秒；</span><br><span class="line">            proxy_connect_timeout 30;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        #error_page  404              &#x2F;404.html;</span><br><span class="line"></span><br><span class="line">        # redirect server error pages to the static page &#x2F;50x.html</span><br><span class="line">        #</span><br><span class="line">        error_page   500 502 503 504  &#x2F;50x.html;</span><br><span class="line">        location &#x3D; &#x2F;50x.html &#123;</span><br><span class="line">            root   html;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">　　#当需要对同一端口监听多个域名时，使用如下配置，端口相同域名不同，server_name也可以使用正则进行配置</span><br><span class="line">　　#但要注意server过多需要手动扩大server_names_hash_bucket_size缓存区大小</span><br><span class="line">　　server &#123;</span><br><span class="line">　　　　listen 80;</span><br><span class="line">　　　　server_name www.abc.com;</span><br><span class="line">　　　　charset utf-8;</span><br><span class="line">　　　　location &#x2F; &#123;</span><br><span class="line">　　　　　　proxy_pass http:&#x2F;&#x2F;localhost:10001;</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　&#125;</span><br><span class="line">　　server &#123;</span><br><span class="line">　　　　listen 80;</span><br><span class="line">　　　　server_name aaa.abc.com;</span><br><span class="line">　　　　charset utf-8;</span><br><span class="line">　　　　location &#x2F; &#123;</span><br><span class="line">　　　　　　proxy_pass http:&#x2F;&#x2F;localhost:20002;</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="注1：MIME-类型"><a href="#注1：MIME-类型" class="headerlink" title="注1：MIME 类型"></a>注1：MIME 类型</h3><p> 媒体类型（通常称为 Multipurpose Internet Mail Extensions 或 MIME 类型 ）是一种标准，用来表示文档、文件或字节流的性质和格式。</p>
<p> <strong>重要</strong></p>
<p>浏览器通常使用MIME类型（而不是文件扩展名）来确定如何处理URL，因此Web服务器在响应头中添加正确的MIME类型非常重要。如果配置不正确，浏览器可能会曲解文件内容，网站将无法正常工作，并且下载的文件也会被错误处理。</p>
<p><strong>语法</strong></p>
<p>通用结构 <code>type/subtype</code><br>MIME的组成结构非常简单；由类型与子类型两个字符串中间用<code>&#39;/&#39;</code>分隔而组成。不允许空格存在。type 表示可以被分多个子类的独立类别。subtype 表示细分后的每个类型。MIME类型对大小写不敏感，但是传统写法都是小写。</p>
<h3 id="几个常见配置项"><a href="#几个常见配置项" class="headerlink" title="几个常见配置项"></a><strong>几个常见配置项</strong></h3><p>1.$remote_addr 与 $http_x_forwarded_for 用以记录客户端的ip地址；</p>
<p>2.$remote_user ：用来记录客户端用户名称；</p>
<p>3.$time_local ： 用来记录访问时间与时区；</p>
<p>4.$request ： 用来记录请求的url与http协议；</p>
<p>5.$status ： 用来记录请求状态；成功是200；</p>
<p>6.$body_bytes_s ent ：记录发送给客户端文件主体内容大小；</p>
<p>7.$http_referer ：用来记录从那个页面链接访问过来的；</p>
<p>8.$http_user_agent ：记录客户端浏览器的相关信息；</p>
<p> 惊群现象：一个网路连接到来，多个睡眠的进程被同时叫醒，但只有一个进程能获得链接，这样会影响系统性能。</p>
<p> 每个指令必须有分号结束。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://wenwenhuan.gitee.io/2021/07/28/Oracle11g%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="温文焕">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wenhuan Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/07/28/Oracle11g%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/" class="post-title-link" itemprop="url">Oracle11g学习记录</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-07-28 16:15:28" itemprop="dateCreated datePublished" datetime="2021-07-28T16:15:28+08:00">2021-07-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2021-12-21 17:28:32" itemprop="dateModified" datetime="2021-12-21T17:28:32+08:00">2021-12-21</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="1、TNS-12560-TNS-协议适配器错误或者ORA-12638-credential-retrieval-failed"><a href="#1、TNS-12560-TNS-协议适配器错误或者ORA-12638-credential-retrieval-failed" class="headerlink" title="1、TNS-12560: TNS: 协议适配器错误或者ORA-12638: credential retrieval failed"></a>1、TNS-12560: TNS: 协议适配器错误或者ORA-12638: credential retrieval failed</h3><p>配置数据库或者登录数据库报这个错误可以通过改..\app\admin\product\11.2.0\dbhome_1\NETWORK\ADMIN\listener.ora文件</p>
<p><code>Original Entry - SQLNET.AUTHENTICATION_SERVICES= (NTS)</code><br><code>Modified Entry - SQLNET.AUTHENTICATION_SERVICES= (NONE) </code></p>
<h3 id="2、密码不要设置数字开头"><a href="#2、密码不要设置数字开头" class="headerlink" title="2、密码不要设置数字开头"></a>2、密码不要设置数字开头</h3><p>oracle有个毛病，密码必须以字母开头，如果以数字开头，它不会创建用户</p>
<h3 id="3、启动Oracle-SQL-Developer报错WARNING-Could-not-find-jvm-cfg"><a href="#3、启动Oracle-SQL-Developer报错WARNING-Could-not-find-jvm-cfg" class="headerlink" title="3、启动Oracle SQL Developer报错WARNING: Could not find jvm.cfg"></a>3、启动Oracle SQL Developer报错WARNING: Could not find jvm.cfg</h3><p><strong>原因：</strong>oracle 11g中安装的Oracle SQL Developer是32位的，而我们现在给他指定的java.exe却是64位的，所以会出现这种错误。</p>
<p><strong>解决方法：</strong></p>
<ol>
<li><p>从网上下载Oracle SQL Developer x64，然后替换原目录：D:\app\oracle\product\11.1.0\db_1\sqldeveloper下的32位的Oracle SQL Developer。这样重新启动Oracle SQL Developer 并制定java.exe的路径就可以了。</p>
</li>
<li><p>安装JDK6 x86，也就是32位的JDK，虽然我们的系统是64位的，但是也兼容32位的JDK。</p>
</li>
</ol>
<h3 id="4、ORA-01950-对表空间-‘USERS’-无权限"><a href="#4、ORA-01950-对表空间-‘USERS’-无权限" class="headerlink" title="4、ORA-01950: 对表空间 ‘USERS’ 无权限"></a>4、ORA-01950: 对表空间 ‘USERS’ 无权限</h3><p>创建新的用户时，要指定default  tablespace，否则它会把system表空间当成自己的缺省表空间。这样做是不提倡的。估计原来创建某个用户的时候没有指定缺省表空间，而现在它使用系统表空间的权限被DBA给收回了。<br> 先用的简单的办法试试，一般缺省的ORACLE安装都是有USERS表空间的。<br> 比如你要在用户（或SCHEMA）usera中建表，那么你用SYSTEM登录ORACLE后，执行如下SQL </p>
<p> <em><strong>*ALTER  USER  usera  QUOTA  UNLIMITED  ON  USERS;*</strong></em><br> 如果没有USERS表空间，则会报错，你可以找一个其他的表空间，从v$tablespace可以看到所有的表空间。</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/leftfist/article/details/79654651">https://blog.csdn.net/leftfist/article/details/79654651</a></p>
<h3 id="5、SQL语法记得带”-”"><a href="#5、SQL语法记得带”-”" class="headerlink" title="5、SQL语法记得带”;”"></a>5、SQL语法记得带”;”</h3><h3 id="6、ORA-01045-user-lacks-CREATE-SESSION-privilege-logon-denied"><a href="#6、ORA-01045-user-lacks-CREATE-SESSION-privilege-logon-denied" class="headerlink" title="6、ORA-01045: user lacks CREATE SESSION privilege; logon denied"></a>6、ORA-01045: user lacks CREATE SESSION privilege; logon denied</h3><p><strong>Roles in Oracle</strong></p>
<p>When you create a new user, you must at least assign CREATE SESSIONS privilege so the user can connect to the database</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grant create session to usr1;</span><br></pre></td></tr></table></figure>

<h3 id="7、变更用户"><a href="#7、变更用户" class="headerlink" title="7、变更用户"></a>7、变更用户</h3><p>You <em>can</em> temporarily change to another user in that SQL Worksheet by doing:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">connect</span> <span class="operator">&lt;</span>username<span class="operator">&gt;</span><span class="operator">/</span><span class="operator">&lt;</span>password<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="8、查询用户相关信息"><a href="#8、查询用户相关信息" class="headerlink" title="8、查询用户相关信息"></a>8、查询用户相关信息</h3><p>List all users that are visible to the current user:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> all_users;</span><br></pre></td></tr></table></figure>

<p>List all users in the Oracle Database:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> dba_users;</span><br></pre></td></tr></table></figure>

<p>Show the information of the current user:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> user_users;</span><br></pre></td></tr></table></figure>

<h3 id="9、查询权限相关信息"><a href="#9、查询权限相关信息" class="headerlink" title="9、查询权限相关信息"></a>9、查询权限相关信息</h3><h4 id="Querying-DBA-USER-Privilege-Views"><a href="#Querying-DBA-USER-Privilege-Views" class="headerlink" title="Querying DBA/USER Privilege Views"></a>Querying DBA/USER Privilege Views</h4><p>A DBA wishing to view <strong>all <code>system</code> privileges</strong> granted to <strong>all users</strong> would issue the following query:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> DBA_SYS_PRIVS;</span><br></pre></td></tr></table></figure>

<p>To determine which <strong>users</strong> have <em>direct</em> grant access to a <strong><code>table</code></strong> we’ll use the <code>DBA_TAB_PRIVS</code> view:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> DBA_TAB_PRIVS;</span><br></pre></td></tr></table></figure>

<p>Finally, querying the <code>DBA_ROLE_PRIVS</code> view has much of the same information but applicable to <strong><code>roles</code></strong> instead, where the <code>GRANTED_ROLE</code> column specifies the role in question:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span>  DBA_ROLE_PRIVS;</span><br></pre></td></tr></table></figure>

<h4 id="Querying-the-Current-User’s-Privileges"><a href="#Querying-the-Current-User’s-Privileges" class="headerlink" title="Querying the Current User’s Privileges"></a>Querying the Current User’s Privileges</h4><blockquote>
<p>refer to:<a target="_blank" rel="noopener" href="https://chartio.com/resources/tutorials/oracle-user-privileges--how-to-show-all-privileges-for-a-user/">https://chartio.com/resources/tutorials/oracle-user-privileges--how-to-show-all-privileges-for-a-user/</a></p>
</blockquote>
<h3 id="10、使用Oracle-SQL-Developer创建模式"><a href="#10、使用Oracle-SQL-Developer创建模式" class="headerlink" title="10、使用Oracle SQL Developer创建模式"></a>10、使用Oracle SQL Developer创建模式</h3><ol>
<li><p>使用system账户（默认密码为安装Oracle时的密码）连接Oracle SQL Developer在其他用户中新建用户</p>
<img src="/2021/07/28/Oracle11g%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20211220234531194.png" class="" title="image-20211220234531194"></li>
<li><p>用户角色与权限配置</p>
<img src="/2021/07/28/Oracle11g%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20211220234708091.png" class="" title="image-20211220234708091">

<img src="/2021/07/28/Oracle11g%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20211220234648563.png" class="" title="image-20211220234648563">

<h3 id="11、表空间相关语句"><a href="#11、表空间相关语句" class="headerlink" title="11、表空间相关语句"></a>11、表空间相关语句</h3><p>授权表空间</p>
<p><code>alter user 用户名 quota unlimited on 表空间;</code></p>
<p>查询所有表空间</p>
<p><code>select * from dba_tablespaces;</code></p>
<p>查看当前用户的缺省表空间</p>
<p><code>select username,default_tablespace from user_users;</code></p>
<h3 id="12、创建用户"><a href="#12、创建用户" class="headerlink" title="12、创建用户"></a>12、创建用户</h3></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://wenwenhuan.gitee.io/2021/07/13/nacos/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="温文焕">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wenhuan Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/07/13/nacos/" class="post-title-link" itemprop="url">nacos</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-07-13 10:57:30 / 修改时间：11:15:20" itemprop="dateCreated datePublished" datetime="2021-07-13T10:57:30+08:00">2021-07-13</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="什么是-Nacos？"><a href="#什么是-Nacos？" class="headerlink" title="什么是 Nacos？"></a>什么是 Nacos？</h2><hr>
<p>Nacos 是阿里巴巴推出来的一个新开源项目，这是一个更易于<strong>构建云原生应用的动态服务发现</strong>、<strong>配置管理和服务管理平台</strong>。</p>
<p>Nacos 致力于帮助您<strong>发现、配置和管理微服务</strong>。Nacos 提供了一组简单易用的特性集，帮助您快速实现动态服务发现、服务配置、服务元数据及流量管理。</p>
<p>Nacos 帮助您更敏捷和容易地构建、交付和管理微服务平台。 Nacos 是构建以“服务”为中心的现代应用架构 (例如微服务范式、云原生范式) 的服务基础设施。</p>
<h2 id="Nacos-vs-Spring-Cloud"><a href="#Nacos-vs-Spring-Cloud" class="headerlink" title="Nacos vs Spring Cloud"></a>Nacos vs Spring Cloud</h2><hr>
<p>相对于 Spring Cloud Eureka 来说，Nacos 更强大。</p>
<p>Nacos = Spring Cloud Eureka + Spring Cloud Config</p>
<p>Nacos 可以与 Spring, Spring Boot, Spring Cloud 集成，并能代替 Spring Cloud Eureka, Spring Cloud Config。</p>
<ul>
<li>通过 Nacos Server 和 spring-cloud-starter-alibaba-nacos-config 实现配置的动态变更。</li>
<li>通过 Nacos Server 和 spring-cloud-starter-alibaba-nacos-discovery 实现服务的注册与发现。</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://wenwenhuan.gitee.io/2021/07/13/%E9%85%8D%E7%BD%AEnext%E4%B8%BB%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="温文焕">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wenhuan Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/07/13/%E9%85%8D%E7%BD%AEnext%E4%B8%BB%E9%A2%98/" class="post-title-link" itemprop="url">next主题配置分类和标签</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-07-13 10:57:30" itemprop="dateCreated datePublished" datetime="2021-07-13T10:57:30+08:00">2021-07-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2021-12-20 14:29:24" itemprop="dateModified" datetime="2021-12-20T14:29:24+08:00">2021-12-20</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="1-配置分类"><a href="#1-配置分类" class="headerlink" title="1.配置分类"></a>1.配置分类</h2><h3 id="1-1-在主题里配置好分类"><a href="#1-1-在主题里配置好分类" class="headerlink" title="1.1 在主题里配置好分类"></a>1.1 在主题里配置好分类</h3><p>首先我们得先在主题里把分类这个选项打开，例如在 Next 主题下找到hexo 博客项目文件夹下 <strong>\themes\next_config.yml</strong> 这个路径得配置文件,然后打开这个文件并找到下面得代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: &#x2F; || fa fa-home</span><br><span class="line">  # about: &#x2F;about&#x2F; || fa fa-user</span><br><span class="line">  tags: &#x2F;tags&#x2F; || fa fa-tags</span><br><span class="line">  categories: &#x2F;categories&#x2F; || fa fa-th</span><br><span class="line">  archives: &#x2F;archives&#x2F; || fa fa-archive</span><br><span class="line">  # schedule: &#x2F;schedule&#x2F; || fa fa-calendar</span><br><span class="line">  # sitemap: &#x2F;sitemap.xml || fa fa-sitemap</span><br><span class="line">  # commonweal: &#x2F;404&#x2F; || fa fa-heartbeat</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>然后放开  <strong>categories: /categories/ || fa fa-th</strong>  这行代码就已经配置好里分类。</p>
<h3 id="1-2-创建分类目录文件"><a href="#1-2-创建分类目录文件" class="headerlink" title="1.2 创建分类目录文件"></a>1.2 创建分类目录文件</h3><blockquote>
<p>因为分类页是没有默认页面的所以需要我们手动创建分类页。</p>
</blockquote>
<p>打开命令行，进入博客项目所在的文件夹下，执行以下命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new page categories</span><br></pre></td></tr></table></figure>

<p>成功后会提示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INFO  Created: ~&#x2F;blog&#x2F;source&#x2F;categories&#x2F;index.md</span><br></pre></td></tr></table></figure>

<p>这样我们就创建好了分类页面了。但是这个时候主题还不会识别这个页面为分类页；所以我们需要编辑这个新建的页面，让主题识别这个页面，并自动为这个页面显示分类。</p>
<h3 id="1-3-编辑页面让主题识别页面为分类页面"><a href="#1-3-编辑页面让主题识别页面为分类页面" class="headerlink" title="1.3 编辑页面让主题识别页面为分类页面"></a>1.3 编辑页面让主题识别页面为分类页面</h3><p>上文说到需要编辑页面才能让主题识别这个页面为分类页面，我们只需要根据成功后到提示路径打开<code>index.md</code>这个页面文件，打开后默认内容是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: 文章分类</span><br><span class="line">date: 2021-01-25 22:37:25</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<p>我们需要添加上<code>type: &quot;categories&quot;</code>这段代码就能让主题识别该页面为分类页面了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: 文章分类</span><br><span class="line">date: 2021-01-25 22:37:25</span><br><span class="line">type: &quot;categories&quot;</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<p>我们就完成了整个分类页面的配置了</p>
<h3 id="1-4-给文章设置分类属性"><a href="#1-4-给文章设置分类属性" class="headerlink" title="1.4 给文章设置分类属性"></a>1.4 给文章设置分类属性</h3><p>首先打开需要添加分类的文章，在文章里添加上以下文案就设置好分类了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">categories: </span><br><span class="line">- Android</span><br><span class="line">---</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>如上<code>categories:Android</code>表示添加这边文章到 “<strong>Android</strong>” 这个分类下。 然后我们就可以在博客到分类里看到该分类了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;设置二级分类</span><br><span class="line">---</span><br><span class="line">categories: </span><br><span class="line">- Android</span><br><span class="line">- xxx</span><br><span class="line">---</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>如上设置二级分类则该篇文章为 Android 分类下的 XXX 分类下。</p>
<h2 id="2-配置标签"><a href="#2-配置标签" class="headerlink" title="2.配置标签"></a>2.配置标签</h2><h3 id="2-1-在主题里配置好标签"><a href="#2-1-在主题里配置好标签" class="headerlink" title="2.1 在主题里配置好标签"></a>2.1 在主题里配置好标签</h3><p>首先我们得先在主题里把分类这个选项打开，例如在 Next 主题下找到hexo 博客项目文件夹下 <strong>\themes\next_config.yml</strong> 这个路径得配置文件,然后打开这个文件并找到下面得代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: &#x2F; || fa fa-home</span><br><span class="line">  # about: &#x2F;about&#x2F; || fa fa-user</span><br><span class="line">  tags: &#x2F;tags&#x2F; || fa fa-tags</span><br><span class="line">  categories: &#x2F;categories&#x2F; || fa fa-th</span><br><span class="line">  archives: &#x2F;archives&#x2F; || fa fa-archive</span><br><span class="line">  # schedule: &#x2F;schedule&#x2F; || fa fa-calendar</span><br><span class="line">  # sitemap: &#x2F;sitemap.xml || fa fa-sitemap</span><br><span class="line">  # commonweal: &#x2F;404&#x2F; || fa fa-heartbeat</span><br></pre></td></tr></table></figure>

<p>然后放开  <strong>tags: /tags/ || fa fa-tags</strong> 这行代码就已经配置好里分类。</p>
<h3 id="2-2-创建标签目录文件"><a href="#2-2-创建标签目录文件" class="headerlink" title="2.2 创建标签目录文件"></a>2.2 创建标签目录文件</h3><blockquote>
<p>和分类页一样，标签页也是没有默认页面的所以需要我们手动创建标签页。</p>
</blockquote>
<p>打开命令行，进入博客项目所在的文件夹下，执行以下命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new page tags</span><br></pre></td></tr></table></figure>

<p>成功后会提示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INFO  Created: ~&#x2F;blog&#x2F;source&#x2F;tags&#x2F;index.md</span><br></pre></td></tr></table></figure>

<p>这样我们就创建好了标签页面了。但是这个时候主题还不会识别这个页面为标签页；所以我们需要编辑这个新建的页面，让主题识别这个页面，并自动为这个页面显示标签。</p>
<h3 id="2-3-编辑页面让主题识别页面为标签页面"><a href="#2-3-编辑页面让主题识别页面为标签页面" class="headerlink" title="2.3 编辑页面让主题识别页面为标签页面"></a>2.3 编辑页面让主题识别页面为标签页面</h3><p>上文说到需要编辑页面才能让主题识别这个页面为标签页面，我们只需要根据成功后到提示路径打开<code>index.md</code>这个页面文件，打开后默认内容是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: 标签</span><br><span class="line">date: 2021-01-25 22:54:58</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<p>我们需要添加上<code>type: &quot;tags&quot;</code>这段代码就能让主题识别该页面为标签页面了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: 标签</span><br><span class="line">date: 2021-01-25 22:54:58</span><br><span class="line">type: &quot;tags&quot;</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<p>我们就完成了整个标签页面的配置了</p>
<h3 id="2-4-给文章设置标签属性"><a href="#2-4-给文章设置标签属性" class="headerlink" title="2.4 给文章设置标签属性"></a>2.4 给文章设置标签属性</h3><p>首先打开需要添加标签的文章，在文章里添加上以下文案，就设置好标签里了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;设置单标签</span><br><span class="line">---</span><br><span class="line">tags:</span><br><span class="line">- Facebook配置</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;设置多标签 并同时设置分类</span><br><span class="line">---</span><br><span class="line">categories: </span><br><span class="line">- Android</span><br><span class="line">tags:</span><br><span class="line">- Android</span><br><span class="line">- RecyclerView</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<p>如上<code>tags:- Facebook配置</code>表示给这篇文章添加 “<strong>Facebook配置</strong>” 这个分标签。 然后我们就可以在博客到标签里看到该标签了。</p>
<p>作者：醉过才知酒浓<br>链接：<a target="_blank" rel="noopener" href="https://juejin.cn/post/6921750181297782798">https://juejin.cn/post/6921750181297782798</a><br>来源：稀土掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://wenwenhuan.gitee.io/2021/05/27/Shell-Script/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="温文焕">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wenhuan Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/05/27/Shell-Script/" class="post-title-link" itemprop="url">Shell Script</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-05-27 21:51:21" itemprop="dateCreated datePublished" datetime="2021-05-27T21:51:21+08:00">2021-05-27</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2021-05-31 10:41:12" itemprop="dateModified" datetime="2021-05-31T10:41:12+08:00">2021-05-31</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="第一个shell脚本"><a href="#第一个shell脚本" class="headerlink" title="第一个shell脚本"></a>第一个shell脚本</h2><p>新建一个文件 test.sh，扩展名为 sh（sh代表shell），扩展名并不影响脚本执行。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Hello Word!&quot;</span></span><br></pre></td></tr></table></figure>



<p>#! 是一个约定的标记，它告诉系统这个脚本需要什么解释器来执行，即使用哪一种 Shell。</p>
<p>echo 命令用于向窗口输出文本。</p>
<h3 id="运行-Shell-脚本有两种方法："><a href="#运行-Shell-脚本有两种方法：" class="headerlink" title="运行 Shell 脚本有两种方法："></a>运行 Shell 脚本有两种方法：</h3><p><strong>1、作为可执行程序</strong></p>
<p>将上面的代码保存为 test.sh，并 cd 到相应目录：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod +x ./test.sh  #使脚本具有执行权限</span><br><span class="line">./test.sh  #执行脚本</span><br></pre></td></tr></table></figure>


<p>注意，一定要写成 ./test.sh，而不是 test.sh，运行其它二进制的程序也一样，直接写 test.sh，linux 系统会去 PATH 里寻找有没有叫 test.sh 的，而只有 /bin, /sbin, /usr/bin，/usr/sbin 等在 PATH 里，你的当前目录通常不在 PATH 里，所以写成 test.sh 是会找不到命令的，<strong>要用 ./test.sh 告诉系统说，就在当前目录找</strong>。</p>
<p><strong>2、作为解释器参数</strong></p>
<p>这种运行方式是，直接运行解释器，其参数就是 shell 脚本的文件名，如：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/bin/sh test.sh</span><br><span class="line">/bin/php test.php</span><br></pre></td></tr></table></figure>

<p>这种方式运行的脚本，不需要在第一行指定解释器信息，写了也没用。</p>
<h2 id="Shell-变量"><a href="#Shell-变量" class="headerlink" title="Shell 变量"></a>Shell 变量</h2><p>定义变量时，变量名不加美元符号（$，PHP语言中变量需要），如：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">your_name=<span class="string">&quot;runoob.com&quot;</span></span><br></pre></td></tr></table></figure>

<p>注意，变量名和等号之间不能有空格，这可能和你熟悉的所有编程语言都不一样。同时，变量名的命名须遵循如下规则：</p>
<ul>
<li>命名只能使用英文字母，数字和下划线，首个字符不能以数字开头。</li>
<li>中间不能有空格，可以使用下划线（_）。</li>
<li>不能使用标点符号。</li>
<li>不能使用bash里的关键字（可用help命令查看保留关键字）。</li>
</ul>
<p>除了显式地直接赋值，还可以用语句给变量赋值，如：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> file <span class="keyword">in</span> `ls /etc`</span><br><span class="line">或</span><br><span class="line"><span class="keyword">for</span> file <span class="keyword">in</span> $(ls /etc)</span><br></pre></td></tr></table></figure>

<p>以上语句将 /etc 下目录的文件名循环出来。???</p>
<h3 id="使用变量"><a href="#使用变量" class="headerlink" title="使用变量"></a>使用变量</h3><p>使用一个定义过的变量，只要在变量名前面加美元符号即可，如：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">your_name=<span class="string">&quot;qinjx&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$your_name</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;your_name&#125;</span></span><br></pre></td></tr></table></figure>

<p>变量名外面的花括号是可选的，加不加都行，加花括号是为了帮助解释器识别变量的边界，比如下面这种情况：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> skill <span class="keyword">in</span> Ada Coffe Action Java; <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;I am good at <span class="variable">$&#123;skill&#125;</span>Script&quot;</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<p>如果不给skill变量加花括号，写成echo “I am good at $skillScript”，解释器就会把$skillScript当成一个变量（其值为空），代码执行结果就不是我们期望的样子了。</p>
<p>推荐给所有变量加上花括号，这是个好的编程习惯。</p>
<p>已定义的变量，可以被重新定义，如：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">your_name=<span class="string">&quot;tom&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$your_name</span></span><br><span class="line">your_name=<span class="string">&quot;alibaba&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$your_name</span></span><br></pre></td></tr></table></figure>

<p>这样写是合法的，但注意，第二次赋值的时候不能写$your_name=”alibaba”，使用变量的时候才加美元符（$）。</p>
<h3 id="只读变量"><a href="#只读变量" class="headerlink" title="只读变量"></a>只读变量</h3><p>使用 <code>readonly </code>命令可以将变量定义为只读变量，只读变量的值不能被改变。</p>
<p>下面的例子尝试更改只读变量，结果报错：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">myUrl=<span class="string">&quot;https://www.google.com&quot;</span></span><br><span class="line"><span class="built_in">readonly</span> myUrl</span><br><span class="line">myUrl=<span class="string">&quot;https://www.runoob.com&quot;</span></span><br></pre></td></tr></table></figure>

<p>运行脚本，结果如下：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/bin/sh: NAME: This variable is <span class="built_in">read</span> only.</span><br></pre></td></tr></table></figure>

<h3 id="删除变量"><a href="#删除变量" class="headerlink" title="删除变量"></a>删除变量</h3><p>使用 <code>unset </code>命令可以删除变量。语法：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">unset</span> variable_name</span><br></pre></td></tr></table></figure>

<p>变量被删除后不能再次使用。<strong>unset 命令不能删除只读变量。</strong></p>
<h3 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h3><p>运行shell时，会同时存在三种变量：</p>
<ul>
<li><strong>1) 局部变量</strong> 局部变量在脚本或命令中定义，仅在当前shell实例中有效，其他shell启动的程序不能访问局部变量。</li>
<li><strong>2) 环境变量</strong> 所有的程序，包括shell启动的程序，都能访问环境变量，有些程序需要环境变量来保证其正常运行。必要的时候shell脚本也可以定义环境变量。</li>
<li><strong>3) shell变量</strong> shell变量是由shell程序设置的特殊变量。shell变量中有一部分是环境变量，有一部分是局部变量，这些变量保证了shell的正常运行</li>
</ul>
<h2 id="Shell-字符串"><a href="#Shell-字符串" class="headerlink" title="Shell 字符串"></a>Shell 字符串</h2><p>字符串是shell编程中最常用最有用的数据类型（除了数字和字符串，也没啥其它类型好用了），字符串可以用单引号，也可以用双引号，也可以不用引号。</p>
<h3 id="单引号"><a href="#单引号" class="headerlink" title="单引号"></a>单引号</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str=<span class="string">&#x27;this is a string&#x27;</span></span><br></pre></td></tr></table></figure>

<p>单引号字符串的限制：</p>
<ul>
<li>单引号里的任何字符都会原样输出，单引号字符串中的变量是无效的；</li>
<li>单引号字串中<strong>不能出现单独一个的单引号（对单引号使用转义符后也不行），但可成对出现，作为字符串拼接使用。</strong>???</li>
</ul>
<h3 id="双引号"><a href="#双引号" class="headerlink" title="双引号"></a>双引号</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">your_name=<span class="string">&#x27;runoob&#x27;</span></span><br><span class="line">str=<span class="string">&quot;Hello, I know you are \&quot;<span class="variable">$your_name</span>\&quot;! \n&quot;</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="variable">$str</span></span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello, I know you are <span class="string">&quot;runoob&quot;</span>! </span><br></pre></td></tr></table></figure>

<p>双引号的优点：</p>
<ul>
<li><strong>双引号里可以有变量</strong></li>
<li><strong>双引号里可以出现转义字符</strong></li>
</ul>
<h3 id="拼接字符串"><a href="#拼接字符串" class="headerlink" title="拼接字符串"></a>拼接字符串</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">your_name=<span class="string">&quot;runoob&quot;</span></span><br><span class="line"><span class="comment"># 使用双引号拼接</span></span><br><span class="line">greeting=<span class="string">&quot;hello, &quot;</span><span class="variable">$your_name</span><span class="string">&quot; !&quot;</span></span><br><span class="line">greeting_1=<span class="string">&quot;hello, <span class="variable">$&#123;your_name&#125;</span> !&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$greeting</span>  <span class="variable">$greeting_1</span></span><br><span class="line"><span class="comment"># 使用单引号拼接</span></span><br><span class="line">greeting_2=<span class="string">&#x27;hello, &#x27;</span><span class="variable">$your_name</span><span class="string">&#x27; !&#x27;</span></span><br><span class="line">greeting_3=<span class="string">&#x27;hello, $&#123;your_name&#125; !&#x27;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$greeting_2</span>  <span class="variable">$greeting_3</span></span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hello, runoob ! hello, runoob !</span><br><span class="line">hello, runoob ! hello, <span class="variable">$&#123;your_name&#125;</span> !</span><br></pre></td></tr></table></figure>

<h3 id="获取字符串长度"><a href="#获取字符串长度" class="headerlink" title="获取字符串长度"></a>获取字符串长度</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string=<span class="string">&quot;abcd&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;#string&#125;</span> <span class="comment">#输出 4</span></span><br></pre></td></tr></table></figure>

<h3 id="提取子字符串"><a href="#提取子字符串" class="headerlink" title="提取子字符串"></a>提取子字符串</h3><p>以下实例从字符串第 <strong>2</strong> 个字符开始截取 <strong>4</strong> 个字符：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string=<span class="string">&quot;runoob is a great site&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;string:1:4&#125;</span> <span class="comment"># 输出 unoo</span></span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：第一个字符的索引值为 <strong>0</strong>。</p>
<h3 id="查找子字符串"><a href="#查找子字符串" class="headerlink" title="查找子字符串"></a>查找子字符串</h3><p>查找字符 <strong>i</strong> 或 <strong>o</strong> 的位置(哪个字母先出现就计算哪个)：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string=<span class="string">&quot;runoob is a great site&quot;</span></span><br><span class="line"><span class="built_in">echo</span> `expr index <span class="string">&quot;<span class="variable">$string</span>&quot;</span> io`  <span class="comment"># 输出 4</span></span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong> 以上脚本中 <strong>`</strong> 是反引号，而不是单引号 **’**，不要看错了哦。</p>
<h2 id="Shell-数组"><a href="#Shell-数组" class="headerlink" title="Shell 数组"></a>Shell 数组</h2><p>bash支持一维数组（不支持多维数组），并且没有限定数组的大小。</p>
<p>类似于 C 语言，数组元素的下标由 0 开始编号。获取数组中的元素要利用下标，下标可以是整数或算术表达式，其值应大于或等于 0。</p>
<h3 id="定义数组"><a href="#定义数组" class="headerlink" title="定义数组"></a>定义数组</h3><p>在 Shell 中，用括号来表示数组，数组元素用”空格”符号分割开。定义数组的一般形式为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数组名&#x3D;(值1 值2 ... 值n)</span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array_name=(value0 value1 value2 value3)</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">array_name=(</span><br><span class="line">value0</span><br><span class="line">value1</span><br><span class="line">value2</span><br><span class="line">value3</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>还可以单独定义数组的各个分量：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">array_name[0]=value0</span><br><span class="line">array_name[1]=value1</span><br><span class="line">array_name[n]=valuen</span><br></pre></td></tr></table></figure>

<p>可以不使用连续的下标，而且下标的范围没有限制。</p>
<h3 id="读取数组"><a href="#读取数组" class="headerlink" title="读取数组"></a>读取数组</h3><p>读取数组元素值的一般格式是：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$&#123;数组名[下标]&#125;</span></span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">valuen=<span class="variable">$&#123;array_name[n]&#125;</span></span><br></pre></td></tr></table></figure>

<p>使用 <strong>@</strong> 符号可以获取数组中的所有元素，例如：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;array_name[@]&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="获取数组的长度"><a href="#获取数组的长度" class="headerlink" title="获取数组的长度"></a>获取数组的长度</h3><p>获取数组长度的方法与获取字符串长度的方法相同，例如：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 取得数组元素的个数</span></span><br><span class="line">length=<span class="variable">$&#123;#array_name[@]&#125;</span></span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">length=<span class="variable">$&#123;#array_name[*]&#125;</span></span><br><span class="line"><span class="comment"># 取得数组单个元素的长度</span></span><br><span class="line">lengthn=<span class="variable">$&#123;#array_name[n]&#125;</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="Shell-注释"><a href="#Shell-注释" class="headerlink" title="Shell 注释"></a>Shell 注释</h2><p>以 <strong>#</strong> 开头的行就是注释，会被解释器忽略。</p>
<p>通过每一行加一个 <strong>#</strong> 号设置多行注释，像这样：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#--------------------------------------------</span></span><br><span class="line"><span class="comment"># 这是一个注释</span></span><br><span class="line"><span class="comment"># author：菜鸟教程</span></span><br><span class="line"><span class="comment"># site：www.runoob.com</span></span><br><span class="line"><span class="comment"># slogan：学的不仅是技术，更是梦想！</span></span><br><span class="line"><span class="comment">#--------------------------------------------</span></span><br><span class="line"><span class="comment">##### 用户配置区 开始 #####</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 这里可以添加脚本描述信息</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">##### 用户配置区 结束  #####</span></span><br></pre></td></tr></table></figure>

<p>如果在开发过程中，遇到大段的代码需要临时注释起来，过一会儿又取消注释，怎么办呢？</p>
<p>每一行加个#符号太费力了，可以把这一段要注释的代码用一对花括号括起来，定义成一个函数，没有地方调用这个函数，这块代码就不会执行，达到了和注释一样的效果。</p>
<h3 id="多行注释"><a href="#多行注释" class="headerlink" title="多行注释"></a>多行注释</h3><p>多行注释还可以使用以下格式：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">:&lt;&lt;<span class="string">EOF</span></span><br><span class="line"><span class="string">注释内容...</span></span><br><span class="line"><span class="string">注释内容...</span></span><br><span class="line"><span class="string">注释内容...</span></span><br><span class="line"><span class="string">EOF</span></span><br></pre></td></tr></table></figure>

<p>EOF 也可以使用其他符号:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">:&lt;&lt;<span class="string">&#x27;</span></span><br><span class="line"><span class="string">注释内容...</span></span><br><span class="line"><span class="string">注释内容...</span></span><br><span class="line"><span class="string">注释内容...</span></span><br><span class="line"><span class="string">&#x27;</span></span><br><span class="line"></span><br><span class="line">:&lt;&lt;!</span><br><span class="line">注释内容...</span><br><span class="line">注释内容...</span><br><span class="line">注释内容...</span><br><span class="line">!</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://wenwenhuan.gitee.io/2021/05/23/Linux%E9%83%A8%E7%BD%B2nodejs%E9%A1%B9%E7%9B%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="温文焕">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wenhuan Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/05/23/Linux%E9%83%A8%E7%BD%B2nodejs%E9%A1%B9%E7%9B%AE/" class="post-title-link" itemprop="url">Linux部署nodejs项目</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-05-23 01:07:07 / 修改时间：01:41:48" itemprop="dateCreated datePublished" datetime="2021-05-23T01:07:07+08:00">2021-05-23</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="第一步、设置代理"><a href="#第一步、设置代理" class="headerlink" title="第一步、设置代理"></a>第一步、设置代理</h2><p>安装nvm需要翻墙，虚拟机里面设置代理较麻烦。</p>
<ul>
<li><p>打开代理软件勾选允许来自局域网的连接</p>
</li>
<li><p>测试Linux中是否可以连接<code>curl http://(主机地址)：（代理端口） </code></p>
</li>
<li><p>在Linux中编写脚本设置环境变量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export http_proxy&#x3D;http:&#x2F;&#x2F;(主机地址)：（代理端口）      # shorter, less portable version</span><br><span class="line">export https_proxy&#x3D;$http_proxy</span><br><span class="line">export all_proxy&#x3D;$http_proxy</span><br></pre></td></tr></table></figure></li>
<li><p>打开代理<code>. ~/proxy.sh</code></p>
</li>
</ul>
<h2 id="第二步、安装nvm（Node-Version-Manager-）"><a href="#第二步、安装nvm（Node-Version-Manager-）" class="headerlink" title="第二步、安装nvm（Node Version Manager ）"></a>第二步、安装nvm（Node Version Manager ）</h2><p><a target="_blank" rel="noopener" href="https://github.com/nvm-sh/nvm#usage%E4%B8%8A%E6%9C%89%E8%AF%A6%E7%BB%86%E6%AD%A5%E9%AA%A4%EF%BC%8C%E5%8C%85%E6%8B%AC%E4%B9%8B%E5%90%8Enode%E7%9A%84%E5%AE%89%E8%A3%85">https://github.com/nvm-sh/nvm#usage上有详细步骤，包括之后node的安装</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -o- https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;nvm-sh&#x2F;nvm&#x2F;v0.38.0&#x2F;install.sh | bash</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>curl</strong>:用来请求 Web 服务器。它的名字就是客户端（client）的 URL 工具的意思。通过参数可以指定请求的信息，例如get/post请求（默认为get）</li>
<li><strong>-o</strong>：参数将服务器回应保存成文件，并将 URL 的最后部分当作文件名。</li>
<li>**|**：管道相关</li>
<li>**-o-**：</li>
</ul>
<p>这句命令的大概意思是向url发出请求并把返回内容通过管道输入到bash。</p>
<p>安装这个工具是因为Linux本身的包管理工具里面node版本很低。用nvm可以安装所需要的node14版本</p>
<h2 id="第三步、安装新版本node"><a href="#第三步、安装新版本node" class="headerlink" title="第三步、安装新版本node"></a>第三步、安装新版本node</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvm install 14 # or 10.10.0, 8.9.1, etc</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://wenwenhuan.gitee.io/2021/05/19/Java%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="温文焕">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wenhuan Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/05/19/Java%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/" class="post-title-link" itemprop="url">Java的垃圾回收机制</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-05-19 23:49:40" itemprop="dateCreated datePublished" datetime="2021-05-19T23:49:40+08:00">2021-05-19</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2021-05-20 01:43:02" itemprop="dateModified" datetime="2021-05-20T01:43:02+08:00">2021-05-20</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><hr>
<ul>
<li>JVM 内存模型一共包括三个部分：<ul>
<li>堆 ( Java代码可及的 Java堆 和 JVM自身使用的方法区)、</li>
<li>栈 ( 服务Java方法的虚拟机栈 和 服务Native方法的本地方法栈 )</li>
<li>保证程序在多线程环境下能够连续执行的程序计数器</li>
</ul>
</li>
</ul>
<p>Java堆是进行垃圾回收的主要区域，故其也被称为GC堆，堆 (包括Java堆 和 方法区)是垃圾回收的主要对象，特别是Java堆。</p>
<p>实际上，Java技术体系中所提倡的自动内存管理最终可以归结为自动化地解决了两个问题：给对象分配内存以及回收分配给对象的内存，而且这两个问题针对的内存区域就是Java内存模型中的堆区。垃圾回收机制是Java语言一个显著的特点，其可以有效的<strong>防止内存泄露、保证内存的有效使用</strong>，从而使得Java程序员在编写程序的时候不再需要考虑内存管理问题。Java 垃圾回收机制要考虑的问题很复杂，本文阐述了其三个核心问题</p>
<p>包括：</p>
<ul>
<li><strong>那些内存需要回收？(对象是否可以被回收的两种经典算法: 引用计数法 和 可达性分析算法)</strong></li>
<li><strong>什么时候回收？ （堆的新生代、老年代、永久代的垃圾回收时机，MinorGC 和 FullGC）</strong></li>
<li><strong>如何回收？(三种经典垃圾回收算法(标记清除算法、复制算法、标记整理算法)及分代收集算法 和 七种垃圾收集器)</strong></li>
</ul>
<blockquote>
<p>在探讨Java垃圾回收机制之前，我们首先应该记住一个单词：<strong>Stop-the-World</strong>。Stop-the-world意味着<br>JVM由于要执行GC而停止了应用程序的执行，并且这种情形会在任何一种GC算法中发生。当Stop-the-world发生时，除了GC所需的线程以外，所有线程都处于等待状态直到GC任务完成。事实上，<strong>GC优化很多时候就是指减少Stop-the-world发生的时间</strong>，从而使系统具有<strong>高吞吐 、低停顿</strong>的特点<br>Ps: <strong>内存泄露是指该内存空间使用完毕之后未回收</strong>，在不涉及复杂数据结构的一般情况下，Java 的内存泄露表现为一个内存对象的生命周期超出了程序需要它的时间长度。</p>
</blockquote>
<h2 id="如何确定一个对象是否可以被回收？"><a href="#如何确定一个对象是否可以被回收？" class="headerlink" title="如何确定一个对象是否可以被回收？"></a>如何确定一个对象是否可以被回收？</h2><hr>
<h2 id="引用计数算法：判断对象的引用数量"><a href="#引用计数算法：判断对象的引用数量" class="headerlink" title="引用计数算法：判断对象的引用数量"></a>引用计数算法：判断对象的引用数量</h2><hr>
<ul>
<li><strong>引用计数算法是通过判断对象的引用数量来决定对象是否可以被回收。</strong></li>
</ul>
<p><strong>引用计数算法是垃圾收集器中的早期策略。在这种方法中，堆中的每个对象实例都有一个引用计数。</strong></p>
<ul>
<li>当一个对象被创建时，且将该对象实例分配给一个引用变量，该对象实例的引用计数设置为 1。</li>
<li>当任何其它变量被赋值为这个对象的引用时，对象实例的引用计数加 1（a = b，则b引用的对象实例的计数器加 1），</li>
<li>但当一个对象实例的某个引用超过了生命周期或者被设置为一个新值时，对象实例的引用计数减 1。</li>
<li>特别地，当一个对象实例被垃圾收集时，它引用的任何对象实例的引用计数器均减 1。任何引用计数为0的对象实例可以被当作垃圾收集。</li>
</ul>
<p>引用计数收集器可以很快的执行，并且交织在程序运行中，对程序需要不被长时间打断的实时环境比较有利，但其很难解决对象之间相互循环引用的问题。如下面的程序和示意图所示，对象objA和objB之间的引用计数永远不可能为 0，那么这两个对象就永远不能被回收。</p>
<img src="/2021/05/19/Java%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/423143115-310ae9452d1c07c2_fix732" class="" title="img">

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReferenceCountingGC</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> Object instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testGC</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">            ReferenceCountingGC objA = <span class="keyword">new</span> ReferenceCountingGC ();</span><br><span class="line">            ReferenceCountingGC objB = <span class="keyword">new</span> ReferenceCountingGC ();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 对象之间相互循环引用，对象objA和objB之间的引用计数永远不可能为 0</span></span><br><span class="line">            objB.instance = objA;</span><br><span class="line">            objA.instance = objB;</span><br><span class="line"></span><br><span class="line">            objA = <span class="keyword">null</span>;</span><br><span class="line">            objB = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">            System.gc();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码最后面两句将objA和objB赋值为null，也就是说objA和objB指向的对象已经不可能再被访问，但是由于它们互相引用对方，导致它们的引用计数器都不为 0，那么垃圾收集器就永远不会回收它们。</p>
<h2 id="可达性分析算法：判断对象的引用链是否可达"><a href="#可达性分析算法：判断对象的引用链是否可达" class="headerlink" title="可达性分析算法：判断对象的引用链是否可达"></a>可达性分析算法：判断对象的引用链是否可达</h2><ul>
<li><strong>可达性分析算法是通过判断对象的引用链是否可达来决定对象是否可以被回收。</strong></li>
</ul>
<p>可达性分析算法是从离散数学中的图论引入的，程序把所有的引用关系看作一张图，通过一系列的名为 “GC Roots” 的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain）。当一个对象到 GC Roots 没有任何引用链相连（用图论的话来说就是从 GC Roots 到这个对象不可达）时，则证明此对象是不可用的，如下图所示。在Java中，可作为 GC Root 的对象包括以下几种：</p>
<ul>
<li>虚拟机栈(栈帧中的局部变量表)中引用的对象；</li>
<li>方法区中类静态属性引用的对象；</li>
<li>方法区中常量引用的对象；</li>
<li>本地方法栈中Native方法引用的对象；</li>
</ul>
<img src="/2021/05/19/Java%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/911576013-2a68e02a67a17c0a_fix732" class="" title="img">

<h2 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h2><hr>
<h2 id="标记清除算法"><a href="#标记清除算法" class="headerlink" title="标记清除算法"></a>标记清除算法</h2><hr>
<p><strong>标记-清除算法分为标记和清除两个阶段。该算法首先从根集合进行扫描，对存活的对象对象标记，标记完毕后，再扫描整个空间中未被标记的对象并进行回收，如下图所示。</strong></p>
<img src="/2021/05/19/Java%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/3268013027-f2d85229debd322b_fix732" class="" title="img">

<p>标记-清除算法的主要不足有两个：</p>
<p>效率问题：标记和清除两个过程的效率都不高;</p>
<p>空间问题：标记-清除算法不需要进行对象的移动，并且仅对不存活的对象进行处理，因此标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。</p>
<img src="/2021/05/19/Java%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/23140115-f9a1ccdd3cc7bdcf" class="" title="img">

<h2 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h2><hr>
<p>复制算法将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。这种<strong>算法适用于对象存活率低的场景</strong>，比如新生代。这样使得每次都是对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。该算法示意图如下所示：</p>
<img src="/2021/05/19/Java%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/3200468268-2b60abc2e479515b_fix732" class="" title="img">

<p>　　<strong>事实上，现在商用的虚拟机都采用这种算法来回收新生代。因为研究发现，新生代中的对象每次回收都基本上只有10%左右的对象存活，所以需要复制的对象很少，效率还不错</strong>。正如在博文《JVM 内存模型概述》中介绍的那样，实践中会将新生代内存分为一块较大的Eden空间和两块较小的Survivor空间 (如下图所示)，每次使用Eden和其中一块Survivor。当回收时，将Eden和Survivor中还存活着的对象一次地复制到另外一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor空间。HotSpot虚拟机默认Eden和Survivor的大小比例是 8:1，也就是每次新生代中可用内存空间为整个新生代容量的90% ( 80%+10% )，只有10% 的内存会被“浪费”。</p>
<img src="/2021/05/19/Java%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/981952109-ee03dbce37f93dbf_fix732" class="" title="img">

<h2 id="标记整理算法"><a href="#标记整理算法" class="headerlink" title="标记整理算法"></a>标记整理算法</h2><hr>
<p>复制收集算法在对象存活率较高时就要进行较多的复制操作，效率将会变低。更关键的是，如果不想浪费50%的空间，就需要有额外的空间进行分配担保，以应对被使用的内存中所有对象都100%存活的极端情况，所以在老年代一般不能直接选用这种算法。标记整理算法的标记过程类似标记清除算法，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存，类似于磁盘整理的过程，该垃圾回收算法适用于对象存活率高的场景（老年代），其作用原理如下图所示。</p>
<img src="/2021/05/19/Java%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/713578178-a38ee8b917afcbb5_fix732" class="" title="img">

<p>　　标记整理算法与标记清除算法最显著的区别是：标记清除算法不进行对象的移动，并且仅对不存活的对象进行处理；而标记整理算法会将所有的存活对象移动到一端，并对不存活对象进行处理，因此其不会产生内存碎片。标记整理算法的作用示意图如下：</p>
<img src="/2021/05/19/Java%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/3957502137-36ed280209f6acb9_fix732" class="" title="img">

<h2 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h2><hr>
<p>对于一个大型的系统，当创建的对象和方法变量比较多时，堆内存中的对象也会比较多，如果逐一分析对象是否该回收，那么势必造成效率低下。<br>　　分代收集算法是基于这样一个事实：不同的对象的生命周期(存活情况)是不一样的，而不同生命周期的对象位于堆中不同的区域，因此对堆内存不同区域采用不同的策略进行回收可以提高 JVM 的执行效率。<br>　　当代商用虚拟机使用的都是分代收集算法：新生代对象存活率低，就采用复制算法；老年代存活率高，就用标记清除算法或者标记整理算法。<strong>Java堆内存一般可以分为新生代、老年代和永久代三个模块</strong>，如下图所示：</p>
<img src="/2021/05/19/Java%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/1650438907-2dde27f173dc5539_fix732" class="" title="img">

<h2 id="新生代（Young-Generation）"><a href="#新生代（Young-Generation）" class="headerlink" title="新生代（Young Generation）"></a>新生代（Young Generation）</h2><hr>
<p><strong>新生代的目标就是尽可能快速的收集掉那些生命周期短的对象，一般情况下，所有新生成的对象首先都是放在新生代的</strong>。<br>　　新生代内存按照 8:1:1 的比例分为一个eden区和两个survivor(survivor0，survivor1)区，大部分对象在Eden区中生成。在进行垃圾回收时，先将eden区存活对象复制到survivor0区，然后清空eden区，当这个survivor0区也满了时，则将eden区和survivor0区存活对象复制到survivor1区，然后清空eden和这个survivor0区，此时survivor0区是空的，然后交换survivor0区和survivor1区的角色（即下次垃圾回收时会扫描Eden区和survivor1区），即保持survivor0区为空，如此往复。特别地，当survivor1区也不足以存放eden区和survivor0区的存活对象时，就将存活对象直接存放到老年代。<br>　　<strong>如果老年代也满了，就会触发一次FullGC，也就是新生代、老年代都进行回收。注意，新生代发生的GC也叫做MinorGC，MinorGC发生频率比较高，不一定等 Eden区满了才触发。</strong></p>
<h2 id="老年代（Old-Generation）"><a href="#老年代（Old-Generation）" class="headerlink" title="老年代（Old Generation）"></a>老年代（Old Generation）</h2><hr>
<p><strong>老年代存放的都是一些生命周期较长的对象，就像上面所叙述的那样，在新生代中经历了N次垃圾回收后仍然存活的对象就会被放到老年代中。</strong><br>　　此外，老年代的内存也比新生代大很多(大概比例是1:2)，当老年代满时会触发Major GC(Full GC)，老年代对象存活时间比较长，因此FullGC发生的频率比较低。</p>
<h2 id="永久代（Permanent-Generation）"><a href="#永久代（Permanent-Generation）" class="headerlink" title="永久代（Permanent Generation）"></a>永久代（Permanent Generation）</h2><hr>
<p><strong>永久代主要用于存放静态文件，如Java类、方法等。</strong><br>　　永久代对垃圾回收没有显著影响，但是有些应用可能动态生成或者调用一些class，例如使用反射、动态代理、CGLib等bytecode框架时，在这种时候需要设置一个比较大的永久代空间来存放这些运行过程中新增的类。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><hr>
<p>由于对象进行了分代处理，因此垃圾回收区域、时间也不一样。垃圾回收有两种类型，Minor GC 和 Full GC</p>
<h2 id="Minor-GC："><a href="#Minor-GC：" class="headerlink" title="Minor GC："></a>Minor GC：</h2><hr>
<p>对新生代进行回收，不会影响到年老代。因为新生代的 Java 对象大多死亡频繁，所以 Minor GC 非常频繁，一般在这里使用速度快、效率高的算法，使垃圾回收能尽快完成。</p>
<h2 id="Full-GC："><a href="#Full-GC：" class="headerlink" title="Full GC："></a>Full GC：</h2><hr>
<p>也叫 Major GC，对整个堆进行回收，包括新生代、老年代和永久代。由于Full GC需要对整个堆进行回收，所以比Minor GC要慢，因此应该尽可能减少Full GC的次数，导致Full GC的原因包括：老年代被写满、永久代（Perm）被写满和System.gc()被显式调用等。</p>
<h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><hr>
<p>如果说垃圾收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。下图展示了7种作用于不同分代的收集器，其中用于回收新生代的收集器包括Serial、PraNew、Parallel Scavenge，回收老年代的收集器包括Serial Old、Parallel Old、CMS，还有用于回收整个Java堆的G1收集器。不同收集器之间的连线表示它们可以搭配使用。</p>
<img src="/2021/05/19/Java%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/673083256-d9263d736171b54e_fix732" class="" title="img">

<h2 id="内存分配与回收策略"><a href="#内存分配与回收策略" class="headerlink" title="内存分配与回收策略"></a>内存分配与回收策略</h2><hr>
<p>Java技术体系中所提倡的自动内存管理最终可以归结为自动化地解决了两个问题：给对象分配内存 以及 回收分配给对象的内存。一般而言，对象主要分配在新生代的Eden区上，如果启动了本地线程分配缓存(TLAB)，将按线程优先在TLAB上分配。少数情况下也可能直接分配在老年代中。总的来说，内存分配规则并不是一层不变的，其细节取决于当前使用的是哪一种垃圾收集器组合，还有虚拟机中与内存相关的参数的设置。</p>
<h2 id="对象优先在Eden分配，当Eden区没有足够空间进行分配时，虚拟机将发起一次MinorGC。"><a href="#对象优先在Eden分配，当Eden区没有足够空间进行分配时，虚拟机将发起一次MinorGC。" class="headerlink" title="对象优先在Eden分配，当Eden区没有足够空间进行分配时，虚拟机将发起一次MinorGC。"></a>对象优先在Eden分配，当Eden区没有足够空间进行分配时，虚拟机将发起一次MinorGC。</h2><hr>
<p>现在的商业虚拟机一般都采用复制算法来回收新生代，将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor。 <strong>当进行垃圾回收时，将Eden和Survivor中还存活的对象一次性地复制到另外一块Survivor空间上，最后处理掉Eden和刚才的Survivor空间。</strong>（HotSpot虚拟机默认Eden和Survivor的大小比例是8:1）当Survivor空间不够用时，需要依赖老年代进行分配担保。</p>
<h2 id="大对象直接进入老年代。"><a href="#大对象直接进入老年代。" class="headerlink" title="大对象直接进入老年代。"></a>大对象直接进入老年代。</h2><hr>
<p>所谓的大对象是指，需要大量连续内存空间的Java对象，最典型的大对象就是那种很长的字符串以及数组。</p>
<h2 id="长期存活的对象将进入老年代。"><a href="#长期存活的对象将进入老年代。" class="headerlink" title="长期存活的对象将进入老年代。"></a>长期存活的对象将进入老年代。</h2><hr>
<p>当对象在新生代中经历过一定次数（默认为15）的Minor GC后，就会被晋升到老年代中。</p>
<h2 id="动态对象年龄判定。"><a href="#动态对象年龄判定。" class="headerlink" title="动态对象年龄判定。"></a>动态对象年龄判定。</h2><hr>
<p>为了更好地适应不同程序的内存状况，虚拟机并不是永远地要求对象年龄必须达到了MaxTenuringThreshold才能晋升老年代，如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到MaxTenuringThreshold中要求的年龄。</p>
<p>需要注意的是，Java的垃圾回收机制是Java虚拟机提供的能力，用于在空闲时间以不定时的方式动态回收无任何引用的对象占据的内存空间。也就是说，<strong>垃圾收集器回收的是无任何引用的对象占据的内存空间而不是对象本身</strong></p>
<p>参考：<a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000023637649">https://segmentfault.com/a/1190000023637649</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://wenwenhuan.gitee.io/2021/05/17/JVM%E5%86%85%E5%AD%98%E5%88%86%E6%9E%90-stack-heap-and-method-area/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="温文焕">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wenhuan Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/05/17/JVM%E5%86%85%E5%AD%98%E5%88%86%E6%9E%90-stack-heap-and-method-area/" class="post-title-link" itemprop="url">JVM内存分析-stack, heap and method area</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-05-17 16:36:57 / 修改时间：16:46:08" itemprop="dateCreated datePublished" datetime="2021-05-17T16:36:57+08:00">2021-05-17</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="JVM的内存分为三个区域："><a href="#JVM的内存分为三个区域：" class="headerlink" title="JVM的内存分为三个区域："></a>JVM的内存分为三个区域：</h2><ul>
<li>栈 stack</li>
<li>堆 heap</li>
<li>方法区 method area</li>
</ul>
<h2 id="栈-stack（连续的内存空间）"><a href="#栈-stack（连续的内存空间）" class="headerlink" title="栈 stack（连续的内存空间）"></a>栈 stack（连续的内存空间）</h2><ul>
<li>方法执行的内存模型。是一个连续的内存空间。</li>
<li>JVM为每个线程创建一个栈。<strong>栈属于线程私有，不能共享</strong>。？？？线程如何共享信息？？？</li>
<li>每个方法调用都会创建一个栈帧</li>
<li>特点： 先进后出，后进先出</li>
</ul>
<h2 id="堆-heap（不连续的内存空间）"><a href="#堆-heap（不连续的内存空间）" class="headerlink" title="堆 heap（不连续的内存空间）"></a>堆 heap（不连续的内存空间）</h2><ul>
<li>存储对象</li>
<li>JVM只有一个堆，被所有线程共享！！！线程共享信息的方式！！！</li>
<li>不连续的内存空间。</li>
</ul>
<h2 id="方法区-method-area"><a href="#方法区-method-area" class="headerlink" title="方法区 method area"></a>方法区 method area</h2><ul>
<li>堆的一部分</li>
<li>存储类信息中<strong>不变或者唯一的内容</strong><ul>
<li>代码</li>
<li>静态变量</li>
<li>静态方法</li>
<li>String常量</li>
</ul>
</li>
</ul>
<h1 id="举例-图示"><a href="#举例-图示" class="headerlink" title="举例+图示"></a>举例+图示</h1><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;</span><br><span class="line">	String name;</span><br><span class="line">	<span class="keyword">int</span> age;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(name + <span class="string">&quot; : &quot;</span> + age);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JvmStackHeapSample</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> averageAge = <span class="number">28</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Student student = <span class="keyword">new</span> Student();</span><br><span class="line">		student.name = <span class="string">&quot;ryan&quot;</span>;</span><br><span class="line">		student.age = averageAge;</span><br><span class="line">		student.show();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">anyMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><ul>
<li>运行程序，<strong>首先使用方法区加载类信息</strong><ul>
<li>代码</li>
<li>静态变量</li>
<li>静态方法</li>
<li>String常量</li>
</ul>
</li>
<li>开始执行 main 方法，<strong>创建main()栈帧</strong></li>
<li>创建局部变量 student = null</li>
<li>在堆里创建Student类对象，调用构造器初始化对象</li>
<li>将新建对象的地址赋值给student</li>
<li>将String常量“ryan”赋值给student.name</li>
<li>将静态变量averageAge赋值给student.age</li>
<li>调用student.show(),创建show()栈帧</li>
<li>打印: name + “ : “ + age</li>
<li>销毁show()栈帧</li>
<li>销毁main()栈帧</li>
</ul>
<img src="/2021/05/17/JVM%E5%86%85%E5%AD%98%E5%88%86%E6%9E%90-stack-heap-and-method-area/JVM%E5%86%85%E5%AD%98%E5%88%86%E6%9E%90.png" class="" title="JVM内存">

<p>参考：<a target="_blank" rel="noopener" href="https://ryanluoxu.github.io/2019/02/24/JVM%E5%86%85%E5%AD%98%E5%88%86%E6%9E%90-stack-heap-and-method-area/">https://ryanluoxu.github.io/2019/02/24/JVM%E5%86%85%E5%AD%98%E5%88%86%E6%9E%90-stack-heap-and-method-area/</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://wenwenhuan.gitee.io/2021/05/17/How-many-types-of-memory-areas-are-allocated-by-JVM/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="温文焕">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wenhuan Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/05/17/How-many-types-of-memory-areas-are-allocated-by-JVM/" class="post-title-link" itemprop="url">How many types of memory areas are allocated by JVM?</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-05-17 15:45:09 / 修改时间：17:09:16" itemprop="dateCreated datePublished" datetime="2021-05-17T15:45:09+08:00">2021-05-17</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><strong>JVM (Java Virtual Machine)</strong> is an abstract machine, In other words, it is a program/software which takes Java bytecode and converts the bytecode (line by line) into machine understandable code.</p>
<h3 id="JVM-perform-some-particular-types-of-operations"><a href="#JVM-perform-some-particular-types-of-operations" class="headerlink" title="JVM perform some particular types of operations:"></a>JVM perform some particular types of operations:</h3><ol>
<li>Loading of code（载入）</li>
<li>Verification of code（确认）</li>
<li>Executing the code（执行）</li>
<li>It provide run-time environment to the users</li>
</ol>
<h3 id="Types-of-Memory-areas-allocated-by-the-JVM"><a href="#Types-of-Memory-areas-allocated-by-the-JVM" class="headerlink" title="Types of Memory areas allocated by the JVM:"></a>Types of Memory areas allocated by the JVM:</h3><p>All these functions take different forms of the memory structure. The <strong>memory in the JVM divided into 5 different parts</strong>:</p>
<img src="/2021/05/17/How-many-types-of-memory-areas-are-allocated-by-JVM/JVM-Architecture-diagram.jpg" class="" title="Lightbox">

<ol>
<li>Class(Method) Area</li>
<li>Heap</li>
<li>Stack</li>
<li>Program Counter Register（程序计数器寄存器）</li>
<li>Native Method Stack</li>
</ol>
<p>Let’s see about them in brief:</p>
<ol>
<li>Class Loader:It is a subsystem of JVM which is used to load class files.It is mainly responsible for three activities.<ul>
<li>Loading</li>
<li>Linking</li>
<li>Initialization</li>
</ul>
</li>
<li><strong>Class(Method) Area:</strong> It stores class level data of every class such as the runtime constant pool, field and method data, the code for methods.</li>
<li><strong>Heap:</strong> It is used to allocate memory to objects at run time</li>
<li>Stack:<ul>
<li>Each thread has a private JVM stack, created at the same time as thread. It is used to store data and partial results which will be needed while returning value for method and performing dynamic linking.</li>
<li>Java Stack stores frames and a new frame is created each time at every invocation of the method.<br>A frame is destroyed when its method invocation completes</li>
</ul>
</li>
<li><strong>Program Counter Register:</strong> Each JVM thread which carries out the task of a specific method has a program counter register associated with it. The non-native method has a PC which stores the address of the available JVM instruction whereas, in a native method, the value of the program counter is undefined. PC register is capable of storing the return address or a native pointer on some specific platform.</li>
<li><strong>Native method Stacks:</strong> Also called as C stacks, native method stacks are not written in Java language. This memory is allocated for each thread when its created And it can be of a fixed or dynamic nature.</li>
</ol>
<h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><h4 id="本地方法栈-Native-Method-Stacks-2"><a href="#本地方法栈-Native-Method-Stacks-2" class="headerlink" title="本地方法栈(Native Method Stacks)[2]"></a>本地方法栈(Native Method Stacks)[2]</h4><p>本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而<strong>本地方法栈则是为虚拟机使用到的Native方法服务</strong>。虚拟机规范中，对本地方法栈中的方法使用的语言、方法使用的方式与数据结构并没有强制规定，因此具体的虚拟机可以自由实现它。甚至有的虚拟机（譬如Sun HotSpot虚拟机）直接就把本地方法栈和虚拟机栈合二为一。与虚拟机栈一样，本地方法栈区域也会抛出StackOverflowError和OutOfMemoryError异常。</p>
<p>以上描述截取自： </p>
<p>《深入理解Java虚拟机:JVM高级特性与最佳实践》 作者： 周志明 </p>
<p>-————————————————————————————————————–</p>
<p>In addition to all the runtime data areas defined by the Java Virtual Machine specification and described above, a running Java application may use other data areas created by or for native methods. When a thread invokes a native method, it enters a new world in which the structures and security restrictions of the Java Virtual Machine no longer hamper its freedom. A native method can likely access the runtime data areas of the virtual machine (it depends upon the native method interface), but can also do anything else it wants. It may use registers inside the native processor, allocate memory on any number of native heaps, or use any kind of stack.</p>
<p>前面提到的所有运行时数据区都是Java虚拟机规范中明确定义的，除此之外，对于一个运行中的Java程序而言，他还可能会用到一些与本地方法相关的数据区。当某个线程调用一个本地方法时，他就进入了一个全新的并且不再受虚拟机限制的世界 ，本地方法可以通过本地方法接口来访问虚拟机运行时的数据区，但不止于此，他还可以做任何他想做的事情。比如，他甚至可以直接使用本地处理器中的寄存器，或者直接从本地内存的堆中分配任意数量的内存等等。总之，他和虚拟机拥有同样的权限（或者说能力）。</p>
<p>Native methods are inherently implementation dependent. Implementation designers are free to decide what mechanisms they will use to enable a Java application running on their implementation to invoke native methods.</p>
<p>本地方法本质上是依赖于实现的，虚拟机实现的设计者可以自由地决定使用怎样的机制来让Java程序调用本地方法。</p>
<p>Any native method interface will use some kind of native method stack. When a thread invokes a Java method, the virtual machine creates a new frame and pushes it onto the Java stack. When a thread invokes a native method, however, that thread leaves the Java stack behind. Instead of pushing a new frame onto the threadís Java stack, the Java Virtual Machine will simply dynamically link to and directly invoke the native method. One way to think of it is that the Java Virtual Machine is dynamically extending itself with native code. It is as if the Java Virtual Machine implementation is just calling another (dynamically linked) method within itself, at the behest of the running Java program.</p>
<p>任何本地方法接口都会使用某种本地方法栈。当线程调用Java方法时，虚拟机会创建一个新的栈帧并压入Java栈。然而<strong>当他调用的是本地方法时，虚拟机会保持Java栈不变，不再在线程的Java栈中压入新的帧，虚拟机只是简单地动态连接并直接调用指定的本地方法。</strong>可以把这看做是虚拟机利用本地方法来动态地扩展自己 。就如同Java虚拟机的实现在按照其中运行的Java程序的吩咐，调用属于虚拟机内部的另一个（动态连接的）方法。</p>
<p>If an implementationís native method interface uses a C-linkage model, then the native method stacks are C stacks. When a C program invokes a C function, the stack operates in a certain way. The arguments to the function are pushed onto the stack in a certain order. The return value is passed back to the invoking function in a certain way. This would be the behavior of the of native method stacks in that implementation.</p>
<p>如果某个虚拟机实现的本地方法接口是使用C连接模型的话，那么他的本地方法栈就是C栈。我们知道，当C程序调用一个C函数时，其栈操作都是确定的。传递给该函数的参数以某个确定的顺序压入栈，他的返回值也以确定的方式传回调用者。同样，这就是该虚拟机实现中本地方法栈的行为。</p>
<p>A native method interface will likely (once again, it is up to the designers to decide) be able to call back into the Java Virtual Machine and invoke a Java method. In this case, the thread leaves the native method stack and enters another Java stack.</p>
<p>很可能本地方法接口需要回调Java虚拟机中的Java方法（这也是由设计者决定的），在这种情形下，该线程会保存本地方法栈的状态并进入到另一个Java栈。</p>
<p>Figure 5-13 shows a graphical depiction of a thread that invokes a native method that calls back into the virtual machine to invoke another Java method. This figure shows the full picture of what a thread can expect inside the Java Virtual Machine. A thread may spend its entire lifetime executing Java methods, working with frames on its Java stack. Or, it may jump back and forth between the Java stack and native method stacks.</p>
<p>图5-13描绘了这种情况，就是当一个线程调用一个本地方法时，本地方法又回调虚拟机中的另一个Java方法。这幅图展Java虚拟机内部线程运行的全景图。一个线程可能在整个生命周期中都执行Java方法，操作他的Java栈；或者他可能毫无障碍地在Java栈和本地方法栈之间跳转。<img src="/2021/05/17/How-many-types-of-memory-areas-are-allocated-by-JVM/03231458_sjaE.jpg" class="" title="img"></p>
<p>As depicted in Figure 5-13, a thread first invoked two Java methods, the second of which invoked a native method. This act caused the virtual machine to use a native method stack. In this figure, the native method stack is shown as a finite amount of contiguous memory space. Assume it is a C stack. The stack area used by each C-linkage function is shown in gray and bounded by a dashed line. The first C-linkage function, which was invoked as a native method, invoked another C-linkage function. The second C-linkage function invoked a Java method through the native method interface. This Java method invoked another Java method, which is the current method shown in the figure.</p>
<p>上图所示，该线程首先调用了两个Java方法，而第二个Java方法又调用了一个本地方法，这样导致虚拟机使用了一个本地方法栈。图中的本地方法栈显示为一个连续的内存空间。假设这是一个C语言栈，期间有两个C函数，他们都以包围在虚线中的灰色块表示。第一个C函数被第二个Java方法当做本地方法调用， 而这个C函数又调用了第二个C函数。之后第二个C函数被第二个Java方法当做本地方法调用，而这个C函数又调用了第二个C函数。之后第二个C函数又通过 本地方法接口回调了一个Java方法（第三个Java方法）。最终这个Java方法又调用了一个Java方法（他成为图中的当前方法）。</p>
<p>As with the other runtime memory areas, the memory they occupied by native method stacks need not be of a fixed size. It can expand and contract as needed by the running application. Implementations may allow users or programmers to specify an initial size for the method area, as well as a maximum or minimum size.</p>
<p>就像其他运行时内存区一样，本地方法栈占用的内存区也不必是固定大小的，他可以根据需要动态扩展或者收缩。某些是实现也允许用户或者程序员指定该内存区的初始大小以及最大，最小值。</p>
<h4 id="Program-Counter-Register-3"><a href="#Program-Counter-Register-3" class="headerlink" title="Program Counter Register[3]"></a>Program Counter Register[3]</h4><p>​    　　JVM在运行时会把管理的内存划分为不同的数据区域，有的区域随着jvm进程启动就开始存在，有的生命周期则与用户线程的周期相同。下面我们来看个划分图（摘自网络）</p>
<img src="/2021/05/17/How-many-types-of-memory-areas-are-allocated-by-JVM/image-20210517170622110.png" class="" title="image-20210517170622110">

<p>其中，方法区、java堆、执行引擎、本地库接口是线程共享的，虚拟机栈、本地方法栈、程序计数器是私有的。</p>
<p>　　接下来，我们介绍第一个概念：程序计数器。</p>
<p>   首先看一下百度百科的解释：</p>
<p>  程序计数器是用于存放下一条指令所在单元的地址的地方。</p>
<p> 　程序计数器是计算机<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%A4%84%E7%90%86%E5%99%A8">处理器</a>中的<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%AF%84%E5%AD%98%E5%99%A8">寄存器</a>，它包含当前正在执行的指令的地址（位置）。当每个<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%8C%87%E4%BB%A4">指令</a>被获取，程序计数器的存储地址加一。在每个指令被获取之后，程序计数器指向顺序中的下一个指令。当计算机重启或复位时，程序计数器通常恢复到 零。</p>
<p>　　当执行一条指令时，首先需要根据PC中存放的指令地址，将指令由内存取到<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%8C%87%E4%BB%A4%E5%AF%84%E5%AD%98%E5%99%A8">指令寄存器</a>中，此过程称为“取指令”。与此同时，PC中的地址或自动加1或由转移指针给出下一条指令的地址。此后经过分析指令，执行指令。完成第一条指令的执行，而后根据PC取出第二条指令的地址，如此循环，执行每一条指令。</p>
<p>　　程序计数器其实就是一小块内存区域，可以看作是当前线程所执行的字节码的行号代码，直白一点说，就是当前线程执行到哪一行的一个代码计数器。</p>
<p>　　大家都知道在jvm中，是跑多线程的，包括我们的debug，都是在多线程中运行。java中的多线程是通过轮流切换分配处理器来执行的，在任何时间，一个处理器只处理一条指令，所以一旦切换线程，就依靠程序计数器来确定执行到了哪一行代码，或者说是哪一行指令，所以，程序计数器是私有的，才能保证各个线程间的任务执行互不影响。</p>
<p>　　还有一点要注意的是，如果线程运行的是一个java的方法，程序计数器记录的是虚拟机字节码指令的地址（在jvm启动后，编译java文件成字节码文件），而如果是一个Native方法，程序计数器则为空，这里也是java虚拟机规范中，唯一一个没有规定OutOfMemoryError的区域。</p>
<p> The Java Virtual Machine can support many threads of execution at once (JLS §17). Each Java Virtual Machine thread has its own <code>pc</code> (program counter) register. At any point, each Java Virtual Machine thread is executing the code of a single method, namely the current method (<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.6">§2.6</a>) for that thread. If that method is not <code>native</code>, the <code>pc</code> register contains the address of the Java Virtual Machine instruction currently being executed. If the method currently being executed by the thread is <code>native</code>, the value of the Java Virtual Machine’s <code>pc</code> register is undefined. The Java Virtual Machine’s <code>pc</code> register is wide enough to hold a <code>returnAddress</code> or a native pointer on the specific platform.</p>
<p>　　因为jvm中的程序计数器，记录的是字节码指令的地址，而本地方法体不一定是有java实现的，所以自然不能支持程序计数器。</p>
<p>参考：</p>
<p>[1] <a target="_blank" rel="noopener" href="https://www.geeksforgeeks.org/how-many-types-of-memory-areas-are-allocated-by-jvm/">https://www.geeksforgeeks.org/how-many-types-of-memory-areas-are-allocated-by-jvm/</a></p>
<p>[2] <a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1111730">https://cloud.tencent.com/developer/article/1111730</a></p>
<p>[3] <a target="_blank" rel="noopener" href="https://www.iteye.com/blog/denverj-1220969">https://www.iteye.com/blog/denverj-1220969</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://wenwenhuan.gitee.io/2021/05/12/%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="温文焕">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wenhuan Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/05/12/%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3/" class="post-title-link" itemprop="url">算法相关</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-05-12 12:02:52 / 修改时间：12:08:12" itemprop="dateCreated datePublished" datetime="2021-05-12T12:02:52+08:00">2021-05-12</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <img src="/2021/05/12/%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3/v2-0872ff222124611b3403a888be76c2b9_1440w.jpg" class="" title="排序算法的稳定性">
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">温文焕</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  





  





</body>
</html>
