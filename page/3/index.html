<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"wenwenhuan.gitee.io","root":"/","images":"/images","scheme":"Gemini","darkmode":true,"version":"8.8.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>
<meta property="og:type" content="website">
<meta property="og:title" content="Wenhuan Blog">
<meta property="og:url" content="https://wenwenhuan.gitee.io/page/3/index.html">
<meta property="og:site_name" content="Wenhuan Blog">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="温文焕">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://wenwenhuan.gitee.io/page/3/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/3/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Wenhuan Blog</title>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Wenhuan Blog</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">即使天无雨 我亦留此地</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">温文焕</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">61</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://wenwenhuan.gitee.io/2021/04/25/%E5%A4%9A%E7%BA%BF%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="温文焕">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wenhuan Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/04/25/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" class="post-title-link" itemprop="url">多线程</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-04-25 10:33:17" itemprop="dateCreated datePublished" datetime="2021-04-25T10:33:17+08:00">2021-04-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2021-05-12 12:07:02" itemprop="dateModified" datetime="2021-05-12T12:07:02+08:00">2021-05-12</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="一个线程的生命周期"><a href="#一个线程的生命周期" class="headerlink" title="一个线程的生命周期"></a>一个线程的生命周期</h2><p>线程是一个动态执行的过程，它也有一个从产生到死亡的过程。</p>
<p>下图显示了一个线程完整的生命周期。</p>
<img src="/2021/04/25/%E5%A4%9A%E7%BA%BF%E7%A8%8B/java-thread.jpg" class="" title="img">

<ul>
<li><p>新建状态:</p>
<p>使用 <strong>new</strong> 关键字和 <strong>Thread</strong> 类或其子类建立一个线程对象后，该线程对象就处于新建状态。它保持这个状态直到程序 <strong>start()</strong> 这个线程。</p>
</li>
<li><p>就绪状态:</p>
<p>当线程对象调用了start()方法之后，该线程就进入就绪状态。就绪状态的线程处于就绪队列中，要等待JVM里线程调度器的调度。</p>
</li>
<li><p>运行状态:</p>
<p>如果就绪状态的线程获取 CPU 资源，就可以执行 **run()**，此时线程便处于运行状态。处于运行状态的线程最为复杂，它可以变为阻塞状态、就绪状态和死亡状态。</p>
</li>
<li><p>阻塞状态:</p>
<p>如果一个线程执行了sleep（睡眠）、suspend（挂起）等方法，失去所占用资源之后，该线程就从运行状态进入阻塞状态。在睡眠时间已到或获得设备资源后可以重新进入就绪状态。可以分为三种：</p>
<ul>
<li>等待阻塞：运行状态中的线程执行 wait() 方法，使线程进入到等待阻塞状态。</li>
<li>同步阻塞：线程在获取 synchronized 同步锁失败(因为同步锁被其他线程占用)。</li>
<li>其他阻塞：通过调用线程的 sleep() 或 join() 发出了 I/O 请求时，线程就会进入到阻塞状态。当sleep() 状态超时，join() 等待线程终止或超时，或者 I/O 处理完毕，线程重新转入就绪状态。</li>
</ul>
</li>
<li><p>死亡状态:</p>
<p>一个运行状态的线程完成任务或者其他终止条件发生时，该线程就切换到终止状态。</p>
</li>
</ul>
<p>一个线程还可以等待另一个线程直到其运行结束。例如，<code>main</code>线程在启动<code>t</code>线程后，可以通过<code>t.join()</code>等待<code>t</code>线程结束后再继续运行。</p>
<h2 id="线程的优先级"><a href="#线程的优先级" class="headerlink" title="线程的优先级"></a>线程的优先级</h2><p>每一个 Java 线程都有一个优先级，这样有助于操作系统确定线程的调度顺序。</p>
<p>Java 线程的优先级是一个整数，其取值范围是 1 （Thread.MIN_PRIORITY ） - 10 （Thread.MAX_PRIORITY ）。</p>
<p>默认情况下，每一个线程都会分配一个优先级 NORM_PRIORITY（5）。</p>
<p>具有较高优先级的线程对程序更重要，并且应该在低优先级的线程之前分配处理器资源。但是，线程优先级不能保证线程执行的顺序，而且非常依赖于平台。</p>
<h2 id="Java多线程实现的三种方式"><a href="#Java多线程实现的三种方式" class="headerlink" title="Java多线程实现的三种方式"></a>Java多线程实现的三种方式</h2><p>1.继承Thread类，重写run方法</p>
<p>2.实现Runnable接口，重写run方法，实现Runnable接口的实现类的实例对象作为Thread构造函数的target</p>
<p>3.通过Callable和FutureTask创建线程</p>
<p>4.通过线程池创建线程</p>
<p>前面两种可以归结为一类：无返回值，原因很简单，通过重写run方法，run方式的返回值是void，所以没有办法返回结果</p>
<p>后面两种可以归结成一类：有返回值，通过Callable接口，就要实现call方法，这个方法的返回值是Object，所以返回的结果可以放在Object对象中</p>
<h3 id="方式1：通过继承Thread来创建线程"><a href="#方式1：通过继承Thread来创建线程" class="headerlink" title="方式1：通过继承Thread来创建线程"></a>方式1：通过继承Thread来创建线程</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo01</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadDemo01</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//编写子类的构造方法，可缺省</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//编写自己的线程代码</span></span><br><span class="line">        System.out.println(Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123; </span><br><span class="line">        ThreadDemo01 threadDemo01 = <span class="keyword">new</span> ThreadDemo01(); </span><br><span class="line">        threadDemo01.setName(<span class="string">&quot;我是自定义的线程1&quot;</span>);</span><br><span class="line">        threadDemo01.start();       </span><br><span class="line">        System.out.println(Thread.currentThread().toString());  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序结果：</p>
<p>Thread[main,5,main]</p>
<p>我是自定义的线程1</p>
<p><strong>使用到的方法：</strong></p>
<p><code>setName</code>:改变线程名称，使之与参数 <code>name</code> 相同。</p>
<p><code>currentThread</code>:返回对当前正在执行的线程对象的引用。返回：当前执行的线程。</p>
<h3 id="方式2：通过实现-Runnable-接口来创建线程"><a href="#方式2：通过实现-Runnable-接口来创建线程" class="headerlink" title="方式2：通过实现 Runnable 接口来创建线程"></a>方式2：通过实现 Runnable 接口来创建线程</h3><p>接口的实现类的实例作为Thread的target作为参数传入带参的Thread构造函数，通过调用start()方法启动线程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo02</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123; </span><br><span class="line">        System.out.println(Thread.currentThread().getName());</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyThread());</span><br><span class="line">        t1.start(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;--&gt;我是通过实现接口的线程实现方式！&quot;</span>);</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序运行结果：</p>
<p>main</p>
<p>Thread-0–&gt;我是通过实现接口的线程实现方式！</p>
<h3 id="方式3：通过-Callable-和-Future-创建线程"><a href="#方式3：通过-Callable-和-Future-创建线程" class="headerlink" title="方式3：通过 Callable 和 Future 创建线程"></a>方式3：通过 Callable 和 Future 创建线程</h3><ul>
<li><ol>
<li>创建 Callable 接口的实现类，并实现 call() 方法，该 call() 方法将作为线程执行体，并且有返回值。</li>
</ol>
</li>
<li><ol start="2">
<li>创建 Callable 实现类的实例，使用 FutureTask 类来包装 Callable 对象，该 FutureTask 对象封装了该 Callable 对象的 call() 方法的返回值。</li>
</ol>
</li>
<li><ol start="3">
<li>使用 FutureTask 对象作为 Thread 对象的 target 创建并启动新线程。</li>
</ol>
</li>
<li><ol start="4">
<li>调用 FutureTask 对象的 get() 方法来获得子线程执行结束后的返回值。</li>
</ol>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallableThreadTest</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  </span></span><br><span class="line"><span class="function">    </span>&#123;  </span><br><span class="line">        CallableThreadTest ctt = <span class="keyword">new</span> CallableThreadTest();  </span><br><span class="line">        FutureTask&lt;Integer&gt; ft = <span class="keyword">new</span> FutureTask&lt;&gt;(ctt);  </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">100</span>;i++)  </span><br><span class="line">        &#123;  </span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot; 的循环变量i的值&quot;</span>+i);  </span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">20</span>)  </span><br><span class="line">            &#123;  </span><br><span class="line">                <span class="keyword">new</span> Thread(ft,<span class="string">&quot;有返回值的线程&quot;</span>).start();  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">try</span>  </span><br><span class="line">        &#123;  </span><br><span class="line">            System.out.println(<span class="string">&quot;子线程的返回值：&quot;</span>+ft.get());  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e)  </span><br><span class="line">        &#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e)  </span><br><span class="line">        &#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception  </span></span><br><span class="line"><span class="function">    </span>&#123;  </span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;  </span><br><span class="line">        <span class="keyword">for</span>(;i&lt;<span class="number">100</span>;i++)  </span><br><span class="line">        &#123;  </span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot; &quot;</span>+i);  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> i;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="创建线程的三种方式的对比"><a href="#创建线程的三种方式的对比" class="headerlink" title="创建线程的三种方式的对比"></a>创建线程的三种方式的对比</h4><ul>
<li>采用实现 Runnable、Callable 接口的方式创建多线程时，线程类只是实现了 Runnable 接口或 Callable 接口，还可以继承其他类。</li>
<li>使用继承 Thread 类的方式创建多线程时，编写简单，如果需要访问当前线程，则无需使用 Thread.currentThread() 方法，直接使用 this 即可获得当前线程。</li>
</ul>
<h2 id="中断线程"><a href="#中断线程" class="headerlink" title="中断线程"></a>中断线程</h2><p>中断一个线程非常简单，只需要在其他线程中对目标线程调用<code>interrupt()</code>方法，目标线程需要反复检测自身状态是否是interrupted状态，如果是，就立刻结束运行。</p>
<h2 id="volatile关键字"><a href="#volatile关键字" class="headerlink" title="volatile关键字"></a>volatile关键字</h2><p>线程间共享变量需要使用<code>volatile</code>关键字标记，确保每个线程都能读取到更新后的变量值。</p>
<h2 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h2><p>Java程序入口就是由JVM启动<code>main</code>线程，<code>main</code>线程又可以启动其他线程。当所有线程都运行结束时，JVM退出，进程结束。</p>
<p>如果有一个线程没有退出，JVM进程就不会退出。所以，必须保证所有线程都能及时结束。</p>
<p>当遇到无限循环线程的时候，就需要守护线程负责结束该线程。</p>
<p>守护线程是指为其他线程服务的线程。在JVM中，所有非守护线程都执行完毕后，无论有没有守护线程，虚拟机都会自动退出。</p>
<p>因此，JVM退出时，不必关心守护线程是否已结束。</p>
<h3 id="创建守护线程"><a href="#创建守护线程" class="headerlink" title="创建守护线程"></a>创建守护线程</h3><p>方法和普通线程一样，只是在调用<code>start()</code>方法前，调用<code>setDaemon(true)</code>把该线程标记为守护线程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Thread t = <span class="keyword">new</span> MyThread();</span><br><span class="line">t.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">t.start();</span><br></pre></td></tr></table></figure>

<p>在守护线程中，编写代码要注意：守护线程不能持有任何需要关闭的资源，例如打开文件等，因为虚拟机退出时，守护线程没有任何机会来关闭文件，这会导致数据丢失。</p>
<p>所有非守护线程都执行完毕后，虚拟机退出。</p>
<h2 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h2><p>解决多个线程同时读写共享变量，会出现数据不一致的问题。</p>
<p>对变量进行读取和写入时，结果要正确，必须保证是原子操作。原子操作是指不能被中断的一个或一系列操作。</p>
<p>保证一组指令以原子方式执行：即某一个线程执行时，其他线程必须等待。</p>
<p>保证一段代码的原子性就是通过加锁和解锁实现的。Java程序使用<code>synchronized</code>关键字对一个对象进行加锁：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(lock) &#123;</span><br><span class="line">    n = n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(Counter.lock) &#123; <span class="comment">// 获取锁</span></span><br><span class="line">    ...</span><br><span class="line">&#125; <span class="comment">// 释放锁</span></span><br></pre></td></tr></table></figure>

<p>表示用<code>Counter.lock</code>实例作为锁，两个线程在执行各自的<code>synchronized(Counter.lock) &#123; ... &#125;</code>代码块时，必须先获得锁，才能进入代码块进行。执行结束后，在<code>synchronized</code>语句块结束会自动释放锁。这样一来，对<code>Counter.count</code>变量进行读写就不可能同时进行。</p>
<h2 id="线程的几个主要概念"><a href="#线程的几个主要概念" class="headerlink" title="线程的几个主要概念"></a>线程的几个主要概念</h2><p>在多线程编程时，需要了解以下几个概念：</p>
<ul>
<li>线程同步</li>
<li>线程间通信</li>
<li>线程死锁</li>
<li>线程控制：挂起、停止和恢复</li>
</ul>
<h2 id="多线程优缺点"><a href="#多线程优缺点" class="headerlink" title="多线程优缺点"></a>多线程优缺点</h2><p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1416283">https://cloud.tencent.com/developer/article/1416283</a></p>
<h3 id="1-多线程的优点"><a href="#1-多线程的优点" class="headerlink" title="1. 多线程的优点"></a>1. 多线程的优点</h3><ul>
<li>无需跨进程边界；</li>
<li>程序逻辑和控制方式简单；</li>
<li>所有线程可以直接共享内存和变量等；</li>
<li>线程方式消耗的总资源比进程方式好；</li>
</ul>
<h3 id="2-多线程缺点"><a href="#2-多线程缺点" class="headerlink" title="2. 多线程缺点"></a>2. 多线程缺点</h3><ul>
<li>每个线程与主程序共用地址空间，受限于2GB地址空间；</li>
<li>线程之间的同步和加锁控制比较麻烦；</li>
<li>一个线程的崩溃可能影响到整个程序的稳定性；</li>
<li>到达一定的线程数程度后，即使再增加CPU也无法提高性能，例如Windows Server 2003，大约是1500个左右的线程数就快到极限了（线程堆栈设定为1M），如果设定线程堆栈为2M，还达不到1500个线程总数；</li>
<li>线程能够提高的总性能有限，而且线程多了之后，线程本身的调度也是一个麻烦事儿，需要消耗较多的CPU</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://wenwenhuan.gitee.io/2021/04/24/%E7%BC%93%E5%AD%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="温文焕">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wenhuan Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/04/24/%E7%BC%93%E5%AD%98/" class="post-title-link" itemprop="url">缓存</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-04-24 21:01:16" itemprop="dateCreated datePublished" datetime="2021-04-24T21:01:16+08:00">2021-04-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2021-05-12 12:07:12" itemprop="dateModified" datetime="2021-05-12T12:07:12+08:00">2021-05-12</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="什么是缓存"><a href="#什么是缓存" class="headerlink" title="什么是缓存"></a>什么是缓存</h2><p>所谓缓存，就是将程序或系统经常要调用的对象存在内存中，以便其使用时可以快速调用，不必再去创建新的重复的实例。这样做可以减少系统开销，提高系统效率。</p>
<p>缓存主要可分为二大类:</p>
<p>1：通过文件缓存,顾名思义文件缓存是指把数据存储在磁盘上，不管你是以XML格式，序列化文件DAT格式还是其它文件格式；</p>
<p>2：内存缓存，也就是创建一个静态内存区域，将数据存储进去，例如我们B/S架构的将数据存储在Application中或者存储在一个静态Map中。</p>
<h2 id="实现本地缓存"><a href="#实现本地缓存" class="headerlink" title="实现本地缓存"></a>实现本地缓存</h2><h3 id="1-存储集合的选择"><a href="#1-存储集合的选择" class="headerlink" title="1.存储集合的选择"></a>1.存储集合的选择</h3><p>实现本地缓存，存储容器肯定是 <strong>key/value 形式的数据结构</strong>，在 Java 中，也就是我们常用的 Map 集合。Map 中有 HashMap、Hashtable、ConcurrentHashMap 几种供我们选择，如果不考虑高并发情况下数据安全问题，我们可以选择HashMap，如果考虑高并发情况下数据安全问题，我们可以选择 Hashtable、ConcurrentHashMap 中的一种集合，但是我们优先选择 ConcurrentHashMap，因为 ConcurrentHashMap 的性能比 Hashtable 要好。</p>
<h3 id="2、过期缓存处理"><a href="#2、过期缓存处理" class="headerlink" title="2、过期缓存处理"></a>2、过期缓存处理</h3><p>因为缓存直接存储在内存中，如果我们不处理过期缓存，内存将被大量无效缓存占用，这不是我们想要的，所以我们需要清理这些失效的缓存。过期缓存处理可以参考 Redis 的策略来实现，Redis 采用的是定期删除 + 懒惰淘汰策略。</p>
<h4 id="定期删除策略"><a href="#定期删除策略" class="headerlink" title="定期删除策略"></a>定期删除策略</h4><p>定期删除策略是每隔一段时间检测已过期的缓存，并且将之删除。这个策略的优点是能够确保过期的缓存都会被删除。同时也存在着缺点，过期的缓存不一定能够及时的被删除，这跟我们设置的定时频率有关系，另一个缺点是如果缓存数据较多时，每次检测也会给 cup 带来不小的压力。</p>
<h4 id="懒惰淘汰策略"><a href="#懒惰淘汰策略" class="headerlink" title="懒惰淘汰策略"></a>懒惰淘汰策略</h4><p>懒惰淘汰策略是在使用缓存时，先判断缓存是否过期，如果过期将它删除，并且返回空。这个策略的优点是只有在查找的时候，才判断是否过期，对 CUP 影响较小。同时这种策略有致命的缺点，当存入了大量的缓存，这些缓存都没有被使用并且已过期，都将成为无效缓存，这些无效的缓存将占用你大量的内存空间，最后导致服务器内存溢出。</p>
<p>我们简单的了解了一下 Redis 的两种过期缓存处理策略，每种策略都存在自己的优缺点。所以我们在使用过程中，可以将两种策略组合起来，结合效果还是非常理想的。</p>
<h3 id="3、缓存淘汰策略"><a href="#3、缓存淘汰策略" class="headerlink" title="3、缓存淘汰策略"></a>3、缓存淘汰策略</h3><p>缓存淘汰跟过期缓存处理要区别开来，缓存淘汰是指当我们的缓存个数达到我们指定的缓存个数时，毕竟我们的内存不是无限的。如果我们需要继续添加缓存的话，我们就需要在现有的缓存中根据某种策略淘汰一些缓存，给新添加的缓存腾出位置，下面一起来认识几种常用的缓存淘汰策略。</p>
<h4 id="先进先出策略"><a href="#先进先出策略" class="headerlink" title="先进先出策略"></a>先进先出策略</h4><p>最先进入缓存的数据在缓存空间不够的情况下会被优先被清除掉，以腾出新的空间接受新的数据。该策略主要比较缓存元素的创建时间。在一些对数据实效性要求比较高的场景下，可考虑选择该类策略，优先保障最新数据可用。</p>
<h4 id="最少使用策略"><a href="#最少使用策略" class="headerlink" title="最少使用策略"></a>最少使用策略</h4><p>无论是否过期，根据元素的被使用次数判断，清除使用次数较少的元素释放空间。该策略主要比较元素的hitCount（命中次数），在保证高频数据有效性场景下，可选择这类策略。</p>
<h4 id="最近最少使用策略"><a href="#最近最少使用策略" class="headerlink" title="最近最少使用策略"></a>最近最少使用策略</h4><p>无论是否过期，根据元素最后一次被使用的时间戳，清除最远使用时间戳的元素释放空间。该策略主要比较缓存最近一次被get使用时间。在热点数据场景下较适用，优先保证热点数据的有效性。</p>
<h4 id="随机淘汰策略"><a href="#随机淘汰策略" class="headerlink" title="随机淘汰策略"></a>随机淘汰策略</h4><p>无论是否过期，随机淘汰某个缓存，如果对缓存数据没有任何要求，可以考虑使用该策略。</p>
<h4 id="不淘汰策略"><a href="#不淘汰策略" class="headerlink" title="不淘汰策略"></a>不淘汰策略</h4><p>当缓存达到指定值之后，不淘汰任何缓存，而是不能新增缓存，直到有缓存淘汰时，才能继续添加缓存。</p>
<p>上面是实现本地缓存需要考虑的三个点，看完我们应该知该如何实现一个本地缓存了，不妨我们一起来实现一个本地缓存。</p>
<h3 id="实现本地缓存-1"><a href="#实现本地缓存-1" class="headerlink" title="实现本地缓存"></a>实现本地缓存</h3><p>在该 Demo 中，我们采用 ConcurrentHashMap 作为存储集合，这样即使在高并发的情况下，我们也能够保证缓存的安全。过期缓存处理在这里我只使用了定时删除策略，并没有使用定时删除 + 懒惰淘汰策略，你可以自己动手尝试一下使用这两种策略进行过期缓存处理。在缓存淘汰方面，我在这里采用了最少使用策略。好了，技术选型都知道了，我们一起来看看代码实现。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://wenwenhuan.gitee.io/2021/04/17/%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E5%A4%A7%E5%88%A9%E6%B6%A6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="温文焕">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wenhuan Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/04/17/%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E5%A4%A7%E5%88%A9%E6%B6%A6/" class="post-title-link" itemprop="url">股票的最大利润</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-04-17 10:53:49 / 修改时间：11:16:06" itemprop="dateCreated datePublished" datetime="2021-04-17T10:53:49+08:00">2021-04-17</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>假设把某股票的价格按照时间先后顺序存储在数组中，请问买卖该股票一次可能获得的最大利润是多少？</p>
<h3 id="审题"><a href="#审题" class="headerlink" title="审题"></a>审题</h3><p>关键的两个限制是“最大”利润和买卖股票的时间顺序。</p>
<p>这两个限制表明，题目不是简单寻找数组中的最大最小值，而是要比较多种情况。</p>
<h3 id="自己的方法–暴力"><a href="#自己的方法–暴力" class="headerlink" title="自己的方法–暴力"></a>自己的方法–暴力</h3><p>思路：两个for循环，把每一种情况都计算出来，不断刷新最大的利润值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; prices.length; j++) &#123;</span><br><span class="line">            <span class="keyword">int</span> profit = prices[j] - prices[i];</span><br><span class="line">            <span class="keyword">if</span> (profit&gt;res)&#123;</span><br><span class="line">                res = profit;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>时间复杂度：O(n^2)，循环运行 [n(n-1)]/2次。</p>
<p>空间复杂度：O(1)。只使用了常数个变量。</p>
<h3 id="动态规划解题"><a href="#动态规划解题" class="headerlink" title="动态规划解题"></a>动态规划解题</h3><p>思路：分析四要素</p>
<img src="/2021/04/17/%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E5%A4%A7%E5%88%A9%E6%B6%A6/image-20210417110436812.png" class="" title="image-20210417110436812">

<p>难点是转移方程的分析</p>
<h4 id="效率优化："><a href="#效率优化：" class="headerlink" title="效率优化："></a>效率优化：</h4><img src="/2021/04/17/%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E5%A4%A7%E5%88%A9%E6%B6%A6/image-20210417110556220.png" class="" title="image-20210417110556220">

<p>时间复杂度降低较容易，相较于每次都要遍历一遍子数组寻找最低价格，借助变量保存并实时更新显然更合理。</p>
<p>空间复杂度的降低很巧妙，也是动态规划的核心，本来状态方程中最难解决的就是<code>dp[i]</code>是与<code>dp[i-1]</code>相关的，很像递归，在实现上很难处理，答案使用了和时间复杂度降低相似的做法，借助变量记录<code>dp[i-1]</code>.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> profit = <span class="number">0</span>,cost = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">        <span class="comment">//更新最小的prices</span></span><br><span class="line">        <span class="keyword">if</span> (prices[i]&lt;cost) cost = prices[i];</span><br><span class="line">        profit = Math.max(profit, prices[i]-cost);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> profit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="复杂度分析："><a href="#复杂度分析：" class="headerlink" title="复杂度分析："></a>复杂度分析：</h4><img src="/2021/04/17/%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E5%A4%A7%E5%88%A9%E6%B6%A6/image-20210417110618502.png" class="" title="image-20210417110618502">
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://wenwenhuan.gitee.io/2021/04/16/wldd/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="温文焕">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wenhuan Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/04/16/wldd/" class="post-title-link" itemprop="url">外伶仃岛攻略</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-04-16 19:39:32 / 修改时间：20:06:56" itemprop="dateCreated datePublished" datetime="2021-04-16T19:39:32+08:00">2021-04-16</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="出行方式：地铁-高铁-打车-船"><a href="#出行方式：地铁-高铁-打车-船" class="headerlink" title="出行方式：地铁+高铁+打车+船"></a>出行方式：地铁+高铁+打车+船</h3><p><strong>去程</strong></p>
<ul>
<li><p>家→广州南：地铁，一小时，九点出门</p>
</li>
<li><p>广州南→珠海站：高铁65/人,一小时左右，10:25-11:24或10:57-11:53（这趟有点太赶）</p>
</li>
<li><p>珠海站→香洲港：打车28左右，半个小时左右</p>
</li>
<li><p>香洲港→外伶仃岛：坐船120/人，一个半小时左右,12:40-13:50，提前半个小时排队取票</p>
</li>
</ul>
<p><strong>回程</strong></p>
<ul>
<li>外伶仃岛→香洲港：17：15→18:25</li>
<li>香洲港→珠海站：18:30-19:00</li>
<li>珠海站→广州南：19:20-20:29</li>
</ul>
<p>船票+高铁票往返=370￥</p>
<h3 id="住宿"><a href="#住宿" class="headerlink" title="住宿"></a>住宿</h3><p>聆海居榻榻米海景客栈，双床房，185/晚</p>
<p>距离码头走路6-7分钟</p>
<p><strong>参考地图</strong></p>
<img src="/2021/04/16/wldd/map.png" class="" title="image-20210416193536381">

<h3 id="游玩"><a href="#游玩" class="headerlink" title="游玩"></a>游玩</h3><p>岛内交通包括骑车和走路</p>
<img src="/2021/04/16/wldd/%E9%AA%91%E8%BD%A6.png" class="" title="39538248fe8c99575d55fd13bbe16ba">

<p><strong>1.矿石湖</strong></p>
<p>走路1-1.5小时</p>
<img src="/2021/04/16/wldd/%E7%9F%BF%E7%9F%B3%E6%B9%961.jpg" class="" title="41bd865bf60abdfb260c8b23469958a">
<img src="/2021/04/16/wldd/%E7%9F%BF%E7%9F%B3%E6%B9%962.png" class="" title="46ad7e878a8de0100135420a2af1d1e">
<p>2.<strong>看日出</strong></p>
<p>参考路线</p>
<p>去山顶可能四点就要起床了</p>
<img src="/2021/04/16/wldd/sun.jpg" class="" title="1bcfa63e2a23a812b4850428c94937a">

<h3 id="饮食"><a href="#饮食" class="headerlink" title="饮食"></a>饮食</h3><p>外伶仃岛特色小吃：海胆、狗爪螺和将军帽</p>
<img src="/2021/04/16/wldd/%E9%A5%AE%E9%A3%9F2.png" class="" title="acba6652fd072abc0b207235c0e43d7">

<img src="/2021/04/16/wldd/%E9%A5%AE%E9%A3%9F.png" class="" title="image-20210416193716389">
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://wenwenhuan.gitee.io/2021/04/12/Java%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="温文焕">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wenhuan Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/04/12/Java%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">Java的一些基础知识点</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-04-12 23:11:00 / 修改时间：23:17:58" itemprop="dateCreated datePublished" datetime="2021-04-12T23:11:00+08:00">2021-04-12</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="hashmap如何实现"><a href="#hashmap如何实现" class="headerlink" title="hashmap如何实现"></a>hashmap如何实现</h2><p>HashMap是使用<strong>hash算法</strong>,然后基于<strong>数组+链表+红黑树</strong>来实现的,或许还知道HashMap内部数组的初始长度为<strong>16</strong>,并且还能<strong>自动扩容</strong>.</p>
<p><strong>简单来说，HashMap由数组+链表组成的，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的，如果定位到的数组位置不含链表（当前entry的next指向null）,那么对于查找，添加等操作很快，仅需一次寻址即可；如果定位到的数组包含链表，对于添加操作，其时间复杂度为O(n)，首先遍历链表，存在即覆盖，否则新增；对于查找操作来讲，仍需遍历链表，然后通过key对象的equals方法逐一比对查找。所以，性能考虑，HashMap中的链表出现越少，性能才会越好。</strong></p>
<p><img src="C:%5CUsers%5CPowerwenwh%5CDocuments%5CMyBlog%5Csource%5C_posts%5Cimgs%5CJava%E5%9F%BA%E7%A1%80%5C1024555-20161113235348670-746615111.png" alt="img"></p>
<p><img src="C:%5CUsers%5CPowerwenwh%5CDocuments%5CMyBlog%5Csource%5C_posts%5Cimgs%5CJava%E5%9F%BA%E7%A1%80%5C1292434-20171210003109576-1016700625.jpg" alt="img"></p>
<p>我们可以看到12和0的位置冲突了，然后我们把该数组的每一个元素变成了一个链表头，冲突的元素放在了链表中，这样在找到对应的链表头之后会顺着链表找下去，至于<strong>为什么采用链表，是为了节省空间，链表在内存中并不是连续存储</strong>，所以我们可以更充分地使用内存。</p>
<h2 id="ReentrantLock与synchronized（同步锁）锁"><a href="#ReentrantLock与synchronized（同步锁）锁" class="headerlink" title="ReentrantLock与synchronized（同步锁）锁"></a>ReentrantLock与synchronized（同步锁）锁</h2><p><strong>线程不同步的原因</strong></p>
<p>线程之所以会不同步，<strong>本质原因在于每个线程的高速缓存区</strong>。每个线程在创建后会有自己的一个缓存区，在线程要访问主存中的变量的时候会先将主存中的变量加入缓存，然后进行操作，这样可以避免主存访问过于频繁，可以加快线程的执行效率（类似于cache）。但问题在于每个线程的缓存区之间不可见，如果载入的是主存中的同一个变量，分别进行了更改，就会出现线程不同步的问题。</p>
<p><strong>synchronized是如何实现同步的##</strong></p>
<p>好吧其实很简单，比较机智的读者可能已经猜到了，他其实是使各个线程之间的高速缓存区失效了，然后线程要获取该变量的时候需要在主存中读写，这个时候对该变量的操作对于各个线程之间是可见的，然后操作结束之后再刷新其缓存区，</p>
<p><strong>reentrantlock</strong></p>
<p>synchonized的缺点。一是不灵活，<strong>synchonized在锁定之后必须要代码块结束之后才能释放锁</strong>，然后被其他线程获得。那么如果获取到锁的这个线程要执行非常长的时间呢，那其他的线程不是会一直阻塞在这里，这时如果有哪个线程生气了不想等了怎么办？抱歉不可以，需要一直等待。另一方面，同步锁的<strong>释放顺序也很固定</strong>，必须是加锁的反顺序，很不潇洒等等。。。</p>
<p>声明了ReentrantLock对象后只需调用其中的lock方法便可直接加锁，而释放锁需要unlock方法。这样一是很灵活，<strong>不需要代码块结束再释放</strong>，还有就是 ReentrantLock是可中断的，如果等待的线程不想等了，好说，interrupt掉就好了，另外， <strong>ReentrantLock可以设为悲观锁和乐观锁，而synchonized则默认为悲观锁</strong>，不可改变，不够灵活。所以综上，ReentrantLock更加灵活多变。但大家在使用时一定要记得unlock，最好写在finally里面防止忘记，不然就会造成其他线程阻塞。</p>
<h2 id="Java中的锁分类"><a href="#Java中的锁分类" class="headerlink" title="Java中的锁分类"></a>Java中的锁分类</h2><p>Java中锁分为以下几种：</p>
<ul>
<li>乐观锁、悲观锁</li>
<li>独享锁、共享锁</li>
<li>公平锁、非公平锁</li>
<li>互斥锁、读写锁</li>
<li>可重入锁</li>
<li>分段锁</li>
<li>锁升级(无锁 -&gt; 偏向锁 -&gt; 轻量级锁 -&gt; 重量级锁) JDK1.6</li>
</ul>
<p>这些锁的分类并不全是指锁的状态，有的指<strong>锁的特性，有的指锁的设计</strong>，下面总结的内容是对每个锁的名词进行一定的解释。</p>
<h3 id="1、乐观锁-amp-悲观锁"><a href="#1、乐观锁-amp-悲观锁" class="headerlink" title="1、乐观锁 &amp; 悲观锁"></a>1、乐观锁 &amp; 悲观锁</h3><p>两种锁只是一种概念</p>
<p><strong>乐观锁：</strong>乐观锁认为一个线程去拿数据的时候不会有其他线程对数据进行更改，所以不会上锁。</p>
<p>实现方式：CAS机制、版本号机制</p>
<p><strong>悲观锁：</strong>悲观锁认为一个线程去拿数据时一定会有其他线程对数据进行更改。所以一个线程在拿数据的时候都会顺便加锁，这样别的线程此时想拿这个数据就会阻塞。比如Java里面的synchronized关键字的实现就是悲观锁。实现方式：就是加锁。</p>
<h3 id="2、独享锁-amp-共享锁"><a href="#2、独享锁-amp-共享锁" class="headerlink" title="2、独享锁 &amp; 共享锁"></a>2、独享锁 &amp; 共享锁</h3><p>两种锁只是一种概念</p>
<p><strong>独享锁：</strong>该锁一次只能被一个线程所持有</p>
<p><strong>共享锁：</strong>该锁可以被多个线程所持有</p>
<p>举例：</p>
<p>synchronized是独享锁；</p>
<p>可重入锁ReentrantLock是独享锁；</p>
<p>读写锁ReentrantReadWriteLock中的读锁ReadLock是共享锁，写锁WriteLock是独享锁。</p>
<p>独享锁与共享锁通过AQS(AbstractQueuedSynchronizer)来实现的，通过实现不同的方法，来实现独享或者共享。</p>
<h3 id="3、互斥锁-amp-读写锁"><a href="#3、互斥锁-amp-读写锁" class="headerlink" title="3、互斥锁 &amp; 读写锁"></a>3、互斥锁 &amp; 读写锁</h3><p>上面讲的独享锁/共享锁就是一种概念，互斥锁/读写锁是具体的实现。</p>
<p><strong>互斥锁</strong>的具体实现就是synchronized、ReentrantLock。ReentrantLock是JDK1.5的新特性，采用ReentrantLock可以完全替代替换synchronized传统的锁机制，更加灵活。</p>
<p><strong>读写锁</strong>的具体实现就是读写锁ReadWriteLock。</p>
<h3 id="4、可重入锁"><a href="#4、可重入锁" class="headerlink" title="4、可重入锁"></a>4、可重入锁</h3><p>定义：对于同一个线程在外层方法获取锁的时候，在进入内层方法时也会自动获取锁。</p>
<p>优点：避免死锁</p>
<p>举例：ReentrantLock、synchronized</p>
<h3 id="5、公平锁-amp-非公平锁"><a href="#5、公平锁-amp-非公平锁" class="headerlink" title="5、公平锁 &amp; 非公平锁"></a>5、公平锁 &amp; 非公平锁</h3><p><strong>公平锁：</strong>多个线程相互竞争时要排队，多个线程按照申请锁的顺序来获取锁。</p>
<p><strong>非公平锁：</strong>多个线程相互竞争时，先尝试插队，插队失败再排队，比如：synchronized、ReentrantLock</p>
<h3 id="6、分段锁"><a href="#6、分段锁" class="headerlink" title="6、分段锁"></a>6、分段锁</h3><p>分段锁并不是具体的一种锁，只是一种锁的设计。</p>
<p>分段锁的设计目的是细化锁的粒度，当操作不需要更新整个数组的时候，就仅仅针对数组中的一项进行加锁操作。CurrentHashMap底层就用了分段锁，使用Segment，就可以进行并发使用了，而HashMap确实非线程安全的，就差在了分段锁上。</p>
<h3 id="7、偏向锁-amp-轻量级锁-amp-重量级锁"><a href="#7、偏向锁-amp-轻量级锁-amp-重量级锁" class="headerlink" title="7、偏向锁 &amp; 轻量级锁 &amp; 重量级锁"></a>7、偏向锁 &amp; 轻量级锁 &amp; 重量级锁</h3><p>JDK 1.6 为了减少获得锁和释放锁所带来的性能消耗，在JDK 1.6里引入了4种锁的状态：<strong>无锁、偏向锁、轻量级锁和重量级锁</strong>，它会随着多线程的竞争情况逐渐升级，但不能降级。</p>
<p>研究发现大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了不让这个线程每次获得锁都需要CAS操作的性能消耗，就引入了偏向锁。当一个线程访问对象并获取锁时，会在对象头里存储锁偏向的这个线程的ID，以后该线程再访问该对象时只需判断对象头的Mark Word里是否有这个线程的ID，如果有就不需要进行CAS操作，这就是偏向锁。当线程竞争更激烈时，偏向锁就会升级为轻量级锁，轻量级锁认为虽然竞争是存在的，但是理想情况下竞争的程度很低，通过自旋方式等待一会儿上一个线程就会释放锁，但是当自旋超过了一定次数，或者一个线程持有锁，一个线程在自旋，又来了第三个线程访问时（反正就是竞争继续加大了），轻量级锁就会膨胀为重量级锁，重量级锁就是Synchronized,重量级锁会使除了此时拥有锁的线程以外的线程都阻塞。</p>
<h2 id="Java数组和链表的区别"><a href="#Java数组和链表的区别" class="headerlink" title="Java数组和链表的区别"></a>Java数组和链表的区别</h2><p>从数据结构上说，数组的<strong>内存空间是连续的</strong>，我们创建数组的时候系统就会为我们开辟固定数目的内存空间，如果内存不足，就会创建失败，例如创建数组的两种方式：<br>int[] a=new int[3];<br>int[] b=new int[]{1,2,3};<br>可以看到我们创建数组的时候已经指定了数组的大小，且不能动态更改数组的大小，是因为创建时候已经分配了连续的固定内存空间，每个元素占用两个字节，这样我们就可以通过连续的内存，去访问数组的元素；</p>
<p><strong>链表的内存分配是动态的</strong>，链表的元素占用的空间包含元素占用的空间，还有指向上一个或者下一个元素的指针（双链表，单链表）；</p>
<p>这样我们可以得出各自的优缺点：</p>
<p>数组链表的优缺点：<br><strong>数组占用空间小</strong>，链表元素还要包涵上一元素和下一个元素的的信息<br><strong>数组的访问速度快</strong>，因为内存是连续的<br><strong>数组内部元素可以随机访问</strong>，而链表依赖于上一个元素的信息</p>
<p>链表的插入删除操作由于数组，因为内存不连续，只需要更改元素的前后节点信息就行了，并不需要更改元素内存地址，而数组的连续内存想要插入和删除的话就要移动所有的内存地址<br>链表的<strong>内存利用率高于数组</strong>，链表内存是分散的一个元素占用一块空间，数组元素少于内存空间的话，会有部分的内存浪费；<br>链表的<strong>扩展性强</strong>，数组的创建完成内存大小就确定了，满了就没法扩展只能再次创建新的数组，而链表可以随意的增加扩展</p>
<p>效率：数组查询效率高，链表增，删效率高</p>
<h2 id="列举两种单例模式"><a href="#列举两种单例模式" class="headerlink" title="列举两种单例模式"></a>列举两种单例模式</h2><p>Java中单例模式是一种常见的设计模式，单例模式的写法有好几种，这里主要介绍懒汉式单例、饿汉式单例.</p>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a><strong>介绍</strong></h3><p>意图：保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p>
<p>主要解决：一个全局使用的类频繁地创建与销毁。</p>
<p>何时使用：当您<strong>想控制实例数目，节省系统资源的时候。</strong></p>
<p>如何解决：判断系统是否已经有这个单例，如果有则返回，如果没有则创建。</p>
<p>关键代码：构造函数是私有的。</p>
<p>应用实例： 1、一个党只能有一个书记。 2、Windows 是多进程多线程的，在操作一个文件的时候，就不可避免地出现多个进程或线程同时操作一个文件的现象，所以所有文件的处理必须通过唯一的实例来进行。 3、一些设备管理器常常设计为单例模式，比如一个电脑有两台打印机，在输出的时候就要处理不能两台打印机打印同一个文件。</p>
<p>优点： 1、在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例（比如管理学院首页页面缓存）。 2、避免对资源的多重占用（比如写文件操作）。</p>
<p>缺点：没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。</p>
<p>使用场景： 1、要求生产唯一序列号。 2、WEB 中的计数器，不用每次刷新都在数据库里加一次，用单例先缓存起来。 3、创建的一个对象需要消耗的资源过多，比如 I/O 与数据库的连接等。</p>
<p>特点：</p>
<ol>
<li>单例模式只能有一个实例。</li>
<li>单例模式必须自己创建自己的唯一实例。</li>
<li>单例模式的构造器必须是私有，不允许外界通过构造器构建对象。</li>
<li>单例模式只能通过公开的静态方法向外界返回类的唯一实例。</li>
</ol>
<h3 id="饿汉式单例"><a href="#饿汉式单例" class="headerlink" title="饿汉式单例"></a><strong>饿汉式单例</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonEH</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *是否 Lazy 初始化：否</span></span><br><span class="line"><span class="comment">     *是否多线程安全：是</span></span><br><span class="line"><span class="comment">     *实现难度：易</span></span><br><span class="line"><span class="comment">     *描述：这种方式比较常用，但容易产生垃圾对象。</span></span><br><span class="line"><span class="comment">     *优点：没有加锁，执行效率会提高。</span></span><br><span class="line"><span class="comment">     *缺点：类加载时就初始化，浪费内存。</span></span><br><span class="line"><span class="comment">     *它基于 classloder 机制避免了多线程的同步问题，</span></span><br><span class="line"><span class="comment">     * 不过，instance 在类装载时就实例化，虽然导致类装载的原因有很多种，</span></span><br><span class="line"><span class="comment">    * 在单例模式中大多数都是调用 getInstance 方法，</span></span><br><span class="line"><span class="comment">     * 但是也不能确定有其他的方式（或者其他的静态方法）导致类装载，</span></span><br><span class="line"><span class="comment">     * 这时候初始化 instance 显然没有达到 lazy loading 的效果。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingletonEH instance = <span class="keyword">new</span> SingletonEH();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonEH</span> <span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonEH <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;instance:&quot;</span>+instance);</span><br><span class="line">        System.out.println(<span class="string">&quot;加载饿汉式....&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>饿汉就是类一旦加载，就把单例初始化完成，保证getInstance的时候，单例是已经存在的了。</p>
<h3 id="懒汉式单例"><a href="#懒汉式单例" class="headerlink" title="懒汉式单例"></a><strong>懒汉式单例</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonLH</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *是否 Lazy 初始化：是</span></span><br><span class="line"><span class="comment">     *是否多线程安全：否</span></span><br><span class="line"><span class="comment">     *实现难度：易</span></span><br><span class="line"><span class="comment">     *描述：这种方式是最基本的实现方式，这种实现最大的问题就是不支持多线程。因为没有加锁 synchronized，所以严格意义上它并不算单例模式。</span></span><br><span class="line"><span class="comment">     *这种方式 lazy loading 很明显，不要求线程安全，在多线程不能正常工作。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingletonLH instance;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonLH</span> <span class="params">()</span></span>&#123;&#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonLH <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> SingletonLH();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而懒汉比较懒，只有当调用getInstance的时候，才回去初始化这个单例。</p>
<h3 id="1、线程安全："><a href="#1、线程安全：" class="headerlink" title="1、线程安全："></a><strong>1、线程安全：</strong></h3><p>饿汉式天生就是线程安全的，可以直接用于多线程而不会出现问题，</p>
<p>懒汉式本身是非线程安全的，为了实现线程安全有几种写法。</p>
<p>例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">	</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonLHsyn</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *是否 Lazy 初始化：是</span></span><br><span class="line"><span class="comment">     *是否多线程安全：是</span></span><br><span class="line"><span class="comment">     *实现难度：易</span></span><br><span class="line"><span class="comment">     *描述：这种方式具备很好的 lazy loading，能够在多线程中很好的工作，但是，效率很低，99% 情况下不需要同步。</span></span><br><span class="line"><span class="comment">     *优点：第一次调用才初始化，避免内存浪费。</span></span><br><span class="line"><span class="comment">     *缺点：必须加锁 synchronized 才能保证单例，但加锁会影响效率。</span></span><br><span class="line"><span class="comment">     *getInstance() 的性能对应用程序不是很关键（该方法使用不太频繁）。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingletonLHsyn instance;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonLHsyn</span> <span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> SingletonLHsyn <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> SingletonLHsyn();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2、资源加载和性能："><a href="#2、资源加载和性能：" class="headerlink" title="2、资源加载和性能："></a><strong>2、资源加载和性能：</strong></h3><p>饿汉式在类创建的同时就实例化一个静态对象出来，不管之后会不会使用这个单例，都会占据一定的内存，但是相应的，在第一次调用时速度也会更快，因为其资源已经初始化完成。</p>
<p>而懒汉式顾名思义，会延迟加载，在第一次使用该单例的时候才会实例化对象出来，第一次调用时要做初始化，如果要做的工作比较多，性能上会有些延迟，之后就和饿汉式一样了。</p>
<h3 id="为什么要用单例模式？"><a href="#为什么要用单例模式？" class="headerlink" title="为什么要用单例模式？"></a><strong>为什么要用单例模式？</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Printer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Printer printer =<span class="keyword">null</span>;<span class="comment">//创建一个私有的全局变量</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 如果有多线程并发访问时，上锁，让其排队等候，一次只能一人用。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Printer <span class="title">getPrinter</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(printer==<span class="keyword">null</span>)&#123;<span class="comment">//如果为空，创建本实例</span></span><br><span class="line">            printer = <span class="keyword">new</span> Printer();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> printer;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 构造私有化，保证在系统的使用中，只有一个实例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Printer</span><span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从代码上来分析，单例模式，首先向外提供了一个可被访问的实例化的对象，如果没有此对象时，该printer类创建一个。如果遇到多线程并发访问，加上关键字Synchronized，上锁让没有持有该对象的类处于等待状态。当前持有该printer的线程任务结束之后，处于等待中的线程才能逐个去持有该实例，去操作其方法。这样的一个过程 在编程中被称为单例模式。<br>如果在系统中不使用单例模式的话，在碰到多线程访问的时候，<u>printer就会给要请求的类，分别在内存中new出一个printer对象</u>，让这些请求的类去做print方法。这样<u>大量占有内存，就会导致系统运行变慢</u>，像电脑的CPU一样，占有量极高，电脑卡死不动的感觉。因为系统的硬件设施需求变动量小，所以只能想出一个节约成本 的方法就是，单例模式，<u>让多线程处于等待的状态，一个 一个的去解决</u>，这样，即节约内存，提交了运行的成本。也就是单例存在的意义。</p>
<h2 id="重写和重载的区别"><a href="#重写和重载的区别" class="headerlink" title="重写和重载的区别"></a>重写和重载的区别</h2><p><strong>重写</strong>:</p>
<p>重写（Override）是<strong>父类与子类之间多态性的一种表现</strong>。如果在子类中定义某方法与其父类有<strong>相同的名称和参数</strong>，我们说该方法被重写 (Override)。子类的对象使用这个方法时，将调用子类中的定义，对它而言，父类中的定义如同被“<strong>屏蔽</strong>”了。</p>
<p><strong>重载：</strong></p>
<p>重载（Overload）是<strong>一个类中多态性的一种表现</strong>。如果在一个类中定义了多个同名的方法，它们<strong>参数列表不同</strong>，则称为方法的重载(Overload)</p>
<p><strong>区别：</strong>重载实现于一个类中;重写实现于子类中。</p>
<p>重载(Overload)：是一个类中多态性的一种表现，指同一个类中不同的函数使用<strong>相同的函数名</strong>，但是<strong>函数的参数个数或类型不同</strong>。可以有<strong>不同的返回类型</strong>;可以有不同的访问修饰符;可以抛出不同的异常。调用的时候根据函数的参数来区别不同的函数。</p>
<p>重写（Override): 是父类与子类之间的多态性，是<strong>子类对父类函数的重新实现</strong>。<strong>函数名和参数与父类一样</strong>，子类与父类<strong>函数体内容不一样</strong>。子类<strong>返回的类型</strong>必须与父类保持一致；子类方法访问修饰符的限制一定要大于父类方法的访问修饰（public&gt;protected&gt;default&gt;private）；子类重写方法一定不能抛出新的检查异常或者比被父类方法申明更加宽泛的检查型异常。</p>
<h2 id="重载"><a href="#重载" class="headerlink" title="重载"></a><strong>重载</strong></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.etime09;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Goods</span> </span>&#123;  <span class="comment">//创建一个商品类 </span></span><br><span class="line"><span class="keyword">private</span> String ID;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> price;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> String manufactureDate;</span><br><span class="line"><span class="comment">//实现构造函数的重载 参数个数或类型不同</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Goods</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">super</span>();</span><br><span class="line">	<span class="comment">// TODO Auto-generated constructor stub</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Goods</span><span class="params">(String iD)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">super</span>();</span><br><span class="line">	ID = iD;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Goods</span><span class="params">(String iD, <span class="keyword">int</span> price)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">super</span>();</span><br><span class="line">	ID = iD;</span><br><span class="line">	<span class="keyword">this</span>.price = price;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Goods</span><span class="params">(String iD, <span class="keyword">int</span> price, String name)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">super</span>();</span><br><span class="line">	ID = iD;</span><br><span class="line">	<span class="keyword">this</span>.price = price;</span><br><span class="line">	<span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Goods</span><span class="params">(String iD, <span class="keyword">int</span> price, String name, String manufactureDate)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">super</span>();</span><br><span class="line">	ID = iD;</span><br><span class="line">	<span class="keyword">this</span>.price = price;</span><br><span class="line">	<span class="keyword">this</span>.name = name;</span><br><span class="line">	<span class="keyword">this</span>.manufactureDate = manufactureDate;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="重写"><a href="#重写" class="headerlink" title="重写"></a><strong>重写</strong></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.etime09;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;  <span class="comment">//创建一个父类Person</span></span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"><span class="comment">//父类中写一个eat()方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;人都要吃饭&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br><span class="line">---------------------------------------------</span><br><span class="line"><span class="keyword">package</span> com.etime09;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;  <span class="comment">//Student子类继承Person父类</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="comment">//重写eat()方法   方法名，参数，返回类型相同；方法体内容不同</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	System.out.println(<span class="string">&quot;学生喜欢吃肉&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="面向对象三大特征"><a href="#面向对象三大特征" class="headerlink" title="面向对象三大特征"></a>面向对象三大特征</h2><h3 id="1-封装-Encapsulation"><a href="#1-封装-Encapsulation" class="headerlink" title="(1)封装(Encapsulation)"></a>(1)封装(Encapsulation)</h3><p><strong>所谓封装，也就是把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏</strong>。封装是面向对象的特征之一，是对象和类概念的主要特性。简单的说，一个类就是一个封装了数据以及操作这些数据的代码的逻辑实体。在一个对象内部，某些代码或某些数据可以是私有的，不能被外界访问。通过这种方式，对象对内部数据提供了不同级别的保护，以防止程序中无关的部分意外的改变或错误的使用了对象的私有部分。</p>
<hr>
<h3 id="2-继承-Inheritance"><a href="#2-继承-Inheritance" class="headerlink" title="(2)继承(Inheritance)"></a>(2)继承(Inheritance)</h3><p><strong>继承是指这样一种能力：它可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展</strong>。通过继承创建的新类称为“子类”或“派生类”，被继承的类称为“基类”、“父类”或“超类”。继承的过程，就是从一般到特殊的过程。要实现继承，可以通过“继承”（Inheritance）和“组合”（Composition）来实现。继承概念的实现方式有二类：<strong>实现继承与接口继承</strong>。</p>
<ul>
<li>实现继承是指直接使用基类的属性和方法而无需额外编码的能力；</li>
<li>接口继承是指仅使用属性和方法的名称、但是子类必须提供实现的能力。</li>
</ul>
<hr>
<h3 id="3-多态-Polymorphism"><a href="#3-多态-Polymorphism" class="headerlink" title="(3)多态(Polymorphism)"></a>(3)多态(Polymorphism)</h3><p><strong>所谓多态就是指一个类实例的相同方法在不同情形有不同表现形式。多态机制使具有不同内部结构的对象可以共享相同的外部接口</strong>。这意味着，虽然针对不同对象的具体操作不同，但通过一个公共的类，它们（那些操作）可以通过相同的方式予以调用。最常见的多态就是将子类传入父类参数中，运行时调用父类方法时通过传入的子类决定具体的内部结构或行为。</p>
<h2 id="MySQL两种引擎"><a href="#MySQL两种引擎" class="headerlink" title="MySQL两种引擎"></a>MySQL两种引擎</h2><p>MySQL应用最广泛的有两种存储引擎：</p>
<p><strong>一个是MyISAM</strong>，不支持事务处理，读性能处理快，表级别锁。</p>
<p><strong>一个是InnoDB</strong>，支持事务处理（ACID属性）,设计目标是为大数据处理，行级别锁，外键。</p>
<p>ACID（Atomicity 原子性、Consistency 一致性、Isolation 隔离性、Durability 持久性）是一系列属性</p>
<p>表锁：开销小，锁定粒度大，发生死锁概率高，相对并发也低。<br>行锁：开销大，锁定粒度小，发生死锁概率低，相对并发也高。</p>
<p>InnoDB不支持FULLTEXT类型的索引。</p>
<p>InnoDB 中不保存表的具体行数，也就是说，执行select count(<em>) from table时，InnoDB要扫描一遍整个表来计算有多少行，但是MyISAM只要简单的读出保存好的行数即可。注意的是，当count(</em>)语句包含 where条件时，两种表的操作是一样的。</p>
<p>对于AUTO_INCREMENT类型的字段，InnoDB中必须包含只有该字段的索引，但是在MyISAM表中，可以和其他字段一起建立联合索引。</p>
<p>DELETE FROM table时，InnoDB不会重新建立表，而是一行一行的删除。</p>
<p>LOAD TABLE FROM MASTER操作对InnoDB是不起作用的，解决方法是首先把InnoDB表改成MyISAM表，导入数据后再改成InnoDB表，但是对于使用的额外的InnoDB特性(例如外键)的表不适用。</p>
<p>另外，InnoDB表的行锁也不是绝对的，假如在执行一个SQL语句时MySQL不能确定要扫描的范围，InnoDB表同样会锁全表，例如update table set num=1 where name like “%aaa%”</p>
<p>作为使用MySQL的用户角度出发，Innodb和MyISAM都是比较喜欢的，如果数据库平台要达到需求：99.9%的稳定性，方便的扩展性和高可用性来说的话，MyISAM绝对是首选。</p>
<p>　　原因如下：</p>
<p>　　1、平台上承载的大部分项目是读多写少的项目，而MyISAM的读性能是比Innodb强不少的。</p>
<p>　　2、MyISAM的索引和数据是分开的，并且索引是有压缩的，内存使用率就对应提高了不少。能加载更多索引，而Innodb是索引和数据是紧密捆绑的，没有使用压缩从而会造成Innodb比MyISAM体积庞大不小。</p>
<p>　　3、经常隔1，2个月就会发生应用开发人员不小心update一个表where写的范围不对，导致这个表没法正常用了，这个时候MyISAM的优越性就体现出来了，随便从当天拷贝的压缩包取出对应表的文件，随便放到一个数据库目录下，然后dump成sql再导回到主库，并把对应的binlog补上。如果是Innodb，恐怕不可能有这么快速度，别和我说让Innodb定期用导出xxx.sql机制备份，因为最小的一个数据库实例的数据量基本都是几十G大小。</p>
<p>　　4、从接触的应用逻辑来说，select count(*) 和order by 是最频繁的，大概能占了整个sql总语句的60%以上的操作，而这种操作Innodb其实也是会锁表的，很多人以为Innodb是行级锁，那个只是where对它主键是有效，非主键的都会锁全表的。</p>
<p>　　5、还有就是经常有很多应用部门需要我给他们定期某些表的数据，MyISAM的话很方便，只要发给他们对应那表的frm.MYD,MYI的文件，让他们自己在对应版本的数据库启动就行，而Innodb就需要导出xxx.sql了，因为光给别人文件，受字典数据文件的影响，对方是无法使用的。</p>
<p>　　6、如果和MyISAM比insert写操作的话，Innodb还达不到MyISAM的写性能，如果是针对基于索引的update操作，虽然MyISAM可能会逊色Innodb,但是那么高并发的写，从库能否追的上也是一个问题，还不如通过多实例分库分表架构来解决。</p>
<p>　　7、如果是用MyISAM的话，merge引擎可以大大加快应用部门的开发速度，他们只要对这个merge表做一些select count(*)操作，非常适合大项目总量约几亿的rows某一类型(如日志，调查统计)的业务表。</p>
<p>　　当然Innodb也不是绝对不用，用事务的项目就用Innodb的。另外，可能有人会说你MyISAM无法抗太多写操作，但是可以通过架构来弥补。</p>
<h2 id="预防死锁"><a href="#预防死锁" class="headerlink" title="预防死锁"></a>预防死锁</h2><p><strong>死锁</strong><br>当线程A持有独占锁a，并尝试去获取独占锁b的同时，线程B持有独占锁b，并尝试获取独占锁a的情况下，就会发生AB两个线程由于互相持有对方需要的锁，而发生的阻塞现象，我们称为死锁。</p>
<p><strong>如何避免死锁？</strong></p>
<p>教科书般的回答应该是，结合“哲学家就餐”模型，分析并总结出以下死锁的原因，最后得出“避免死锁就是破坏造成死锁的，若干条件中的任意一个”的结论。</p>
<p>造成死锁必须达成的4个条件（原因）：</p>
<ol>
<li><strong>互斥条件</strong>：一个资源每次只能被一个线程使用。</li>
<li><strong>请求与保持条件</strong>：一个线程因请求资源而阻塞时，对已获得的资源保持不放。</li>
<li><strong>不剥夺条件</strong>：线程已获得的资源，在未使用完之前，不能强行剥夺。</li>
<li><strong>循环等待条件</strong>：若干线程之间形成一种头尾相接的循环等待资源关系。</li>
</ol>
<p>但是，“哲学家就餐”光看名字就很讨厌，然后以上这4个条件看起来也很绕口，再加上笔者又是个懒人，所以要让我在面试时把这些“背诵”出来实在是太难了！必须要想办法把这4个条件简化一下！<br> 于是，通过对4个造成死锁的条件进行逐条分析，我们可以得出以下4个结论。</p>
<ol>
<li>互斥条件 —&gt; 独占锁的特点之一。</li>
<li>请求与保持条件 —&gt; 独占锁的特点之一，尝试获取锁时并不会释放已经持有的锁</li>
<li>不剥夺条件 —&gt; 独占锁的特点之一。</li>
<li>循环等待条件 —&gt; 唯一需要记忆的造成死锁的条件。</li>
</ol>
<p>不错！复杂的死锁条件经过简化，现在需要记忆的仅只有独占锁与第四个条件而已。</p>
<p>所以，面对如何避免死锁这个问题，我们只需要这样回答！<br> :   在并发程序中，避免了逻辑中出现复数个线程互相持有对方线程所需要的独占锁的情况，就可以避免死锁。</p>
<h2 id="JVM内存结构-VS-Java内存模型-VS-Java对象模型"><a href="#JVM内存结构-VS-Java内存模型-VS-Java对象模型" class="headerlink" title="JVM内存结构 VS Java内存模型 VS Java对象模型"></a>JVM内存结构 VS Java内存模型 VS Java对象模型</h2><h3 id="JVM内存结构"><a href="#JVM内存结构" class="headerlink" title="JVM内存结构"></a>JVM内存结构</h3><p>Java代码是要运行在虚拟机上的，而虚拟机在执行Java程序的过程中会把所管理的内存划分为若干个不同的数据区域，这些区域都有各自的用途。其中有些区域随着虚拟机进程的启动而存在，而有些区域则依赖用户线程的启动和结束而建立和销毁。</p>
<p><img src="C:%5CUsers%5CPowerwenwh%5CDocuments%5CMyBlog%5Csource%5C_posts%5Cimgs%5CJava%E5%9F%BA%E7%A1%80%5CQQ20180624-150918.png" alt="QQ20180624-150918"></p>
<p>1、以上是Java虚拟机规范，不同的虚拟机实现会各有不同，但是一般会遵守规范。</p>
<p>2、规范中定义的方法区，只是一种概念上的区域，并说明了其应该具有什么功能。但是并没有规定这个区域到底应该处于何处。所以，对于不同的虚拟机实现来说，是由一定的自由度的。</p>
<p>3、不同版本的方法区所处位置不同，上图中划分的是逻辑区域，并不是绝对意义上的物理区域。因为某些版本的JDK中方法区其实是在堆中实现的。</p>
<p>4、运行时常量池用于存放编译期生成的各种字面量和符号应用。但是，Java语言并不要求常量只有在编译期才能产生。比如在运行期，String.intern也会把新的常量放入池中。</p>
<p>5、除了以上介绍的JVM运行时内存外，还有一块内存区域可供使用，那就是直接内存。Java虚拟机规范并没有定义这块内存区域，所以他并不由JVM管理，是利用本地方法库直接在堆外申请的内存区域。</p>
<p>6、堆和栈的数据划分也不是绝对的，如HotSpot的JIT会针对对象分配做相应的优化。</p>
<p>如上，做个总结，JVM内存结构，由Java虚拟机规范定义。描述的是Java程序执行过程中，由JVM管理的不同数据区域。各个区域有其特定的功能。</p>
<h3 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h3><p>Java内存模型看上去和Java内存结构（JVM内存结构）差不多，很多人会误以为两者是一回事。</p>
<p>在前面的关于JVM的内存结构的图中，我们可以看到，其中Java堆和方法区的区域是多个线程共享的数据区域。也就是说，多个线程可能可以操作保存在堆或者方法区中的同一个数据。这也就是我们常说的“Java的线程间通过共享内存进行通信”。</p>
<p>Java内存模型是根据英文Java Memory Model（JMM）翻译过来的。其实JMM并不像JVM内存结构一样是真实存在的。他只是一个<strong>抽象的概念</strong>。<a target="_blank" rel="noopener" href="http://www.cs.umd.edu/~pugh/java/memoryModel/jsr133.pdf">JSR-133: Java Memory Model and Thread Specification</a>中描述了，JMM是<strong>和多线程相关的</strong>，他描述了<strong>一组规则或规范</strong>，这个规范定义了一个线程对共享变量的写入时对另一个线程是可见的。</p>
<p>那么，简单总结下，<strong>Java的多线程之间是通过共享内存进行通信的</strong>，而由于采用共享内存进行通信，在通信过程中会存在一系列如<strong>可见性、原子性、顺序性等问题</strong>，而JMM就是围绕着多线程通信以及与其相关的一系列特性而建立的模型。JMM定义了一些语法集，这些语法集映射到Java语言中就是volatile、synchronized等关键字。</p>
<p><a target="_blank" rel="noopener" href="http://www.hollischuang.com/wp-content/uploads/2018/06/11.png"><img src="C:%5CUsers%5CPowerwenwh%5CDocuments%5CMyBlog%5Csource%5C_posts%5Cimgs%5CJava%E5%9F%BA%E7%A1%80%5C11.png" alt="11"></a></p>
<p>在Java中，JMM是一个非常重要的概念，正是由于有了JMM，Java的并发编程才能避免很多问题。这里就不对Java内存模型做更加详细的介绍了，想了解更多的朋友可以参考《Java并发编程的艺术》。</p>
<h3 id="Java对象模型"><a href="#Java对象模型" class="headerlink" title="Java对象模型"></a>Java对象模型</h3><p>Java是一种面向对象的语言，而Java对象在JVM中的存储也是有一定的结构的。而这个关于Java对象自身的存储模型称之为Java对象模型。</p>
<p>HotSpot虚拟机中，设计了一个OOP-Klass Model。OOP（Ordinary Object Pointer）指的是普通对象指针，而Klass用来描述对象实例的具体类型。</p>
<p>每一个Java类，在被JVM加载的时候，JVM会给这个类创建一个<code>instanceKlass</code>，保存在方法区，用来在JVM层表示该Java类。当我们在Java代码中，使用new创建一个对象的时候，JVM会创建一个<code>instanceOopDesc</code>对象，这个对象中包含了对象头以及实例数据。</p>
<p><a target="_blank" rel="noopener" href="http://www.hollischuang.com/wp-content/uploads/2018/06/20170615230126453.jpeg"><img src="C:%5CUsers%5CPowerwenwh%5CDocuments%5CMyBlog%5Csource%5C_posts%5Cimgs%5CJava%E5%9F%BA%E7%A1%80%5C20170615230126453.jpeg" alt="20170615230126453"></a></p>
<p>这就是一个简单的Java对象的OOP-Klass模型，即Java对象模型。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>我们再来区分下JVM内存结构、 Java内存模型 以及 Java对象模型 三个概念。</p>
<p>JVM内存结构，和Java虚拟机的运行时区域有关。 Java内存模型，和Java的并发编程有关。 Java对象模型，和Java对象在虚拟机中的表现形式有关。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://wenwenhuan.gitee.io/2021/04/12/Java%E9%9B%86%E5%90%88%E5%B9%B6%E5%8F%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="温文焕">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wenhuan Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/04/12/Java%E9%9B%86%E5%90%88%E5%B9%B6%E5%8F%91/" class="post-title-link" itemprop="url">Java的集合并发常用知识点</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-04-12 23:11:00 / 修改时间：23:17:58" itemprop="dateCreated datePublished" datetime="2021-04-12T23:11:00+08:00">2021-04-12</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="java并发面试题"><a href="#java并发面试题" class="headerlink" title="java并发面试题"></a>java并发面试题</h2><p>什么是多线程环境下的伪共享(false sharing)？<br>答：在多核的CPU架构中，每个<strong>处理器都有自己的局部缓存</strong>，<strong>缓存系统是以缓存行为单位存储</strong>的，当多线程修改互相独立的变量时，如果这些变量共享同一个缓存行，就会无意中影响彼此的性能，这就是伪共享。</p>
<p>同步和异步有何异同？<br>答：同步就是事情必须一件一件的做，下一件事的开始必须在上一件事结束后。异步就是下一件事的开始无需等待上一件事的结束，两件事之间没有强关联。</p>
<p>调用start()方法时会执行run()方法，为什么不能直接调用run()方法？<br>答：调用start()方法时，JVM底层会帮我们生产新的线程，然后再通过这个线程来调用run()方法里的逻辑，而直接调用run()方法则不同，不会产生新线程，就是简简单单把run()方法当成普通方法运行。</p>
<p>stop()方法和 suspend()方法为何不推荐使用？<br>答: 首先两者都做到停止线程的效果，其中stop() 方法的停止很暴力，<strong>不安全</strong>，容易造成数据的不一致。而 suspend() 方法的停止很无赖，它<strong>不会释放锁</strong>，这就容易造成死锁了。</p>
<p>如何让正在运行的线程暂停一段时间？<br>答:使用sleep()方法或wait()方法。</p>
<p>线程状态，BLOCKD和WAITING有什么区别？<br>答:当线程无法进入同步方法或者同步代码块中时，线程状态就是BLOCKD，这个线程这时处于同步队列。当线程调用了wait，join等方法就会进入WAITING状态，这时线程处于等待队列。当处于等待队列的线程通过notify()，notifyAll()等方法被唤醒时，就会进入同步队列。</p>
<p>提交任务时，线程池队列已满时会发会生什么？<br>答:调用拒绝策略，可参考本篇博客【<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_38106322/article/details/104121861">简单了解线程池</a>】中的线程池工作流程图。</p>
<p>ThreadPoolExecutor.AbortPolicy:丢弃任务并抛出RejectedExecutionException异常。注：默认策略！！！！！！</p>
<p>ThreadPoolExecutor.DiscardPolicy：也是丢弃任务，但是不抛出异常。</p>
<p>ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）</p>
<p>ThreadPoolExecutor.CallerRunsPolicy：由调用线程处理该任务</p>
<p>线程池中submit() 和 execute()方法有什么区别？<br>答:两者都可以用于向线程池提交任务。不过<strong>submit()方法的返回值是Future类型，而execute()方法无返回值。</strong>submit()方法方便Exception处理。</p>
<p>说说什么是CountDownLatch？<br>答:可参考本篇博客【<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_38106322/article/details/103743113">CountDownLatch的简单应用和实现原理</a> 】。</p>
<p>说说什么是CyclicBarrier?<br>答:可参考本篇博客【<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_38106322/article/details/103830014">CyclicBarrier的简单使用</a>】。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://wenwenhuan.gitee.io/2021/04/12/Linux/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="温文焕">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wenhuan Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/04/12/Linux/" class="post-title-link" itemprop="url">Linux的一些基础知识点</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-04-12 23:11:00" itemprop="dateCreated datePublished" datetime="2021-04-12T23:11:00+08:00">2021-04-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2021-04-20 11:57:00" itemprop="dateModified" datetime="2021-04-20T11:57:00+08:00">2021-04-20</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="Linux查看内存使用情况"><a href="#Linux查看内存使用情况" class="headerlink" title="Linux查看内存使用情况"></a>Linux查看内存使用情况</h2><p>包括：free、top、cat /proc/meminfo、vmstat、ps</p>
<h3 id="1-top命令"><a href="#1-top命令" class="headerlink" title="1. top命令"></a>1. top命令</h3><img src="/2021/04/12/Linux/image-20210407204911221.png" class="" title="image-20210407204911221">

<p>内容分析：</p>
<p>   PID：进程的ID</p>
<p>   USER：进程所有者</p>
<p>​    PR：进程的优先级别，越小越优先被执行</p>
<p>​    NI：进程Nice值，代表这个进程的优先值</p>
<p>​    VIRT：进程占用的虚拟内存</p>
<p>​    RES：进程占用的物理内存</p>
<p>​    SHR：进程使用的共享内存</p>
<p>   S：进程的状态。S表示休眠，R表示正在运行，Z表示僵死状态</p>
<p>​    %CPU：进程占用CPU的使用</p>
<p>​    %MEM：进程使用的物理内存和总内存的百分</p>
<p>​    TIME+：该进程启动后占用的总的CPU时间，即占用CPU使用时间的累加值</p>
<p>​    COMMAND：启动该进程的命令名称</p>
<h3 id="2-free命令："><a href="#2-free命令：" class="headerlink" title="2. free命令："></a>2. free命令：</h3><p>输入命令分类：</p>
<p>free   用KB为单位展示数据</p>
<p>free -m   用MB为单位展示数据</p>
<p>free -h   用GB为单位展示数据</p>
<img src="/2021/04/12/Linux/image-20210407205121916.png" class="" title="image-20210407205121916">

<p>total : 总计物理内存的大小</p>
<p>used : 已使用内存的大小</p>
<p>free : 可用内存的大小</p>
<p>shared : 多个进程共享的内存总额</p>
<p>buff/cache : 磁盘缓存大小</p>
<p>available : 可用内存大小 ， 从应用程序的角度来说：available = free + buff/cache .</p>
<h3 id="3-cat-proc-meminfo-命令："><a href="#3-cat-proc-meminfo-命令：" class="headerlink" title="3. cat  /proc/meminfo 命令："></a>3. cat  /proc/meminfo 命令：</h3><img src="/2021/04/12/Linux/image-20210407205332503.png" class="" title="image-20210407205332503">

<p>这是用来查看RAM使用情况最简单的方法。 这个动态更新的虚拟文件实际上是许多其他内存相关工具的组合显示，就如上面说列的 top, free等。它列出了所有我们想了解的内存的使用情况。</p>
<p>进程的内存使用信息也可以通过： /proc//statm 和 /proc//status 来查看。</p>
<h3 id="4-ps-命令：用于显示当前进程的状态"><a href="#4-ps-命令：用于显示当前进程的状态" class="headerlink" title="4. ps 命令：用于显示当前进程的状态"></a>4. ps 命令：用于显示当前进程的状态</h3><p>输入内容方式：</p>
<p>ps aux ：按照 pid 显示内容 （默认排序方式）</p>
<p>ps aux –sort -rss : 按照 rss 排序显示内容</p>
<img src="/2021/04/12/Linux/image-20210407205451578.png" class="" title="image-20210407205451578">

<h3 id="5-vmstat-命令："><a href="#5-vmstat-命令：" class="headerlink" title="5. vmstat 命令："></a>5. vmstat 命令：</h3><p>输入命令：</p>
<p>vmstat -s</p>
<p>输出内容：</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://wenwenhuan.gitee.io/2021/04/12/OS/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="温文焕">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wenhuan Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/04/12/OS/" class="post-title-link" itemprop="url">操作系统常用知识点</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-04-12 23:11:00" itemprop="dateCreated datePublished" datetime="2021-04-12T23:11:00+08:00">2021-04-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2021-05-12 12:05:54" itemprop="dateModified" datetime="2021-05-12T12:05:54+08:00">2021-05-12</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><h3 id="进程和线程是什么的最新答法"><a href="#进程和线程是什么的最新答法" class="headerlink" title="进程和线程是什么的最新答法"></a>进程和线程是什么的最新答法</h3><p>进程：指在系统中正在运行的一个应用程序；程序一旦运行就是进程；进程——资源分配的最小单位。</p>
<p>线程：系统分配处理器时间资源的基本单元，或者说进程之内独立执行的一个单元执行流。线程——程序执行的最小单位。</p>
<h3 id="进程基本介绍"><a href="#进程基本介绍" class="headerlink" title="进程基本介绍"></a>进程基本介绍</h3><p>进程是程序执行时的一个实例，<strong>是系统进行资源分配的基本单位</strong>。所有与该进程有关的资源，都被记录在进程控制块(PCB)中。以表示该进程拥有这些资源或正在使用它们。另外，进程也是抢占处理机的调度单位，它拥有一个完整的虚拟地址空间。当进程发生调度时，<strong>不同的进程拥有不同的虚拟地址空间</strong>，而同一进程内的不同线程共享同一地址空间。</p>
<p><strong>程序运行时系统就会创建一个进程，并为它分配资源，然后把该进程放入进程就绪队列</strong>，进程调度器选中它的时候就会为它分配CPU时间，程序开始真正运行。</p>
<h4 id="记不住就这怎么答："><a href="#记不住就这怎么答：" class="headerlink" title="记不住就这怎么答："></a>记不住就这怎么答：</h4><blockquote>
<p>进程是<strong>是系统进行资源分配的基本单位</strong>，<strong>进程拥有自己的虚拟地址空间</strong>，<strong>程序运行时系统就会创建一个进程，并为它分配资源，然后把该进程放入进程就绪队列</strong>。</p>
</blockquote>
<h3 id="线程基本介绍"><a href="#线程基本介绍" class="headerlink" title="线程基本介绍"></a>线程基本介绍</h3><p>线程，有时也被称为轻量级进程，是程序执行流的最小单元，是进程中的一个实体，<strong>是被系统独立调度和分派的基本单位</strong>。与进程不同，线程与资源分配无关，线程自己不拥有系统资源，它属于某一个进程，并与进程内的其他线程一起共享进程的资源。线程只由相关堆栈（系统栈或用户栈）寄存器和线程控制表TCB组成。</p>
<p><strong>它是进程的一个执行流</strong>，</p>
<h4 id="记不住就这怎么答：-1"><a href="#记不住就这怎么答：-1" class="headerlink" title="记不住就这怎么答："></a>记不住就这怎么答：</h4><blockquote>
<p><strong>线程是进程的一个执行流</strong>，<strong>是CPU调度和分派的基本单位</strong>，<strong>线程间共享进程的所有资源</strong>。</p>
</blockquote>
<h3 id="进程与线程的区别"><a href="#进程与线程的区别" class="headerlink" title="进程与线程的区别"></a>进程与线程的区别</h3><p>地址空间：线程共享本进程的地址空间，而进程之间是独立的地址空间。</p>
<p>切换：</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/coder-programming/p/10595804.html">https://www.cnblogs.com/coder-programming/p/10595804.html</a></p>
<p>根本区别：进程是操作系统资源分配的基本单位，而线程是任务调度和执行的基本单位</p>
<p>在<strong>开销</strong>方面：每个进程都有独立的代码和数据空间（程序上下文），程序之间的切换会有较大的开销；线程可以看做轻量级的进程，同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器（PC），线程之间切换的开销小。</p>
<p><strong>所处环境</strong>：在操作系统中能同时运行多个进程（程序）；而在同一个进程（程序）中有多个线程同时执行（通过CPU调度，在每个时间片中只有一个线程执行）</p>
<p><strong>内存分配方面</strong>：系统在运行的时候会为每个进程分配不同的内存空间；而对线程而言，除了CPU外，系统不会为线程分配内存（线程所使用的资源来自其所属进程的资源），线程组之间只能共享资源。</p>
<p>包含关系：没有线程的进程可以看做是单线程的，如果一个进程内有多个线程，则执行过程不是一条线的，而是多条线（线程）共同完成的；线程是进程的一部分，所以线程也被称为轻权进程或者轻量级进程。</p>
<h3 id="进程的五种基本状态"><a href="#进程的五种基本状态" class="headerlink" title="进程的五种基本状态"></a>进程的五种基本状态</h3><img src="/2021/04/12/OS/image-20210415081219424.png" class="" title="image-20210415081219424">

<ul>
<li>创建状态：进程在创建时需要申请一个空白PCB，向其中填写控制和管理进程的信息，完成资源分配。如果创建工作无法完成，比如资源无法满足，就无法被调度运行，把此时进程所处状态称为创建状态</li>
<li>就绪状态：进程已经准备好，已分配到所需资源，只要分配到CPU就能够立即运行</li>
<li>执行状态：进程处于就绪状态被调度后，进程进入执行状态</li>
<li>阻塞状态：正在执行的进程由于某些事件（I/O请求，申请缓存区失败）而暂时无法运行，进程受到阻塞。在满足请求时进入就绪状态等待系统调用</li>
<li>终止状态：进程结束，或出现错误，或被系统终止，进入终止状态。无法再执行</li>
</ul>
<h3 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/gatieme/article/details/50908749">https://blog.csdn.net/gatieme/article/details/50908749</a></p>
<ol>
<li>管道（pipe）,流管道(s_pipe)和有名管道（FIFO）</li>
<li>信号（signal）</li>
<li>消息队列</li>
<li>共享内存</li>
<li>信号量</li>
<li>套接字（socket)</li>
</ol>
<h2 id="计算机内存模型"><a href="#计算机内存模型" class="headerlink" title="计算机内存模型"></a>计算机内存模型</h2><h2 id="为什么要有内存模型"><a href="#为什么要有内存模型" class="headerlink" title="为什么要有内存模型"></a>为什么要有内存模型</h2><p>在介绍Java内存模型之前，先来看一下到底什么是计算机内存模型，然后再来看Java内存模型在计算机内存模型的基础上做了哪些事情。要说计算机的内存模型，就要说一下一段古老的历史，看一下为什么要有内存模型。</p>
<p><strong>内存模型，英文名Memory Model，他是一个很老的老古董了。他是与计算机硬件有关的一个概念。那么我先给你介绍下他和硬件到底有啥关系。</strong></p>
<h3 id="CPU和缓存一致性"><a href="#CPU和缓存一致性" class="headerlink" title="CPU和缓存一致性"></a>CPU和缓存一致性</h3><p>我们应该都知道，计算机在执行程序的时候，每条指令都是在CPU中执行的，而执行的时候，又免不了要和数据打交道。而计算机上面的数据，是存放在主存当中的，也就是计算机的物理内存啦。</p>
<p>刚开始，还相安无事的，但是随着CPU技术的发展，CPU的执行速度越来越快。而由于内存的技术并没有太大的变化，所以从内存中读取和写入数据的过程和CPU的执行速度比起来差距就会越来越大,这就导致CPU每次操作内存都要耗费很多等待时间。</p>
<blockquote>
<p>这就像一家创业公司，刚开始，创始人和员工之间工作关系其乐融融，但是随着创始人的能力和野心越来越大，逐渐和员工之间出现了差距，普通员工原来越跟不上CEO的脚步。老板的每一个命令，传到到基层员工之后，由于基层员工的理解能力、执行能力的欠缺，就会耗费很多时间。这也就无形中拖慢了整家公司的工作效率。</p>
</blockquote>
<p>可是，不能因为内存的读写速度慢，就不发展CPU技术了吧，总不能让内存成为计算机处理的瓶颈吧。</p>
<p>所以，人们想出来了一个好的办法，就是在CPU和内存之间增加高速缓存。缓存的概念大家都知道，就是保存一份数据拷贝。他的特点是速度快，内存小，并且昂贵。</p>
<p>那么，程序的执行过程就变成了：</p>
<p><strong>当程序在运行过程中，会将运算需要的数据从主存复制一份到CPU的高速缓存当中，那么CPU进行计算时就可以直接从它的高速缓存读取数据和向其中写入数据，当运算结束之后，再将高速缓存中的数据刷新到主存当中。</strong></p>
<blockquote>
<p>之后，这家公司开始设立中层管理人员，管理人员直接归CEO领导，领导有什么指示，直接告诉管理人员，然后就可以去做自己的事情了。管理人员负责去协调底层员工的工作。因为管理人员是了解手下的人员以及自己负责的事情的。所以，大多数时候，公司的各种决策，通知等，CEO只要和管理人员之间沟通就够了。</p>
</blockquote>
<p>而随着CPU能力的不断提升，一层缓存就慢慢的无法满足要求了，就逐渐的衍生出多级缓存。</p>
<p>按照数据读取顺序和与CPU结合的紧密程度，CPU缓存可以分为一级缓存（L1），二级缓存（L3），部分高端CPU还具有三级缓存（L3），每一级缓存中所储存的全部数据都是下一级缓存的一部分。</p>
<p>这三种缓存的技术难度和制造成本是相对递减的，所以其容量也是相对递增的。</p>
<p>那么，在有了多级缓存之后，程序的执行就变成了：</p>
<p><strong>当CPU要读取一个数据时，首先从一级缓存中查找，如果没有找到再从二级缓存中查找，如果还是没有就从三级缓存或内存中查找。</strong></p>
<blockquote>
<p>随着公司越来越大，老板要管的事情越来越多，公司的管理部门开始改革，开始出现高层，中层，底层等管理者。一级一级之间逐层管理。</p>
</blockquote>
<p>单核CPU只含有一套L1，L2，L3缓存；如果CPU含有多个核心，即多核CPU，则每个核心都含有一套L1（甚至和L2）缓存，而共享L3（或者和L2）缓存。</p>
<blockquote>
<p>公司也分很多种，有些公司只有一个大Boss，他一个人说了算。但是有些公司有比如联席总经理、合伙人等机制。</p>
<p>单核CPU就像一家公司只有一个老板，所有命令都来自于他，那么就只需要一套管理班底就够了。</p>
<p>多核CPU就像一家公司是由多个合伙人共同创办的，那么，就需要给每个合伙人都设立一套供自己直接领导的高层管理人员，多个合伙人共享使用的是公司的底层员工。</p>
<p>还有的公司，不断壮大，开始差分出各个子公司。各个子公司就是多个CPU了，互相之前没有共用的资源。互不影响。</p>
</blockquote>
<p>下图为一个单CPU双核的缓存结构。</p>
<img src="/2021/04/12/OS/image-20210415081321290.png" class="" title="image-20210415081321290">

<p>随着计算机能力不断提升，开始支持多线程。那么问题就来了。我们分别来分析下单线程、多线程在单核CPU、多核CPU中的影响。</p>
<p><strong>单线程。</strong>cpu核心的缓存只被一个线程访问。缓存独占，不会出现访问冲突等问题。</p>
<p><strong>单核CPU，多线程。</strong>进程中的多个线程会同时访问进程中的共享数据，CPU将某块内存加载到缓存后，不同线程在访问相同的物理地址的时候，都会映射到相同的缓存位置，这样即使发生线程的切换，缓存仍然不会失效。但由于任何时刻只能有一个线程在执行，因此不会出现缓存访问冲突。</p>
<p><strong>多核CPU，多线程。</strong>每个核都至少有一个L1 缓存。多个线程访问进程中的某个共享内存，且这多个线程分别在不同的核心上执行，则每个核心都会在各自的caehe中保留一份共享内存的缓冲。由于多核是可以并行的，可能会出现多个线程同时写各自的缓存的情况，而各自的cache之间的数据就有可能不同。</p>
<p>在CPU和主存之间增加缓存，在多线程场景下就可能存在<strong>缓存一致性问题</strong>，也就是说，在多核CPU中，每个核的自己的缓存中，关于同一个数据的缓存内容可能不一致。</p>
<blockquote>
<p>如果这家公司的命令都是串行下发的话，那么就没有任何问题。</p>
<p>如果这家公司的命令都是并行下发的话，并且这些命令都是由同一个CEO下发的，这种机制是也没有什么问题。因为他的命令执行者只有一套管理体系。</p>
<p>如果这家公司的命令都是并行下发的话，并且这些命令是由多个合伙人下发的，这就有问题了。因为每个合伙人只会把命令下达给自己直属的管理人员，而多个管理人员管理的底层员工可能是公用的。</p>
<p>比如，合伙人1要辞退员工a，合伙人2要给员工a升职，升职后的话他再被辞退需要多个合伙人开会决议。两个合伙人分别把命令下发给了自己的管理人员。合伙人1命令下达后，管理人员a在辞退了员工后，他就知道这个员工被开除了。而合伙人2的管理人员2这时候在没得到消息之前，还认为员工a是在职的，他就欣然的接收了合伙人给他的升职a的命令。</p>
</blockquote>
<img src="/2021/04/12/OS/image-20210415081258412.png" class="" title="image-20210415081258412">

<h3 id="处理器优化和指令重排"><a href="#处理器优化和指令重排" class="headerlink" title="处理器优化和指令重排"></a>处理器优化和指令重排</h3><p>上面提到在在CPU和主存之间增加缓存，在多线程场景下会存在<strong>缓存一致性问题</strong>。除了这种情况，还有一种硬件问题也比较重要。那就是为了使处理器内部的运算单元能够尽量的被充分利用，处理器可能会对输入代码进行乱序执行处理。这就是<strong>处理器优化</strong>。</p>
<p>除了现在很多流行的处理器会对代码进行优化乱序处理，很多编程语言的编译器也会有类似的优化，比如Java虚拟机的即时编译器（JIT）也会做<strong>指令重排</strong>。</p>
<p>可想而知，如果任由处理器优化和编译器对指令重排的话，就可能导致各种各样的问题。</p>
<blockquote>
<p>关于员工组织调整的情况，如果允许人事部在接到多个命令后进行随意拆分乱序执行或者重排的话，那么对于这个员工以及这家公司的影响是非常大的。</p>
</blockquote>
<h2 id="并发编程的问题"><a href="#并发编程的问题" class="headerlink" title="并发编程的问题"></a>并发编程的问题</h2><p>前面说的和硬件有关的概念你可能听得有点蒙，还不知道他到底和软件有啥关系。但是关于并发编程的问题你应该有所了解，比如原子性问题，可见性问题和有序性问题。</p>
<p>其实，原子性问题，可见性问题和有序性问题。是人们抽象定义出来的。而这个抽象的底层问题就是前面提到的缓存一致性问题、处理器优化问题和指令重排问题等。</p>
<p>这里简单回顾下这三个问题，并不准备深入展开，感兴趣的读者可以自行学习。我们说，并发编程，为了保证数据的安全，需要满足以下三个特性：</p>
<p><strong>原子性</strong>是指在一个操作中就是cpu不可以在中途暂停然后再调度，既不被中断操作，要不执行完成，要不就不执行。</p>
<p><strong>可见性</strong>是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。</p>
<p><strong>有序性</strong>即程序执行的顺序按照代码的先后顺序执行。</p>
<p>有没有发现，<strong>缓存一致性问题</strong>其实就是<strong>可见性问题</strong>。而<strong>处理器优化</strong>是可以导致<strong>原子性问题</strong>的。<strong>指令重排</strong>即会导致<strong>有序性问题</strong>。所以，后文将不再提起硬件层面的那些概念，而是直接使用大家熟悉的原子性、可见性和有序性。</p>
<h2 id="什么是内存模型"><a href="#什么是内存模型" class="headerlink" title="什么是内存模型"></a>什么是内存模型</h2><p>前面提到的，缓存一致性问题、处理器器优化的指令重排问题是硬件的不断升级导致的。那么，有没有什么机制可以很好的解决上面的这些问题呢？</p>
<p>最简单直接的做法就是废除处理器和处理器的优化技术、废除CPU缓存，让CPU直接和主存交互。但是，这么做虽然可以保证多线程下的并发问题。但是，这就有点因噎废食了。</p>
<p>所以，为了保证并发编程中可以满足原子性、可见性及有序性。有一个重要的概念，那就是——内存模型。</p>
<p><u><strong>为了保证共享内存的正确性（可见性、有序性、原子性），内存模型定义了共享内存系统中多线程程序读写操作行为的规范。</strong></u>通过这些规则来规范对内存的读写操作，从而保证指令执行的正确性。它与处理器有关、与缓存有关、与并发有关、与编译器也有关。他解决了CPU多级缓存、处理器优化、指令重排等导致的内存访问问题，保证了并发场景下的一致性、原子性和有序性。</p>
<p>内存模型解决并发问题主要采用两种方式：<strong>限制处理器优化</strong>和<strong>使用内存屏障</strong>。本文就不深入底层原理来展开介绍了，感兴趣的朋友可以自行学习。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://wenwenhuan.gitee.io/2021/04/12/%E7%BA%A2%E9%BB%91%E6%A0%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="温文焕">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wenhuan Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/04/12/%E7%BA%A2%E9%BB%91%E6%A0%91/" class="post-title-link" itemprop="url">红黑树</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-04-12 23:11:00" itemprop="dateCreated datePublished" datetime="2021-04-12T23:11:00+08:00">2021-04-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2021-04-13 13:54:14" itemprop="dateModified" datetime="2021-04-13T13:54:14+08:00">2021-04-13</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h2><p>红黑树是每个节点都带有<em>颜色</em>属性的二叉查找树，颜色为<em>红色</em>或<em>黑色</em>。在二叉查找树强制一般要求以外，对于任何有效的红黑树我们增加了如下的额外要求：</p>
<ol>
<li>节点是红色或黑色。</li>
<li>根是黑色。</li>
<li>所有叶子都是黑色（叶子是NIL节点）。</li>
<li>每个红色节点必须有两个黑色的子节点。（从每个叶子到根的所有路径上不能有两个连续的红色节点。）</li>
<li>从任一节点到其每个叶子的所有<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%81%93%E8%B7%AF_(%E5%9B%BE%E8%AE%BA)">简单路径</a>都包含相同数目的黑色节点。</li>
</ol>
<p><img src="450px-Red-black_tree_example.svg.png"></p>
<p>这些约束确保了红黑树的关键特性：<strong>从根到叶子的最长的可能路径不多于最短的可能路径的两倍长</strong>。结果是这个树大致上是平衡的。因为操作比如插入、删除和查找某个值的最坏情况时间都要求与树的高度成比例，这个在高度上的理论上限允许红黑树在最坏情况下都是高效的，而不同于普通的<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91">二叉查找树</a>。</p>
<p>要知道为什么这些性质确保了这个结果，注意到性质4导致了路径不能有两个毗连的红色节点就足够了。最短的可能路径都是黑色节点，最长的可能路径有交替的红色和黑色节点。因为根据性质5所有最长的路径都有相同数目的黑色节点，这就表明了没有路径能多于任何其他路径的两倍长。</p>
<p>在很多树数据结构的表示中，一个节点有可能只有一个子节点，而叶子节点包含数据。用这种范例表示红黑树是可能的，但是这会改变一些性质并使算法复杂。为此，本文中我们使用”nil叶子”或”空（null）叶子”，如上图所示，它不包含数据而只充当树在此结束的指示。这些节点在绘图中经常被省略，导致了这些树好像同上述原则相矛盾，而实际上不是这样。与此有关的结论是所有节点都有两个子节点，尽管其中的一个或两个可能是空叶子。</p>
<h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><p>因为每一个红黑树也是一个特化的<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91">二叉查找树</a>，因此红黑树上的只读操作与普通<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91">二叉查找树</a>上的只读操作相同。然而，在红黑树上进行插入操作和删除操作会导致不再符合红黑树的性质。恢复红黑树的性质需要少量（O(log n)）的颜色变更（实际是非常快速的）和不超过三次<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%A0%91%E6%97%8B%E8%BD%AC">树旋转</a>（对于插入操作是两次）。虽然插入和删除很复杂，但操作时间仍可以保持为O(log n)次。</p>
<h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p>共5种可能</p>
<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>共6种可能</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://wenwenhuan.gitee.io/2021/04/12/%E8%AE%A1%E7%BD%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="温文焕">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wenhuan Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/04/12/%E8%AE%A1%E7%BD%91/" class="post-title-link" itemprop="url">计算机网络常用知识点</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-04-12 23:11:00" itemprop="dateCreated datePublished" datetime="2021-04-12T23:11:00+08:00">2021-04-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2021-05-12 12:06:46" itemprop="dateModified" datetime="2021-05-12T12:06:46+08:00">2021-05-12</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="OSI-TCP-IP-五层协议的体系结构，各层协议"><a href="#OSI-TCP-IP-五层协议的体系结构，各层协议" class="headerlink" title="OSI,TCP/IP,五层协议的体系结构，各层协议"></a>OSI,TCP/IP,五层协议的体系结构，各层协议</h2><hr>
<p>OSI分层（7层）：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。</p>
<p><strong>TCP/IP分层（4层）：网络接口层、网际层、运输层、应用层。</strong></p>
<p>五层协议：物理层、数据链路层、网络层、运输层、应用层。</p>
<p><strong>TCP/IP协议族：</strong></p>
<ul>
<li>应用层：HTTP，SMTP，DNS,RTP</li>
<li>运输层：TCP,UDP</li>
<li>网际层：IP</li>
</ul>
<p><strong>HTTP协议：</strong> 超文本传输协议，是一个属于应用层的面向对象的协议，由于其简捷、快速的方式，适用于分布式超媒体信息系统。</p>
<h2 id="TCP三次握手和四次挥手的全过程"><a href="#TCP三次握手和四次挥手的全过程" class="headerlink" title="TCP三次握手和四次挥手的全过程"></a>TCP三次握手和四次挥手的全过程</h2><hr>
<img src="/2021/04/12/%E8%AE%A1%E7%BD%91/image-20210415220355775.png" class="" title="image-20210415220355775">

<h4 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a><strong>三次握手</strong></h4><ul>
<li><p>第一次握手：客户端给服务端发一个 SYN 报文，并指明客户端的初始化序列号 ISN(c)。此时客户端处于 <code>SYN_SEND</code> 状态。</p>
<p>首部的同步位SYN=1，初始序号seq=x，SYN=1的报文段不能携带数据，但要消耗掉一个序号。</p>
</li>
<li><p>第二次握手：服务器收到客户端的 SYN 报文之后，会以自己的 SYN 报文作为应答，并且也是指定了自己的初始化序列号 ISN(s)。同时会把客户端的 ISN + 1 作为ACK 的值，表示自己已经收到了客户端的 SYN，此时服务器处于 <code>SYN_RCVD</code> 的状态。</p>
<p>在确认报文段中SYN=1，ACK=1，确认号ack=x+1，初始序号seq=y。</p>
</li>
<li><p>第三次握手：客户端收到 SYN 报文之后，会发送一个 ACK 报文，当然，也是一样把服务器的 ISN + 1 作为 ACK 的值，表示已经收到了服务端的 SYN 报文，此时客户端处于 <code>ESTABLISHED</code> 状态。服务器收到 ACK 报文之后，也处于 <code>ESTABLISHED</code> 状态，此时，双方已建立起了连接。</p>
<p>确认报文段ACK=1，确认号ack=y+1，序号seq=x+1（初始为seq=x，第二个报文段所以要+1），ACK报文段可以携带数据，不携带数据则不消耗序号。</p>
</li>
</ul>
<p><strong>状态整理</strong>：</p>
<ul>
<li>客户端：关闭（CLOSE）、同步已发送（SYN-SEND）、已建立连接（ESTABLISHED）</li>
<li>服务器：关闭（CLOSE）、收听（LISTEN）、同步收到（SYN-RCVD）、已建立连接（ESTABLISHED）</li>
</ul>
<h4 id="为什么需要三次握手，两次不行吗？"><a href="#为什么需要三次握手，两次不行吗？" class="headerlink" title="为什么需要三次握手，两次不行吗？"></a>为什么需要三次握手，两次不行吗？</h4><p>关键字：<strong>客户端重传</strong>。<strong>第一次握手</strong>可能是一次<strong>失效的握手</strong>，<strong>第三次握手</strong>是对第一次握手的<strong>确认</strong>。</p>
<p>假如两次，也就是客户端一发送，服务端就建立连接。那么假如客户端发送两次，因为第一次滞留，那么客户端相当于建立了两次连接，但实际上第一次已经是无效的了。</p>
<p>如客户端发出连接请求，但因连接请求报文丢失而未收到确认，于是客户端再重传一次连接请求。后来收到了确认，建立了连接。数据传输完毕后，就释放了连接，客户端共发出了两个连接请求报文段，其中第一个丢失，第二个到达了服务端，但是第一个丢失的报文段只是在<strong>某些网络结点长时间滞留了，延误到连接释放以后的某个时间才到达服务端</strong>，此时服务端误认为客户端又发出一次新的连接请求，于是就向客户端发出确认报文段，同意建立连接，不采用三次握手，只要服务端发出确认，就建立新的连接了，此时客户端忽略服务端发来的确认，也不发送数据，则服务端一致等待客户端发送数据，浪费资源。</p>
<h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><img src="/2021/04/12/%E8%AE%A1%E7%BD%91/image-20210415220422325.png" class="" title="image-20210415220422325">

<h4 id="四次挥手的过程如下："><a href="#四次挥手的过程如下：" class="headerlink" title="四次挥手的过程如下："></a>四次挥手的过程如下：</h4><ul>
<li><p>第一次挥手：客户端发送一个 FIN 报文，报文中会指定一个序列号。此时客户端处于 <code>FIN_WAIT1</code> 状态。 即发出<strong>连接释放报文段</strong>（FIN=1，序号seq=u），并停止再发送数据，主动关闭TCP连接，进入FIN_WAIT1（终止等待1）状态，等待服务端的确认。</p>
</li>
<li><p>第二次挥手：服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序列号值 +1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 <code>CLOSE_WAIT</code> 状态。 即服务端收到连接释放报文段后即发出<strong>确认报文段</strong>（ACK=1，确认号ack=u+1，序号seq=v），服务端进入CLOSE_WAIT（关闭等待）状态，此时的TCP处于<strong>半关闭状态</strong>，客户端到服务端的连接释放。客户端收到服务端的确认后，进入FIN_WAIT2（终止等待2）状态，等待服务端发出的连接释放报文段。</p>
</li>
<li><p>第三次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号。此时服务端处于 <code>LAST_ACK</code> 的状态。 即服务端没有要向客户端发出的数据，服务端发出<strong>连接释放报文段</strong>（FIN=1，ACK=1，序号seq=w，确-认号ack=u+1），服务端进入LAST_ACK（最后确认）状态，等待客户端的确认。</p>
</li>
<li><p>第四次挥手：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 +1 作为自己 ACK 报文的序列号值，此时客户端处于 <code>TIME_WAIT</code> 状态。需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态，服务端收到 ACK 报文之后，就处于关闭连接了，处于 <code>CLOSED</code> 状态。 即客户端收到服务端的连接释放报文段后，对此发出<strong>确认报文段</strong>（ACK=1，seq=u+1，ack=w+1），客户端进入TIME_WAIT（时间等待）状态。此时TCP未释放掉，需要经过时间等待计时器设置的时间2MSL后，客户端才进入CLOSED状态。</p>
<p>时间MSL叫做<strong>最长报文段寿命</strong>（Maximun Segment Lifetime）</p>
</li>
</ul>
<p><strong>状态整理</strong>：</p>
<ul>
<li>客户端：已建立连接（ESTABLISHED）、FIN_WAIT1（终止等待1）、FIN_WAIT2（终止等待2）、TIME_WAIT（时间等待）</li>
<li>服务器：已建立连接（ESTABLISHED）、CLOSE_WAIT（关闭等待）、LAST_ACK（最后确认）</li>
</ul>
<h3 id="挥手为什么需要四次"><a href="#挥手为什么需要四次" class="headerlink" title="挥手为什么需要四次"></a>挥手为什么需要四次</h3><p>关键字：半关闭，<strong>服务端还想要发送数据</strong></p>
<h3 id="四次挥手释放连接时，等待2MSL的意义"><a href="#四次挥手释放连接时，等待2MSL的意义" class="headerlink" title="四次挥手释放连接时，等待2MSL的意义?"></a>四次挥手释放连接时，等待2MSL的意义?</h3><h4 id="两个理由："><a href="#两个理由：" class="headerlink" title="两个理由："></a>两个理由：</h4><ol>
<li><p>关键字：<strong>客户端重传</strong>，确保客户端最后一个 ACK 能够到达服务端（这个 ACK 可能丢失）</p>
<p>保证客户端发送的最后一个ACK报文段能够到达服务端。 <strong>客户端的ACK报文段有可能丢失</strong>（<strong>所以客户端怎么着也得重传一次，不然服务端没办法正常关闭</strong>），使得处于LAST-ACK状态的B收不到对已发送的FIN+ACK报文段的确认，服务端超时重传FIN+ACK报文段，而客户端能在2MSL时间内收到这个重传的FIN+ACK报文段，接着客户端重传一次确认，重新启动2MSL计时器，最后客户端和服务端都进入到CLOSED状态，若客户端在TIME-WAIT状态不等待一段时间，而是发送完ACK报文段后立即释放连接，则无法收到服务端重传的FIN+ACK报文段，所以不会再发送一次确认报文段，则服务端无法正常进入到CLOSED状态。</p>
</li>
<li><p>关键字：<strong>已失效的连接请求报文段</strong></p>
<p>防止“已失效的连接请求报文段”出现在本连接中。 客户端在发送完最后一个ACK报文段后，再经过2MSL，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失，使下一个新的连接中不会出现这种旧的连接请求报文段。</p>
</li>
</ol>
<p><strong>ACK报文</strong>：在TCP/IP协议中，如果接收方成功的接收到数据，那么会回复一个ACK数据。通常ACK信号有自己固定的格式,长度大小,由接收方回复给发送方。</p>
<p><strong>TCP 对应的一些函数</strong></p>
<h4 id="TCP-三次握手发生在哪个函数之间"><a href="#TCP-三次握手发生在哪个函数之间" class="headerlink" title="TCP 三次握手发生在哪个函数之间"></a>TCP 三次握手发生在哪个函数之间</h4><p>TCP 三次握手是发送在<strong>客户端</strong>调用 <code>connect()</code> 函数的时候，注意服务器响应 ack 跟 <code>accept()</code> 没什么关系，服务器在 listen() 之后，就可以响应 ack，所以如果问发生在服务器端的哪个函数，应该说是 <code>listen()</code> 之后。</p>
<h2 id="tcp和udp的区别"><a href="#tcp和udp的区别" class="headerlink" title="tcp和udp的区别"></a>tcp和udp的区别</h2><hr>
<p><strong>比较方向</strong></p>
<p>tcp 是一个 <strong>可靠</strong> 的 <strong>面向连接</strong> 的 <strong>字节流</strong> 服务</p>
<p>可靠性，是否有连接，报文格式，双工性，传输速度</p>
<img src="/2021/04/12/%E8%AE%A1%E7%BD%91/image-20210415220450406.png" class="" title="image-20210415220450406">

<h2 id="TCP如何保证可靠性"><a href="#TCP如何保证可靠性" class="headerlink" title="TCP如何保证可靠性"></a>TCP如何保证可靠性</h2><hr>
<p>主要方向：<strong>校验和</strong>，<strong>握手</strong>，<strong>流量控制</strong>，<strong>拥塞控制</strong></p>
<ul>
<li>校验和，按16位为一个数据<strong>相加</strong>，最后的进位继续加，最终的值<strong>取反</strong></li>
</ul>
<img src="/2021/04/12/%E8%AE%A1%E7%BD%91/image-20210415220516424.png" class="" title="image-20210415220516424">

<ul>
<li>发送方：在发送数据之前计算检验和，并进行校验和的填充。 接收方：收到数据后，对数据以同样的方式进行计算，求出校验和，与发送方的进行比对。</li>
<li>确认应答和序列号</li>
<li>超时重传</li>
<li>连接管理，三次握手，四次挥手</li>
<li>流量控制</li>
<li>拥塞控制</li>
</ul>
<h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><hr>
<h3 id="http状态码"><a href="#http状态码" class="headerlink" title="http状态码"></a>http状态码</h3><h4 id="201-Created-（已创建）"><a href="#201-Created-（已创建）" class="headerlink" title="201 Created （已创建）"></a>201 Created （已创建）</h4><ul>
<li>响应结果：该请求已成功，并因此创建了一个新的资源。</li>
<li>使用场景：作为PUT请求的返回值。</li>
</ul>
<h3 id="204-No-Content-没有内容"><a href="#204-No-Content-没有内容" class="headerlink" title="204 No Content (没有内容)"></a>204 No Content (没有内容)</h3><ul>
<li>响应结果：服务器成功处理了客户端请求，但服务器无返回内容。204是HTTP中数据量最少的响应状态，204的<strong>响应中没有body</strong>，而且Content-Length=0。</li>
<li>使用场景：204状态在一些网站分析的代码中<strong>最常用</strong>到，只需要把客户端的一些信息提交给服务器而无需关心响应。</li>
</ul>
<h3 id="301-Moved-Permanently（永久性重定向"><a href="#301-Moved-Permanently（永久性重定向" class="headerlink" title="301 Moved Permanently（永久性重定向)"></a>301 Moved Permanently（永久性重定向)</h3><ul>
<li>响应结果：表示请求的资源已被分配了新的URL，以后应使用现在所指的URL。也就是说如果已经吧资源对应的URL保存为书签了，这时应该按Location首部字段提示的URL重新保存。</li>
<li>使用场景：</li>
<li><ul>
<li>域名到期不想续费（或者发现了更适合网站的域名），想换个域名。</li>
</ul>
</li>
<li><ul>
<li>在搜索引擎的搜索结果中出现了不带www的域名，而带www的域名却没有收录，这个时候可以用301重定向来告诉搜索引擎我们目标的域名是哪一个。</li>
</ul>
</li>
<li><ul>
<li>空间服务器不稳定，换空间的时候。</li>
</ul>
</li>
</ul>
<h3 id="302-Found（临时性重定向）"><a href="#302-Found（临时性重定向）" class="headerlink" title="302 Found（临时性重定向）"></a>302 Found（临时性重定向）</h3><ul>
<li>响应结果：该状态码表示请求的资源已被分配了新的URL，希望用户（本次）能使用新的URL访问。</li>
<li>使用场景：尽量使用301！</li>
</ul>
<h3 id="304-Not-Modified"><a href="#304-Not-Modified" class="headerlink" title="304 Not Modified"></a>304 Not Modified</h3><p>字面意思是：资源未改变，可直接使用缓存。</p>
<p>这种响应一般是GET请求中带有附加条件，例如请求头中含有if-Match,if-Modified-Since等（if-Match表示只请求带有特殊标记的资源，if-Modified-Since表示请求指定时间后未变更的资源，因为本文主要讲解状态码，所以不在此引入太多http头部的相关内容，这里是为了简单解释下附加条件请求的含义）。</p>
<p>这种情况下，<strong>服务端不会返回响应主体</strong>，含义就是：”<strong>从你上次访问以来这个资源都没变过哟，直接使用你本地的缓存就行啦</strong>“。</p>
<p>304就是3xx里面的一个特例，因为它不算是一个重定向。（一般我们认为重定向要给出一个新的地址让客户端去访问，304如果一定要解释为重定向，只能解释为让客户端转去访问缓存-_-）</p>
<h3 id="401-Unauthorized（未授权）"><a href="#401-Unauthorized（未授权）" class="headerlink" title="401 Unauthorized（未授权）"></a>401 Unauthorized（未授权）</h3><ul>
<li>响应结果：表示发送的请求需要有通过HTTP认证的认证信息。另外若之前已进行过一次请求，则表示用户认证失败。返回含有401响应必须包含一个适用于被请求资源的WWW-Authenticate 首部用以质询用户信息。当浏览器初次接收到401响应，会弹出认证用的对话窗口。</li>
<li>出现原因：客户端错误，指的是由于缺乏目标资源要求的身份验证凭证，发送的请求未得到满足。</li>
</ul>
<h3 id="403-Forbidden-（禁止）"><a href="#403-Forbidden-（禁止）" class="headerlink" title="403 Forbidden （禁止）"></a>403 Forbidden （禁止）</h3><ul>
<li>响应结果：对请求资源的访问服务器拒绝了。服务器端没有必要给出拒绝的详细理由，但如果想作说明的话，可以在实体的主题部分对原因进行描述，这样就能让用户看到了。</li>
<li>出现原因：未获得文件系统的访问授权，访问权限出现某些问题（从未授权的发送源IP地址试图访问）等列举情况都可能是发生403的原因。</li>
</ul>
<h3 id="502-Bad-Gateway"><a href="#502-Bad-Gateway" class="headerlink" title="502 Bad Gateway"></a>502 Bad Gateway</h3><p>作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应。这里说明下网关和代理服务器的概念：前面我们举例子都是直接客户端向服务器发请求，实际上客户端有时候不是直接向服务器请求，这中间可能存在网关和代理。画个简单的图：</p>
<h3 id="503-Service-Unavailable"><a href="#503-Service-Unavailable" class="headerlink" title="503 Service Unavailable"></a>503 Service Unavailable</h3><p>服务器暂时无法使用，可能是维护或者升级，反正无法使用。</p>
<h3 id="504-Gateway-Timeout"><a href="#504-Gateway-Timeout" class="headerlink" title="504 Gateway Timeout"></a>504 Gateway Timeout</h3><p>作为网关或者代理工作的服务器访问超时。</p>
<h2 id="ARQ协议"><a href="#ARQ协议" class="headerlink" title="ARQ协议"></a>ARQ协议</h2><hr>
<p>也是为了实现<strong>可靠传输</strong>的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组</p>
<h4 id="ARQ协议是什么？"><a href="#ARQ协议是什么？" class="headerlink" title="ARQ协议是什么？"></a>ARQ协议是什么？</h4><p><strong>自动重传请求</strong>（Automatic Repeat-reQuest，ARQ）是OSI模型中数据链路层和传输层的错误纠正协议之一。它通过使用<strong>确认</strong>和<strong>超时</strong>这两个机制，在不可靠服务的基础上实现可靠的信息传输。如果发送方在发送后一段时间之内没有收到确认帧，它通常会重新发送。ARQ包括停止等待ARQ协议和连续ARQ协议。</p>
<h4 id="根据arq协议可以延申出停止等待和连续arq协议"><a href="#根据arq协议可以延申出停止等待和连续arq协议" class="headerlink" title="根据arq协议可以延申出停止等待和连续arq协议"></a>根据arq协议可以延申出停止等待和连续arq协议</h4><h3 id="停止等待ARQ协议"><a href="#停止等待ARQ协议" class="headerlink" title="停止等待ARQ协议"></a>停止等待ARQ协议</h3><ul>
<li>停止等待协议是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认（回复ACK）。如果过了一段时间（超时时间后），还是没有收到 ACK 确认，说明没有发送成功，需要重新发送，直到收到确认后再发下一个分组；</li>
<li>在停止等待协议中，若接收方收到重复分组，就丢弃该分组，但同时还要发送确认；</li>
</ul>
<h3 id="连续ARQ协议"><a href="#连续ARQ协议" class="headerlink" title="连续ARQ协议"></a>连续ARQ协议</h3><p>连续 ARQ 协议可提高信道利用率。发送方维持一个发送窗口，凡位于发送窗口内的分组可以连续发送出去，而不需要等待对方确认。接收方一般采用累计确认，对按序到达的最后一个分组发送确认，表明到这个分组为止的所有分组都已经正确收到了。</p>
<h2 id="各层对应协议"><a href="#各层对应协议" class="headerlink" title="各层对应协议"></a>各层对应协议</h2><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">每一层的协议如下：</span><br><span class="line">物理层：RJ45、CLOCK、IEEE802.3    （中继器，集线器）</span><br><span class="line">数据链路：PPP、FR、HDLC、VLAN、MAC  （网桥，交换机）</span><br><span class="line">网络层：IP、ICMP、ARP、RARP、OSPF、IPX、RIP、IGRP、 （路由器）</span><br><span class="line">传输层：TCP、UDP、SPX</span><br><span class="line">会话层：NFS、SQL、NETBIOS、RPC</span><br><span class="line">表示层：JPEG、MPEG、ASII</span><br><span class="line">应用层：FTP、DNS、Telnet、SMTP、HTTP、WWW、NFS</span><br><span class="line">每一层的作用如下：</span><br><span class="line">物理层：通过媒介传输比特,确定机械及电气规范（比特Bit）</span><br><span class="line">数据链路层：将比特组装成帧和点到点的传递（帧Frame）</span><br><span class="line">网络层：负责数据包从源到宿的传递和网际互连（包PackeT）</span><br><span class="line">传输层：提供端到端的可靠报文传递和错误恢复（段Segment）</span><br><span class="line">会话层：建立、管理和终止会话（会话协议数据单元SPDU）</span><br><span class="line">表示层：对数据进行翻译、加密和压缩（表示协议数据单元PPDU）</span><br><span class="line">应用层：允许访问OSI环境的手段（应用协议数据单元APDU）</span><br></pre></td></tr></table></figure>

<h2 id="常用端口"><a href="#常用端口" class="headerlink" title="常用端口"></a>常用端口</h2><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">20,21：FTP</span><br><span class="line">22：SSH</span><br><span class="line">23：Telnet</span><br><span class="line">25：SMTP</span><br><span class="line">53：DNS（UDP）</span><br><span class="line">69：TFTP（类似FTP）</span><br><span class="line">80：HTTP</span><br><span class="line">443：HTTPS</span><br><span class="line">1080：socks代理服务</span><br><span class="line">8080：用户www代理服务</span><br></pre></td></tr></table></figure>

<h2 id="HTTPS加密过程"><a href="#HTTPS加密过程" class="headerlink" title="HTTPS加密过程"></a>HTTPS加密过程</h2><hr>
<h3 id="HTTP和HTTPS区别"><a href="#HTTP和HTTPS区别" class="headerlink" title="HTTP和HTTPS区别"></a>HTTP和HTTPS区别</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/xionghuixionghui/article/details/68569282">https://blog.csdn.net/xionghuixionghui/article/details/68569282</a></p>
<p>HTTP协议以明文方式发送内容，不提供任何方式的数据加密，如果攻击者截取了Web浏览器和网站服务器之间的传输报文，就可以直接读懂其中的信息，因此，HTTP协议不适合传输一些敏感信息，比如：信用卡号、密码等支付信息。</p>
<p>安全套接字层超文本传输协议HTTPS，为了数据传输的安全，HTTPS在HTTP的基础上加入了SSL协议，SSL依靠证书来验证服务器的身份，并为浏览器和服务器之间的通信加密。</p>
<p>HTTPS协议的主要作用可以分为两种：一种是建立一个信息安全通道，来保证数据传输的安全；另一种就是确认网站的真实性。</p>
<p>简单来说，HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全。</p>
<p>HTTPS和HTTP的区别主要如下：</p>
<p>1、https协议需要到ca<strong>申请证书</strong>，一般免费证书较少，因而需要一定费用。</p>
<p>2、http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。</p>
<p>3、http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。</p>
<p>4、http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。</p>
<p>最新推出的TLS协议，是SSL 3.0协议的升级版</p>
<img src="/2021/04/12/%E8%AE%A1%E7%BD%91/640" class="" title="图片">

<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzA5MzY4NTQwMA==&amp;mid=2651008910&amp;idx=4&amp;sn=049fa10eecb3de61b98d7f58bbb78f74&amp;chksm=8bad9c79bcda156fc2097361977595d4a19a56ded9c8b1ca55890bfe800db0551b1723f2d7b9&amp;mpshare=1&amp;scene=24&amp;srcid=08287mXFO8ufu50J99Dwdfcp&amp;sharer_sharetime=1566958392180&amp;sharer_shareid=21a49bdfc44694f7d1e3ef9964b3998f#rd">https://mp.weixin.qq.com/s?__biz=MzA5MzY4NTQwMA==&amp;mid=2651008910&amp;idx=4&amp;sn=049fa10eecb3de61b98d7f58bbb78f74&amp;chksm=8bad9c79bcda156fc2097361977595d4a19a56ded9c8b1ca55890bfe800db0551b1723f2d7b9&amp;mpshare=1&amp;scene=24&amp;srcid=08287mXFO8ufu50J99Dwdfcp&amp;sharer_sharetime=1566958392180&amp;sharer_shareid=21a49bdfc44694f7d1e3ef9964b3998f#rd</a></p>
<ol>
<li>客户端请求服务器获取证书<strong>公钥</strong>。</li>
<li>客户端(SSL/TLS)解析证书（无效会弹出警告）。</li>
<li>客户端生成随机值（这个随机值就是密钥）。</li>
<li>客户端用公钥加密密钥，发送给服务器。</li>
<li>服务端用私钥解密密钥得到随机值（密钥）。—从此以后就用密钥通信</li>
<li>将信息和随机值混合在一起进行对称加密。</li>
<li>将加密的内容发送给客户端。</li>
<li>客户端用秘钥解密信息。</li>
</ol>
<p><a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2011/08/what_is_a_digital_signature.html">http://www.ruanyifeng.com/blog/2011/08/what_is_a_digital_signature.html</a></p>
<p>ca证书<a target="_blank" rel="noopener" href="https://www.cnblogs.com/handsomeBoys/p/6556336.html">https://www.cnblogs.com/handsomeBoys/p/6556336.html</a></p>
<h2 id="TCP-KeepAlive-原理"><a href="#TCP-KeepAlive-原理" class="headerlink" title="TCP KeepAlive 原理"></a>TCP KeepAlive 原理</h2><hr>
<p>TCP KeepAlive 的基本原理是，<strong>隔一段时间给连接对端发送一个探测包</strong>，如果收到对方回应的 ACK，则认为连接还是存活的，在超过一定重试次数之后还是没有收到对方的回应，则丢弃该 TCP 连接。</p>
<h2 id="PING-的过程-实现"><a href="#PING-的过程-实现" class="headerlink" title="PING 的过程/实现"></a>PING 的过程/实现</h2><hr>
<p><a target="_blank" rel="noopener" href="https://blog.51cto.com/wanicy/335207">https://blog.51cto.com/wanicy/335207</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">温文焕</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  





  





</body>
</html>
