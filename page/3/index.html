<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"wenwenhuan.gitee.io","root":"/","images":"/images","scheme":"Gemini","darkmode":true,"version":"8.8.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>
<meta property="og:type" content="website">
<meta property="og:title" content="Wenhuan Blog">
<meta property="og:url" content="https://wenwenhuan.gitee.io/page/3/index.html">
<meta property="og:site_name" content="Wenhuan Blog">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="温文焕">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://wenwenhuan.gitee.io/page/3/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/3/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Wenhuan Blog</title>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Wenhuan Blog</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">即使天无雨 我亦留此地</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">温文焕</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">64</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://wenwenhuan.gitee.io/2021/05/05/%E6%95%B0%E6%8D%AE%E5%BA%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="温文焕">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wenhuan Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/05/05/%E6%95%B0%E6%8D%AE%E5%BA%93/" class="post-title-link" itemprop="url">数据库</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-05-05 16:00:23" itemprop="dateCreated datePublished" datetime="2021-05-05T16:00:23+08:00">2021-05-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2021-05-12 12:06:10" itemprop="dateModified" datetime="2021-05-12T12:06:10+08:00">2021-05-12</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="数据库范式"><a href="#数据库范式" class="headerlink" title="数据库范式"></a>数据库范式</h2><p>一张数据表的表结构所符合的某种设计标准的级别。主要解决<strong>数据冗余过大</strong>、<strong>插入异常</strong>、<strong>删除异常</strong>、<strong>修改异常</strong>。</p>
<h3 id="第一范式（1NF）"><a href="#第一范式（1NF）" class="headerlink" title="第一范式（1NF）"></a><strong>第一范式（1NF）</strong></h3><p><strong>符合1NF的关系中的每个属性都不可再分。</strong></p>
<h3 id="第二范式"><a href="#第二范式" class="headerlink" title="第二范式"></a>第二范式</h3><p><strong>2NF在1NF的基础之上，消除了非主属性对于码的部分函数依赖</strong>。</p>
<h3 id="第三范式（3NF）"><a href="#第三范式（3NF）" class="headerlink" title="第三范式（3NF）"></a><strong>第三范式（3NF）</strong></h3><p><strong>3NF在2NF的基础之上，消除了非主属性对于码的传递函数依赖</strong>。</p>
<h2 id="mysql数据库引擎"><a href="#mysql数据库引擎" class="headerlink" title="mysql数据库引擎"></a>mysql数据库引擎</h2><h3 id="两种存储引擎的大致区别表现在"><a href="#两种存储引擎的大致区别表现在" class="headerlink" title="==两种存储引擎的大致区别表现在=="></a><strong>==两种存储引擎的大致区别表现在==</strong></h3><p>最重要：两种类型最主要的差别就是<strong>Innodb 支持 <code>事务</code> 处理与 <code>外键</code> 和 <code>行级锁</code></strong></p>
<ul>
<li><strong>InnoDB支持事务，MyISAM不支持</strong>，这一点是非常之重要。事务是一种高级的处理方式，如在一些列增删改中只要哪个出错还可以回滚还原，而MyISAM就不可以了。</li>
<li><strong>MyISAM适合查询以及插入为主的应用</strong>。</li>
<li><strong>InnoDB适合频繁修改以及涉及到安全性较高的应用</strong>。</li>
<li>InnoDB支持外键，MyISAM不支持。</li>
<li><strong>从MySQL5.5.5以后，InnoDB是默认引擎</strong>。</li>
<li>InnoDB不支持FULLTEXT（全文索引）类型的索引。</li>
<li><strong>InnoDB中不保存表的行数</strong>，如<code>select count(*) from table</code>时，InnoDB需要扫描一遍整个表来计算有多少行，但是MyISAM只要简单的读出保存好的行数即可。注意的是，当count(*)语句包含where条件时MyISAM也需要扫描整个表。</li>
<li>对于自增长的字段，InnoDB中必须包含只有该字段的索引，但是在MyISAM表中可以和其他字段一起建立联合索引。</li>
<li><code>DELETE FROM table</code>时，<strong>InnoDB不会重新建立表，而是一行一行的 删除，效率非常慢</strong>。<strong>MyISAM则会重建表</strong>。</li>
<li>InnoDB支持行锁（某些情况下还是锁整表，如 <code>update table set a=1 where user like &#39;%lee%&#39;</code>。</li>
</ul>
<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>事务是逻辑上的一组操作，要么都执行，要么都不执行。（转账例子）</p>
<h3 id="事务的特性-ACID"><a href="#事务的特性-ACID" class="headerlink" title="事务的特性(ACID)"></a>事务的特性(ACID)</h3><ol>
<li><strong>原子性：</strong> 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；</li>
<li><strong>一致性：</strong> 执行事务前后，数据保持一致，例如转账业务中，无论事务是否成功，转账者和收款人的总额应该是不变的；</li>
<li><strong>隔离性：</strong> 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；</li>
<li><strong>持久性：</strong> 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。</li>
</ol>
<h3 id="并发事务带来的问题"><a href="#并发事务带来的问题" class="headerlink" title="并发事务带来的问题"></a>并发事务带来的问题</h3><p><strong>脏读（Dirty read）</strong> ：只读一次，读取的是没提交的数据</p>
<p><strong>不可重复读</strong> ： <strong>一个事务两次读取同一个数据，两次读取的数据不一致</strong> ，读取两次，第一次读取的时候事务的<strong>修改</strong>还没提交，第二次读取的时候事务提交了。</p>
<p><strong>幻读</strong> ： <strong>一个事务两次读取一个范围的记录，两次读取的记录数不一致</strong> ，读取两次，第一次读取的时候事务的<strong>添加或者删除</strong>还没提交，第二次读取的时候事务提交了。</p>
<p><strong>丢失修改（Lost to modify）:</strong> 指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。 例如：事务1读取某表中的数据A=20，事务2也读取A=20，事务1修改A=A-1，事务2也修改A=A-1，最终结果A=19，事务1的修改被丢失。</p>
<p>不可重复度和幻读区别：</p>
<p>不可重复读的重点是修改，幻读的重点在于新增或者删除。</p>
<h2 id="数据库调优（SQL调优）"><a href="#数据库调优（SQL调优）" class="headerlink" title="数据库调优（SQL调优）"></a>数据库调优（SQL调优）</h2><p>数据库组成结构图</p>
<img src="/2021/05/05/%E6%95%B0%E6%8D%AE%E5%BA%93/v2-9cd1e45ad32c2aa83725d57b3a956507_1440w.jpg" class="" title="img">

<p>测试时排除缓存干扰：执行SQL的时候，加上SQL NoCache去跑SQL，这样跑出来的时间就是真实的查询时间了。</p>
<p><a target="_blank" rel="noopener" href="https://sq.163yun.com/blog/article/183654375478206464">https://sq.163yun.com/blog/article/183654375478206464</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/u010520146/article/details/81161762">https://blog.csdn.net/u010520146/article/details/81161762</a></p>
<h3 id="一-创建索引"><a href="#一-创建索引" class="headerlink" title="一.创建索引"></a>一.创建索引</h3><p>1.要尽量避免全表扫描，首先应考虑<strong>在 where 及 order by 涉及的列上建立索引</strong><br>2.(1)在经常需要进行检索的字段上创建索引，比如要按照表字段username进行检索，那么就应该在姓名字段上创建索引，如果经常要按照员工部门和员工岗位级别进行检索，那么就应该在员工部门和员工岗位级别这两个字段上创建索引。<br>(2)创建索引给检索带来的性能提升往往是巨大的，因此在发现检索速度过慢的时候应该首先想到的就是创建索引。<br>(3)一个表的索引数最好不要超过6个，若太多则应考虑一些不常使用到的列上建的索引是否有 必要。索引并不是越多越好，<strong>索引固然可以提高相应的 select 的效率，但同时也降低了 insert 及 update 的效率</strong>，因为 insert 或 update 时有可能会重建索引，所以怎样建索引需要慎重考虑，视具体情况而定。</p>
<h3 id="二-避免在索引上使用计算"><a href="#二-避免在索引上使用计算" class="headerlink" title="二.避免在索引上使用计算"></a>二.避免在索引上使用计算</h3><p>在where字句中，如果索引列是计算或者函数的一部分，DBMS的优化器将不会使用索引而使用全表查询,函数<br>属于计算的一种,同时在in和exists中通常情况下使用EXISTS，因为in不走索引</p>
<p>效率低：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from user where salary*22&gt;11000(salary是索引列)</span><br></pre></td></tr></table></figure>

<p>效率高：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from user where salary&gt;11000&#x2F;22(salary是索引列)</span><br></pre></td></tr></table></figure>

<h3 id="三-使用预编译查询"><a href="#三-使用预编译查询" class="headerlink" title="三.使用预编译查询"></a>三.使用预编译查询</h3><p>程序中通常是根据用户的输入来动态执行SQL，这时应该尽量使用参数化SQL,这样不仅可以避免SQL注入漏洞<br>攻击，最重要数据库会对这些参数化SQL进行预编译，这样第一次执行的时候DBMS会为这个SQL语句进行查询优化<br>并且执行预编译，这样以后再执行这个SQL的时候就直接使用预编译的结果，这样可以大大提高执行的速度。</p>
<h4 id="判断是否存在-Sql-注入漏洞：单引号判断法"><a href="#判断是否存在-Sql-注入漏洞：单引号判断法" class="headerlink" title="判断是否存在 Sql 注入漏洞：单引号判断法"></a>判断是否存在 Sql 注入漏洞：<strong>单引号判断法</strong></h4><h4 id="Sql-注入漏洞的类型：数字型、字符型"><a href="#Sql-注入漏洞的类型：数字型、字符型" class="headerlink" title="Sql 注入漏洞的类型：数字型、字符型"></a>Sql 注入漏洞的类型：数字型、字符型</h4><h4 id="防止SQL注入：对用户输入的数据进行转义"><a href="#防止SQL注入：对用户输入的数据进行转义" class="headerlink" title="防止SQL注入：对用户输入的数据进行转义"></a>防止SQL注入：对用户输入的数据进行转义</h4><h3 id="四-调整Where字句中的连接顺序"><a href="#四-调整Where字句中的连接顺序" class="headerlink" title="四.调整Where字句中的连接顺序"></a>四.调整Where字句中的连接顺序</h3><p>DBMS一般采用自下而上的顺序解析where字句，根据这个原理表连接最好写在其他where条件之前，那些可以<br>过滤掉最大数量记录。</p>
<h4 id="五-尽量将多条SQL语句压缩到一句SQL中"><a href="#五-尽量将多条SQL语句压缩到一句SQL中" class="headerlink" title="五.尽量将多条SQL语句压缩到一句SQL中"></a>五.尽量将多条SQL语句压缩到一句SQL中</h4><p>每次执行SQL的时候都要建立网络连接、进行权限校验、进行SQL语句的查询优化、发送执行结果，这个过程<br>是非常耗时的，因此应该尽量避免过多的执行SQL语句，能够压缩到一句SQL执行的语句就不要用多条来执行。</p>
<h4 id="六-用where字句替换HAVING字句"><a href="#六-用where字句替换HAVING字句" class="headerlink" title="六.用where字句替换HAVING字句"></a>六.用where字句替换HAVING字句</h4><p>避免使用HAVING字句，因为HAVING只会在检索出所有记录之后才对结果集进行过滤，而<strong>where则是在聚合前</strong><br><strong>刷选记录</strong>，如果能通过where字句限制记录的数目，那就能减少这方面的开销。HAVING中的条件一般用于聚合函数<br>的过滤，除此之外，应该将条件写在where字句中。</p>
<h4 id="七-使用表的别名"><a href="#七-使用表的别名" class="headerlink" title="七.使用表的别名"></a>七.使用表的别名</h4><p>当在SQL语句中连接多个表时，请使用表的别名并把别名前缀于每个列名上。这样就可以减少解析的时间并减<br>少哪些友列名歧义引起的语法错误。</p>
<h4 id="八-用union-all替换union"><a href="#八-用union-all替换union" class="headerlink" title="八.用union all替换union"></a>八.用union all替换union</h4><p>当SQL语句需要union两个查询结果集合时，即使检索结果中不会有重复的记录，如果使用union这两个结果集<br>同样会尝试进行合并，然后在输出最终结果前进行排序，因此如果可以判断检索结果中不会有重复的记录时候，应<br>该用union all，这样效率就会因此得到提高</p>
<h4 id="九-考虑使用“临时表”暂存中间结果"><a href="#九-考虑使用“临时表”暂存中间结果" class="headerlink" title="九.考虑使用“临时表”暂存中间结果"></a>九.考虑使用“临时表”暂存中间结果</h4><p>简化SQL语句的重要方法就是采用临时表暂存中间结果，但是，临时表的好处远远不止这些，将临时结果暂存在临时表，后面的查询就在tempdb中了，这可以避免程序中多次扫描主表，也大大减少了程序执行中“共享锁”阻塞“更新锁”，减少了阻塞，提高了并发性能。<br>但是也得避免频繁创建和删除临时表，以减少系统表资源的消耗。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://wenwenhuan.gitee.io/2021/04/26/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="温文焕">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wenhuan Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/04/26/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/" class="post-title-link" itemprop="url">面试题整理</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-04-26 20:09:20 / 修改时间：20:11:16" itemprop="dateCreated datePublished" datetime="2021-04-26T20:09:20+08:00">2021-04-26</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>手写一种单例模式</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://wenwenhuan.gitee.io/2021/04/26/%E9%9D%92%E8%9B%99%E8%B7%B3%E5%8F%B0%E9%98%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="温文焕">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wenhuan Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/04/26/%E9%9D%92%E8%9B%99%E8%B7%B3%E5%8F%B0%E9%98%B6/" class="post-title-link" itemprop="url">青蛙跳台阶（动态规划）</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-04-26 11:47:58" itemprop="dateCreated datePublished" datetime="2021-04-26T11:47:58+08:00">2021-04-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2021-05-17 11:10:10" itemprop="dateModified" datetime="2021-05-17T11:10:10+08:00">2021-05-17</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。</p>
<p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p>
<p><strong>此类求多少种可能性的题目一般都有递推性质 ，即 f(n)和 f(n-1)…f(1)之间是有联系的。</strong></p>
<img src="/2021/04/26/%E9%9D%92%E8%9B%99%E8%B7%B3%E5%8F%B0%E9%98%B6/image-20210426115331679.png" class="" title="image-20210426115331679">

<img src="/2021/04/26/%E9%9D%92%E8%9B%99%E8%B7%B3%E5%8F%B0%E9%98%B6/108249e4d62d429f9cd6cab5bbd6afca581ee61c7d762a4c8ea0c62e08e10762-Picture13.png" class="" title="Picture13.png">

<img src="/2021/04/26/%E9%9D%92%E8%9B%99%E8%B7%B3%E5%8F%B0%E9%98%B6/image-20210426115433377.png" class="" title="image-20210426115433377">

<img src="/2021/04/26/%E9%9D%92%E8%9B%99%E8%B7%B3%E5%8F%B0%E9%98%B6/image-20210426115534280.png" class="" title="image-20210426115534280">

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numWays</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span> || n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            dp[i] = (dp[i - <span class="number">2</span>] + dp[i - <span class="number">1</span>]) % <span class="number">1000_000_007</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者不借助数组</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numWays</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">1</span>, sum;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            sum = (a + b) % <span class="number">1000000007</span>;</span><br><span class="line">            a = b;</span><br><span class="line">            b = sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>求余问题：</p>
<p>a+b的和求余等价于a求余和b求余的和再求余，在此题中，a与b都在上次循环中求余，所以可以直接写作</p>
<p><code> sum = (a + b) % 1000000007;</code></p>
<img src="/2021/04/26/%E9%9D%92%E8%9B%99%E8%B7%B3%E5%8F%B0%E9%98%B6/image-20210426120026171.png" class="" title="image-20210426120026171">
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://wenwenhuan.gitee.io/2021/04/25/%E5%A4%9A%E7%BA%BF%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="温文焕">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wenhuan Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/04/25/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" class="post-title-link" itemprop="url">多线程</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-04-25 10:33:17" itemprop="dateCreated datePublished" datetime="2021-04-25T10:33:17+08:00">2021-04-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2021-05-12 12:07:02" itemprop="dateModified" datetime="2021-05-12T12:07:02+08:00">2021-05-12</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="一个线程的生命周期"><a href="#一个线程的生命周期" class="headerlink" title="一个线程的生命周期"></a>一个线程的生命周期</h2><p>线程是一个动态执行的过程，它也有一个从产生到死亡的过程。</p>
<p>下图显示了一个线程完整的生命周期。</p>
<img src="/2021/04/25/%E5%A4%9A%E7%BA%BF%E7%A8%8B/java-thread.jpg" class="" title="img">

<ul>
<li><p>新建状态:</p>
<p>使用 <strong>new</strong> 关键字和 <strong>Thread</strong> 类或其子类建立一个线程对象后，该线程对象就处于新建状态。它保持这个状态直到程序 <strong>start()</strong> 这个线程。</p>
</li>
<li><p>就绪状态:</p>
<p>当线程对象调用了start()方法之后，该线程就进入就绪状态。就绪状态的线程处于就绪队列中，要等待JVM里线程调度器的调度。</p>
</li>
<li><p>运行状态:</p>
<p>如果就绪状态的线程获取 CPU 资源，就可以执行 **run()**，此时线程便处于运行状态。处于运行状态的线程最为复杂，它可以变为阻塞状态、就绪状态和死亡状态。</p>
</li>
<li><p>阻塞状态:</p>
<p>如果一个线程执行了sleep（睡眠）、suspend（挂起）等方法，失去所占用资源之后，该线程就从运行状态进入阻塞状态。在睡眠时间已到或获得设备资源后可以重新进入就绪状态。可以分为三种：</p>
<ul>
<li>等待阻塞：运行状态中的线程执行 wait() 方法，使线程进入到等待阻塞状态。</li>
<li>同步阻塞：线程在获取 synchronized 同步锁失败(因为同步锁被其他线程占用)。</li>
<li>其他阻塞：通过调用线程的 sleep() 或 join() 发出了 I/O 请求时，线程就会进入到阻塞状态。当sleep() 状态超时，join() 等待线程终止或超时，或者 I/O 处理完毕，线程重新转入就绪状态。</li>
</ul>
</li>
<li><p>死亡状态:</p>
<p>一个运行状态的线程完成任务或者其他终止条件发生时，该线程就切换到终止状态。</p>
</li>
</ul>
<p>一个线程还可以等待另一个线程直到其运行结束。例如，<code>main</code>线程在启动<code>t</code>线程后，可以通过<code>t.join()</code>等待<code>t</code>线程结束后再继续运行。</p>
<h2 id="线程的优先级"><a href="#线程的优先级" class="headerlink" title="线程的优先级"></a>线程的优先级</h2><p>每一个 Java 线程都有一个优先级，这样有助于操作系统确定线程的调度顺序。</p>
<p>Java 线程的优先级是一个整数，其取值范围是 1 （Thread.MIN_PRIORITY ） - 10 （Thread.MAX_PRIORITY ）。</p>
<p>默认情况下，每一个线程都会分配一个优先级 NORM_PRIORITY（5）。</p>
<p>具有较高优先级的线程对程序更重要，并且应该在低优先级的线程之前分配处理器资源。但是，线程优先级不能保证线程执行的顺序，而且非常依赖于平台。</p>
<h2 id="Java多线程实现的三种方式"><a href="#Java多线程实现的三种方式" class="headerlink" title="Java多线程实现的三种方式"></a>Java多线程实现的三种方式</h2><p>1.继承Thread类，重写run方法</p>
<p>2.实现Runnable接口，重写run方法，实现Runnable接口的实现类的实例对象作为Thread构造函数的target</p>
<p>3.通过Callable和FutureTask创建线程</p>
<p>4.通过线程池创建线程</p>
<p>前面两种可以归结为一类：无返回值，原因很简单，通过重写run方法，run方式的返回值是void，所以没有办法返回结果</p>
<p>后面两种可以归结成一类：有返回值，通过Callable接口，就要实现call方法，这个方法的返回值是Object，所以返回的结果可以放在Object对象中</p>
<h3 id="方式1：通过继承Thread来创建线程"><a href="#方式1：通过继承Thread来创建线程" class="headerlink" title="方式1：通过继承Thread来创建线程"></a>方式1：通过继承Thread来创建线程</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo01</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadDemo01</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//编写子类的构造方法，可缺省</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//编写自己的线程代码</span></span><br><span class="line">        System.out.println(Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123; </span><br><span class="line">        ThreadDemo01 threadDemo01 = <span class="keyword">new</span> ThreadDemo01(); </span><br><span class="line">        threadDemo01.setName(<span class="string">&quot;我是自定义的线程1&quot;</span>);</span><br><span class="line">        threadDemo01.start();       </span><br><span class="line">        System.out.println(Thread.currentThread().toString());  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序结果：</p>
<p>Thread[main,5,main]</p>
<p>我是自定义的线程1</p>
<p><strong>使用到的方法：</strong></p>
<p><code>setName</code>:改变线程名称，使之与参数 <code>name</code> 相同。</p>
<p><code>currentThread</code>:返回对当前正在执行的线程对象的引用。返回：当前执行的线程。</p>
<h3 id="方式2：通过实现-Runnable-接口来创建线程"><a href="#方式2：通过实现-Runnable-接口来创建线程" class="headerlink" title="方式2：通过实现 Runnable 接口来创建线程"></a>方式2：通过实现 Runnable 接口来创建线程</h3><p>接口的实现类的实例作为Thread的target作为参数传入带参的Thread构造函数，通过调用start()方法启动线程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo02</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123; </span><br><span class="line">        System.out.println(Thread.currentThread().getName());</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyThread());</span><br><span class="line">        t1.start(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;--&gt;我是通过实现接口的线程实现方式！&quot;</span>);</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序运行结果：</p>
<p>main</p>
<p>Thread-0–&gt;我是通过实现接口的线程实现方式！</p>
<h3 id="方式3：通过-Callable-和-Future-创建线程"><a href="#方式3：通过-Callable-和-Future-创建线程" class="headerlink" title="方式3：通过 Callable 和 Future 创建线程"></a>方式3：通过 Callable 和 Future 创建线程</h3><ul>
<li><ol>
<li>创建 Callable 接口的实现类，并实现 call() 方法，该 call() 方法将作为线程执行体，并且有返回值。</li>
</ol>
</li>
<li><ol start="2">
<li>创建 Callable 实现类的实例，使用 FutureTask 类来包装 Callable 对象，该 FutureTask 对象封装了该 Callable 对象的 call() 方法的返回值。</li>
</ol>
</li>
<li><ol start="3">
<li>使用 FutureTask 对象作为 Thread 对象的 target 创建并启动新线程。</li>
</ol>
</li>
<li><ol start="4">
<li>调用 FutureTask 对象的 get() 方法来获得子线程执行结束后的返回值。</li>
</ol>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallableThreadTest</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  </span></span><br><span class="line"><span class="function">    </span>&#123;  </span><br><span class="line">        CallableThreadTest ctt = <span class="keyword">new</span> CallableThreadTest();  </span><br><span class="line">        FutureTask&lt;Integer&gt; ft = <span class="keyword">new</span> FutureTask&lt;&gt;(ctt);  </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">100</span>;i++)  </span><br><span class="line">        &#123;  </span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot; 的循环变量i的值&quot;</span>+i);  </span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">20</span>)  </span><br><span class="line">            &#123;  </span><br><span class="line">                <span class="keyword">new</span> Thread(ft,<span class="string">&quot;有返回值的线程&quot;</span>).start();  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">try</span>  </span><br><span class="line">        &#123;  </span><br><span class="line">            System.out.println(<span class="string">&quot;子线程的返回值：&quot;</span>+ft.get());  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e)  </span><br><span class="line">        &#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e)  </span><br><span class="line">        &#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception  </span></span><br><span class="line"><span class="function">    </span>&#123;  </span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;  </span><br><span class="line">        <span class="keyword">for</span>(;i&lt;<span class="number">100</span>;i++)  </span><br><span class="line">        &#123;  </span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot; &quot;</span>+i);  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> i;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="创建线程的三种方式的对比"><a href="#创建线程的三种方式的对比" class="headerlink" title="创建线程的三种方式的对比"></a>创建线程的三种方式的对比</h4><ul>
<li>采用实现 Runnable、Callable 接口的方式创建多线程时，线程类只是实现了 Runnable 接口或 Callable 接口，还可以继承其他类。</li>
<li>使用继承 Thread 类的方式创建多线程时，编写简单，如果需要访问当前线程，则无需使用 Thread.currentThread() 方法，直接使用 this 即可获得当前线程。</li>
</ul>
<h2 id="中断线程"><a href="#中断线程" class="headerlink" title="中断线程"></a>中断线程</h2><p>中断一个线程非常简单，只需要在其他线程中对目标线程调用<code>interrupt()</code>方法，目标线程需要反复检测自身状态是否是interrupted状态，如果是，就立刻结束运行。</p>
<h2 id="volatile关键字"><a href="#volatile关键字" class="headerlink" title="volatile关键字"></a>volatile关键字</h2><p>线程间共享变量需要使用<code>volatile</code>关键字标记，确保每个线程都能读取到更新后的变量值。</p>
<h2 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h2><p>Java程序入口就是由JVM启动<code>main</code>线程，<code>main</code>线程又可以启动其他线程。当所有线程都运行结束时，JVM退出，进程结束。</p>
<p>如果有一个线程没有退出，JVM进程就不会退出。所以，必须保证所有线程都能及时结束。</p>
<p>当遇到无限循环线程的时候，就需要守护线程负责结束该线程。</p>
<p>守护线程是指为其他线程服务的线程。在JVM中，所有非守护线程都执行完毕后，无论有没有守护线程，虚拟机都会自动退出。</p>
<p>因此，JVM退出时，不必关心守护线程是否已结束。</p>
<h3 id="创建守护线程"><a href="#创建守护线程" class="headerlink" title="创建守护线程"></a>创建守护线程</h3><p>方法和普通线程一样，只是在调用<code>start()</code>方法前，调用<code>setDaemon(true)</code>把该线程标记为守护线程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Thread t = <span class="keyword">new</span> MyThread();</span><br><span class="line">t.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">t.start();</span><br></pre></td></tr></table></figure>

<p>在守护线程中，编写代码要注意：守护线程不能持有任何需要关闭的资源，例如打开文件等，因为虚拟机退出时，守护线程没有任何机会来关闭文件，这会导致数据丢失。</p>
<p>所有非守护线程都执行完毕后，虚拟机退出。</p>
<h2 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h2><p>解决多个线程同时读写共享变量，会出现数据不一致的问题。</p>
<p>对变量进行读取和写入时，结果要正确，必须保证是原子操作。原子操作是指不能被中断的一个或一系列操作。</p>
<p>保证一组指令以原子方式执行：即某一个线程执行时，其他线程必须等待。</p>
<p>保证一段代码的原子性就是通过加锁和解锁实现的。Java程序使用<code>synchronized</code>关键字对一个对象进行加锁：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(lock) &#123;</span><br><span class="line">    n = n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(Counter.lock) &#123; <span class="comment">// 获取锁</span></span><br><span class="line">    ...</span><br><span class="line">&#125; <span class="comment">// 释放锁</span></span><br></pre></td></tr></table></figure>

<p>表示用<code>Counter.lock</code>实例作为锁，两个线程在执行各自的<code>synchronized(Counter.lock) &#123; ... &#125;</code>代码块时，必须先获得锁，才能进入代码块进行。执行结束后，在<code>synchronized</code>语句块结束会自动释放锁。这样一来，对<code>Counter.count</code>变量进行读写就不可能同时进行。</p>
<h2 id="线程的几个主要概念"><a href="#线程的几个主要概念" class="headerlink" title="线程的几个主要概念"></a>线程的几个主要概念</h2><p>在多线程编程时，需要了解以下几个概念：</p>
<ul>
<li>线程同步</li>
<li>线程间通信</li>
<li>线程死锁</li>
<li>线程控制：挂起、停止和恢复</li>
</ul>
<h2 id="多线程优缺点"><a href="#多线程优缺点" class="headerlink" title="多线程优缺点"></a>多线程优缺点</h2><p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1416283">https://cloud.tencent.com/developer/article/1416283</a></p>
<h3 id="1-多线程的优点"><a href="#1-多线程的优点" class="headerlink" title="1. 多线程的优点"></a>1. 多线程的优点</h3><ul>
<li>无需跨进程边界；</li>
<li>程序逻辑和控制方式简单；</li>
<li>所有线程可以直接共享内存和变量等；</li>
<li>线程方式消耗的总资源比进程方式好；</li>
</ul>
<h3 id="2-多线程缺点"><a href="#2-多线程缺点" class="headerlink" title="2. 多线程缺点"></a>2. 多线程缺点</h3><ul>
<li>每个线程与主程序共用地址空间，受限于2GB地址空间；</li>
<li>线程之间的同步和加锁控制比较麻烦；</li>
<li>一个线程的崩溃可能影响到整个程序的稳定性；</li>
<li>到达一定的线程数程度后，即使再增加CPU也无法提高性能，例如Windows Server 2003，大约是1500个左右的线程数就快到极限了（线程堆栈设定为1M），如果设定线程堆栈为2M，还达不到1500个线程总数；</li>
<li>线程能够提高的总性能有限，而且线程多了之后，线程本身的调度也是一个麻烦事儿，需要消耗较多的CPU</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://wenwenhuan.gitee.io/2021/04/24/%E7%BC%93%E5%AD%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="温文焕">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wenhuan Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/04/24/%E7%BC%93%E5%AD%98/" class="post-title-link" itemprop="url">缓存</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-04-24 21:01:16" itemprop="dateCreated datePublished" datetime="2021-04-24T21:01:16+08:00">2021-04-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2021-05-12 12:07:12" itemprop="dateModified" datetime="2021-05-12T12:07:12+08:00">2021-05-12</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="什么是缓存"><a href="#什么是缓存" class="headerlink" title="什么是缓存"></a>什么是缓存</h2><p>所谓缓存，就是将程序或系统经常要调用的对象存在内存中，以便其使用时可以快速调用，不必再去创建新的重复的实例。这样做可以减少系统开销，提高系统效率。</p>
<p>缓存主要可分为二大类:</p>
<p>1：通过文件缓存,顾名思义文件缓存是指把数据存储在磁盘上，不管你是以XML格式，序列化文件DAT格式还是其它文件格式；</p>
<p>2：内存缓存，也就是创建一个静态内存区域，将数据存储进去，例如我们B/S架构的将数据存储在Application中或者存储在一个静态Map中。</p>
<h2 id="实现本地缓存"><a href="#实现本地缓存" class="headerlink" title="实现本地缓存"></a>实现本地缓存</h2><h3 id="1-存储集合的选择"><a href="#1-存储集合的选择" class="headerlink" title="1.存储集合的选择"></a>1.存储集合的选择</h3><p>实现本地缓存，存储容器肯定是 <strong>key/value 形式的数据结构</strong>，在 Java 中，也就是我们常用的 Map 集合。Map 中有 HashMap、Hashtable、ConcurrentHashMap 几种供我们选择，如果不考虑高并发情况下数据安全问题，我们可以选择HashMap，如果考虑高并发情况下数据安全问题，我们可以选择 Hashtable、ConcurrentHashMap 中的一种集合，但是我们优先选择 ConcurrentHashMap，因为 ConcurrentHashMap 的性能比 Hashtable 要好。</p>
<h3 id="2、过期缓存处理"><a href="#2、过期缓存处理" class="headerlink" title="2、过期缓存处理"></a>2、过期缓存处理</h3><p>因为缓存直接存储在内存中，如果我们不处理过期缓存，内存将被大量无效缓存占用，这不是我们想要的，所以我们需要清理这些失效的缓存。过期缓存处理可以参考 Redis 的策略来实现，Redis 采用的是定期删除 + 懒惰淘汰策略。</p>
<h4 id="定期删除策略"><a href="#定期删除策略" class="headerlink" title="定期删除策略"></a>定期删除策略</h4><p>定期删除策略是每隔一段时间检测已过期的缓存，并且将之删除。这个策略的优点是能够确保过期的缓存都会被删除。同时也存在着缺点，过期的缓存不一定能够及时的被删除，这跟我们设置的定时频率有关系，另一个缺点是如果缓存数据较多时，每次检测也会给 cup 带来不小的压力。</p>
<h4 id="懒惰淘汰策略"><a href="#懒惰淘汰策略" class="headerlink" title="懒惰淘汰策略"></a>懒惰淘汰策略</h4><p>懒惰淘汰策略是在使用缓存时，先判断缓存是否过期，如果过期将它删除，并且返回空。这个策略的优点是只有在查找的时候，才判断是否过期，对 CUP 影响较小。同时这种策略有致命的缺点，当存入了大量的缓存，这些缓存都没有被使用并且已过期，都将成为无效缓存，这些无效的缓存将占用你大量的内存空间，最后导致服务器内存溢出。</p>
<p>我们简单的了解了一下 Redis 的两种过期缓存处理策略，每种策略都存在自己的优缺点。所以我们在使用过程中，可以将两种策略组合起来，结合效果还是非常理想的。</p>
<h3 id="3、缓存淘汰策略"><a href="#3、缓存淘汰策略" class="headerlink" title="3、缓存淘汰策略"></a>3、缓存淘汰策略</h3><p>缓存淘汰跟过期缓存处理要区别开来，缓存淘汰是指当我们的缓存个数达到我们指定的缓存个数时，毕竟我们的内存不是无限的。如果我们需要继续添加缓存的话，我们就需要在现有的缓存中根据某种策略淘汰一些缓存，给新添加的缓存腾出位置，下面一起来认识几种常用的缓存淘汰策略。</p>
<h4 id="先进先出策略"><a href="#先进先出策略" class="headerlink" title="先进先出策略"></a>先进先出策略</h4><p>最先进入缓存的数据在缓存空间不够的情况下会被优先被清除掉，以腾出新的空间接受新的数据。该策略主要比较缓存元素的创建时间。在一些对数据实效性要求比较高的场景下，可考虑选择该类策略，优先保障最新数据可用。</p>
<h4 id="最少使用策略"><a href="#最少使用策略" class="headerlink" title="最少使用策略"></a>最少使用策略</h4><p>无论是否过期，根据元素的被使用次数判断，清除使用次数较少的元素释放空间。该策略主要比较元素的hitCount（命中次数），在保证高频数据有效性场景下，可选择这类策略。</p>
<h4 id="最近最少使用策略"><a href="#最近最少使用策略" class="headerlink" title="最近最少使用策略"></a>最近最少使用策略</h4><p>无论是否过期，根据元素最后一次被使用的时间戳，清除最远使用时间戳的元素释放空间。该策略主要比较缓存最近一次被get使用时间。在热点数据场景下较适用，优先保证热点数据的有效性。</p>
<h4 id="随机淘汰策略"><a href="#随机淘汰策略" class="headerlink" title="随机淘汰策略"></a>随机淘汰策略</h4><p>无论是否过期，随机淘汰某个缓存，如果对缓存数据没有任何要求，可以考虑使用该策略。</p>
<h4 id="不淘汰策略"><a href="#不淘汰策略" class="headerlink" title="不淘汰策略"></a>不淘汰策略</h4><p>当缓存达到指定值之后，不淘汰任何缓存，而是不能新增缓存，直到有缓存淘汰时，才能继续添加缓存。</p>
<p>上面是实现本地缓存需要考虑的三个点，看完我们应该知该如何实现一个本地缓存了，不妨我们一起来实现一个本地缓存。</p>
<h3 id="实现本地缓存-1"><a href="#实现本地缓存-1" class="headerlink" title="实现本地缓存"></a>实现本地缓存</h3><p>在该 Demo 中，我们采用 ConcurrentHashMap 作为存储集合，这样即使在高并发的情况下，我们也能够保证缓存的安全。过期缓存处理在这里我只使用了定时删除策略，并没有使用定时删除 + 懒惰淘汰策略，你可以自己动手尝试一下使用这两种策略进行过期缓存处理。在缓存淘汰方面，我在这里采用了最少使用策略。好了，技术选型都知道了，我们一起来看看代码实现。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://wenwenhuan.gitee.io/2021/04/17/%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E5%A4%A7%E5%88%A9%E6%B6%A6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="温文焕">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wenhuan Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/04/17/%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E5%A4%A7%E5%88%A9%E6%B6%A6/" class="post-title-link" itemprop="url">股票的最大利润</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-04-17 10:53:49 / 修改时间：11:16:06" itemprop="dateCreated datePublished" datetime="2021-04-17T10:53:49+08:00">2021-04-17</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>假设把某股票的价格按照时间先后顺序存储在数组中，请问买卖该股票一次可能获得的最大利润是多少？</p>
<h3 id="审题"><a href="#审题" class="headerlink" title="审题"></a>审题</h3><p>关键的两个限制是“最大”利润和买卖股票的时间顺序。</p>
<p>这两个限制表明，题目不是简单寻找数组中的最大最小值，而是要比较多种情况。</p>
<h3 id="自己的方法–暴力"><a href="#自己的方法–暴力" class="headerlink" title="自己的方法–暴力"></a>自己的方法–暴力</h3><p>思路：两个for循环，把每一种情况都计算出来，不断刷新最大的利润值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; prices.length; j++) &#123;</span><br><span class="line">            <span class="keyword">int</span> profit = prices[j] - prices[i];</span><br><span class="line">            <span class="keyword">if</span> (profit&gt;res)&#123;</span><br><span class="line">                res = profit;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>时间复杂度：O(n^2)，循环运行 [n(n-1)]/2次。</p>
<p>空间复杂度：O(1)。只使用了常数个变量。</p>
<h3 id="动态规划解题"><a href="#动态规划解题" class="headerlink" title="动态规划解题"></a>动态规划解题</h3><p>思路：分析四要素</p>
<img src="/2021/04/17/%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E5%A4%A7%E5%88%A9%E6%B6%A6/image-20210417110436812.png" class="" title="image-20210417110436812">

<p>难点是转移方程的分析</p>
<h4 id="效率优化："><a href="#效率优化：" class="headerlink" title="效率优化："></a>效率优化：</h4><img src="/2021/04/17/%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E5%A4%A7%E5%88%A9%E6%B6%A6/image-20210417110556220.png" class="" title="image-20210417110556220">

<p>时间复杂度降低较容易，相较于每次都要遍历一遍子数组寻找最低价格，借助变量保存并实时更新显然更合理。</p>
<p>空间复杂度的降低很巧妙，也是动态规划的核心，本来状态方程中最难解决的就是<code>dp[i]</code>是与<code>dp[i-1]</code>相关的，很像递归，在实现上很难处理，答案使用了和时间复杂度降低相似的做法，借助变量记录<code>dp[i-1]</code>.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> profit = <span class="number">0</span>,cost = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">        <span class="comment">//更新最小的prices</span></span><br><span class="line">        <span class="keyword">if</span> (prices[i]&lt;cost) cost = prices[i];</span><br><span class="line">        profit = Math.max(profit, prices[i]-cost);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> profit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="复杂度分析："><a href="#复杂度分析：" class="headerlink" title="复杂度分析："></a>复杂度分析：</h4><img src="/2021/04/17/%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E5%A4%A7%E5%88%A9%E6%B6%A6/image-20210417110618502.png" class="" title="image-20210417110618502">
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://wenwenhuan.gitee.io/2021/04/16/wldd/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="温文焕">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wenhuan Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/04/16/wldd/" class="post-title-link" itemprop="url">外伶仃岛攻略</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-04-16 19:39:32 / 修改时间：20:06:56" itemprop="dateCreated datePublished" datetime="2021-04-16T19:39:32+08:00">2021-04-16</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="出行方式：地铁-高铁-打车-船"><a href="#出行方式：地铁-高铁-打车-船" class="headerlink" title="出行方式：地铁+高铁+打车+船"></a>出行方式：地铁+高铁+打车+船</h3><p><strong>去程</strong></p>
<ul>
<li><p>家→广州南：地铁，一小时，九点出门</p>
</li>
<li><p>广州南→珠海站：高铁65/人,一小时左右，10:25-11:24或10:57-11:53（这趟有点太赶）</p>
</li>
<li><p>珠海站→香洲港：打车28左右，半个小时左右</p>
</li>
<li><p>香洲港→外伶仃岛：坐船120/人，一个半小时左右,12:40-13:50，提前半个小时排队取票</p>
</li>
</ul>
<p><strong>回程</strong></p>
<ul>
<li>外伶仃岛→香洲港：17：15→18:25</li>
<li>香洲港→珠海站：18:30-19:00</li>
<li>珠海站→广州南：19:20-20:29</li>
</ul>
<p>船票+高铁票往返=370￥</p>
<h3 id="住宿"><a href="#住宿" class="headerlink" title="住宿"></a>住宿</h3><p>聆海居榻榻米海景客栈，双床房，185/晚</p>
<p>距离码头走路6-7分钟</p>
<p><strong>参考地图</strong></p>
<img src="/2021/04/16/wldd/map.png" class="" title="image-20210416193536381">

<h3 id="游玩"><a href="#游玩" class="headerlink" title="游玩"></a>游玩</h3><p>岛内交通包括骑车和走路</p>
<img src="/2021/04/16/wldd/%E9%AA%91%E8%BD%A6.png" class="" title="39538248fe8c99575d55fd13bbe16ba">

<p><strong>1.矿石湖</strong></p>
<p>走路1-1.5小时</p>
<img src="/2021/04/16/wldd/%E7%9F%BF%E7%9F%B3%E6%B9%961.jpg" class="" title="41bd865bf60abdfb260c8b23469958a">
<img src="/2021/04/16/wldd/%E7%9F%BF%E7%9F%B3%E6%B9%962.png" class="" title="46ad7e878a8de0100135420a2af1d1e">
<p>2.<strong>看日出</strong></p>
<p>参考路线</p>
<p>去山顶可能四点就要起床了</p>
<img src="/2021/04/16/wldd/sun.jpg" class="" title="1bcfa63e2a23a812b4850428c94937a">

<h3 id="饮食"><a href="#饮食" class="headerlink" title="饮食"></a>饮食</h3><p>外伶仃岛特色小吃：海胆、狗爪螺和将军帽</p>
<img src="/2021/04/16/wldd/%E9%A5%AE%E9%A3%9F2.png" class="" title="acba6652fd072abc0b207235c0e43d7">

<img src="/2021/04/16/wldd/%E9%A5%AE%E9%A3%9F.png" class="" title="image-20210416193716389">
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://wenwenhuan.gitee.io/2021/04/12/Java%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="温文焕">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wenhuan Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/04/12/Java%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">Java的一些基础知识点</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-04-12 23:11:00 / 修改时间：23:17:58" itemprop="dateCreated datePublished" datetime="2021-04-12T23:11:00+08:00">2021-04-12</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="hashmap如何实现"><a href="#hashmap如何实现" class="headerlink" title="hashmap如何实现"></a>hashmap如何实现</h2><p>HashMap是使用<strong>hash算法</strong>,然后基于<strong>数组+链表+红黑树</strong>来实现的,或许还知道HashMap内部数组的初始长度为<strong>16</strong>,并且还能<strong>自动扩容</strong>.</p>
<p><strong>简单来说，HashMap由数组+链表组成的，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的，如果定位到的数组位置不含链表（当前entry的next指向null）,那么对于查找，添加等操作很快，仅需一次寻址即可；如果定位到的数组包含链表，对于添加操作，其时间复杂度为O(n)，首先遍历链表，存在即覆盖，否则新增；对于查找操作来讲，仍需遍历链表，然后通过key对象的equals方法逐一比对查找。所以，性能考虑，HashMap中的链表出现越少，性能才会越好。</strong></p>
<p><img src="C:%5CUsers%5CPowerwenwh%5CDocuments%5CMyBlog%5Csource%5C_posts%5Cimgs%5CJava%E5%9F%BA%E7%A1%80%5C1024555-20161113235348670-746615111.png" alt="img"></p>
<p><img src="C:%5CUsers%5CPowerwenwh%5CDocuments%5CMyBlog%5Csource%5C_posts%5Cimgs%5CJava%E5%9F%BA%E7%A1%80%5C1292434-20171210003109576-1016700625.jpg" alt="img"></p>
<p>我们可以看到12和0的位置冲突了，然后我们把该数组的每一个元素变成了一个链表头，冲突的元素放在了链表中，这样在找到对应的链表头之后会顺着链表找下去，至于<strong>为什么采用链表，是为了节省空间，链表在内存中并不是连续存储</strong>，所以我们可以更充分地使用内存。</p>
<h2 id="ReentrantLock与synchronized（同步锁）锁"><a href="#ReentrantLock与synchronized（同步锁）锁" class="headerlink" title="ReentrantLock与synchronized（同步锁）锁"></a>ReentrantLock与synchronized（同步锁）锁</h2><p><strong>线程不同步的原因</strong></p>
<p>线程之所以会不同步，<strong>本质原因在于每个线程的高速缓存区</strong>。每个线程在创建后会有自己的一个缓存区，在线程要访问主存中的变量的时候会先将主存中的变量加入缓存，然后进行操作，这样可以避免主存访问过于频繁，可以加快线程的执行效率（类似于cache）。但问题在于每个线程的缓存区之间不可见，如果载入的是主存中的同一个变量，分别进行了更改，就会出现线程不同步的问题。</p>
<p><strong>synchronized是如何实现同步的##</strong></p>
<p>好吧其实很简单，比较机智的读者可能已经猜到了，他其实是使各个线程之间的高速缓存区失效了，然后线程要获取该变量的时候需要在主存中读写，这个时候对该变量的操作对于各个线程之间是可见的，然后操作结束之后再刷新其缓存区，</p>
<p><strong>reentrantlock</strong></p>
<p>synchonized的缺点。一是不灵活，<strong>synchonized在锁定之后必须要代码块结束之后才能释放锁</strong>，然后被其他线程获得。那么如果获取到锁的这个线程要执行非常长的时间呢，那其他的线程不是会一直阻塞在这里，这时如果有哪个线程生气了不想等了怎么办？抱歉不可以，需要一直等待。另一方面，同步锁的<strong>释放顺序也很固定</strong>，必须是加锁的反顺序，很不潇洒等等。。。</p>
<p>声明了ReentrantLock对象后只需调用其中的lock方法便可直接加锁，而释放锁需要unlock方法。这样一是很灵活，<strong>不需要代码块结束再释放</strong>，还有就是 ReentrantLock是可中断的，如果等待的线程不想等了，好说，interrupt掉就好了，另外， <strong>ReentrantLock可以设为悲观锁和乐观锁，而synchonized则默认为悲观锁</strong>，不可改变，不够灵活。所以综上，ReentrantLock更加灵活多变。但大家在使用时一定要记得unlock，最好写在finally里面防止忘记，不然就会造成其他线程阻塞。</p>
<h2 id="Java中的锁分类"><a href="#Java中的锁分类" class="headerlink" title="Java中的锁分类"></a>Java中的锁分类</h2><p>Java中锁分为以下几种：</p>
<ul>
<li>乐观锁、悲观锁</li>
<li>独享锁、共享锁</li>
<li>公平锁、非公平锁</li>
<li>互斥锁、读写锁</li>
<li>可重入锁</li>
<li>分段锁</li>
<li>锁升级(无锁 -&gt; 偏向锁 -&gt; 轻量级锁 -&gt; 重量级锁) JDK1.6</li>
</ul>
<p>这些锁的分类并不全是指锁的状态，有的指<strong>锁的特性，有的指锁的设计</strong>，下面总结的内容是对每个锁的名词进行一定的解释。</p>
<h3 id="1、乐观锁-amp-悲观锁"><a href="#1、乐观锁-amp-悲观锁" class="headerlink" title="1、乐观锁 &amp; 悲观锁"></a>1、乐观锁 &amp; 悲观锁</h3><p>两种锁只是一种概念</p>
<p><strong>乐观锁：</strong>乐观锁认为一个线程去拿数据的时候不会有其他线程对数据进行更改，所以不会上锁。</p>
<p>实现方式：CAS机制、版本号机制</p>
<p><strong>悲观锁：</strong>悲观锁认为一个线程去拿数据时一定会有其他线程对数据进行更改。所以一个线程在拿数据的时候都会顺便加锁，这样别的线程此时想拿这个数据就会阻塞。比如Java里面的synchronized关键字的实现就是悲观锁。实现方式：就是加锁。</p>
<h3 id="2、独享锁-amp-共享锁"><a href="#2、独享锁-amp-共享锁" class="headerlink" title="2、独享锁 &amp; 共享锁"></a>2、独享锁 &amp; 共享锁</h3><p>两种锁只是一种概念</p>
<p><strong>独享锁：</strong>该锁一次只能被一个线程所持有</p>
<p><strong>共享锁：</strong>该锁可以被多个线程所持有</p>
<p>举例：</p>
<p>synchronized是独享锁；</p>
<p>可重入锁ReentrantLock是独享锁；</p>
<p>读写锁ReentrantReadWriteLock中的读锁ReadLock是共享锁，写锁WriteLock是独享锁。</p>
<p>独享锁与共享锁通过AQS(AbstractQueuedSynchronizer)来实现的，通过实现不同的方法，来实现独享或者共享。</p>
<h3 id="3、互斥锁-amp-读写锁"><a href="#3、互斥锁-amp-读写锁" class="headerlink" title="3、互斥锁 &amp; 读写锁"></a>3、互斥锁 &amp; 读写锁</h3><p>上面讲的独享锁/共享锁就是一种概念，互斥锁/读写锁是具体的实现。</p>
<p><strong>互斥锁</strong>的具体实现就是synchronized、ReentrantLock。ReentrantLock是JDK1.5的新特性，采用ReentrantLock可以完全替代替换synchronized传统的锁机制，更加灵活。</p>
<p><strong>读写锁</strong>的具体实现就是读写锁ReadWriteLock。</p>
<h3 id="4、可重入锁"><a href="#4、可重入锁" class="headerlink" title="4、可重入锁"></a>4、可重入锁</h3><p>定义：对于同一个线程在外层方法获取锁的时候，在进入内层方法时也会自动获取锁。</p>
<p>优点：避免死锁</p>
<p>举例：ReentrantLock、synchronized</p>
<h3 id="5、公平锁-amp-非公平锁"><a href="#5、公平锁-amp-非公平锁" class="headerlink" title="5、公平锁 &amp; 非公平锁"></a>5、公平锁 &amp; 非公平锁</h3><p><strong>公平锁：</strong>多个线程相互竞争时要排队，多个线程按照申请锁的顺序来获取锁。</p>
<p><strong>非公平锁：</strong>多个线程相互竞争时，先尝试插队，插队失败再排队，比如：synchronized、ReentrantLock</p>
<h3 id="6、分段锁"><a href="#6、分段锁" class="headerlink" title="6、分段锁"></a>6、分段锁</h3><p>分段锁并不是具体的一种锁，只是一种锁的设计。</p>
<p>分段锁的设计目的是细化锁的粒度，当操作不需要更新整个数组的时候，就仅仅针对数组中的一项进行加锁操作。CurrentHashMap底层就用了分段锁，使用Segment，就可以进行并发使用了，而HashMap确实非线程安全的，就差在了分段锁上。</p>
<h3 id="7、偏向锁-amp-轻量级锁-amp-重量级锁"><a href="#7、偏向锁-amp-轻量级锁-amp-重量级锁" class="headerlink" title="7、偏向锁 &amp; 轻量级锁 &amp; 重量级锁"></a>7、偏向锁 &amp; 轻量级锁 &amp; 重量级锁</h3><p>JDK 1.6 为了减少获得锁和释放锁所带来的性能消耗，在JDK 1.6里引入了4种锁的状态：<strong>无锁、偏向锁、轻量级锁和重量级锁</strong>，它会随着多线程的竞争情况逐渐升级，但不能降级。</p>
<p>研究发现大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了不让这个线程每次获得锁都需要CAS操作的性能消耗，就引入了偏向锁。当一个线程访问对象并获取锁时，会在对象头里存储锁偏向的这个线程的ID，以后该线程再访问该对象时只需判断对象头的Mark Word里是否有这个线程的ID，如果有就不需要进行CAS操作，这就是偏向锁。当线程竞争更激烈时，偏向锁就会升级为轻量级锁，轻量级锁认为虽然竞争是存在的，但是理想情况下竞争的程度很低，通过自旋方式等待一会儿上一个线程就会释放锁，但是当自旋超过了一定次数，或者一个线程持有锁，一个线程在自旋，又来了第三个线程访问时（反正就是竞争继续加大了），轻量级锁就会膨胀为重量级锁，重量级锁就是Synchronized,重量级锁会使除了此时拥有锁的线程以外的线程都阻塞。</p>
<h2 id="Java数组和链表的区别"><a href="#Java数组和链表的区别" class="headerlink" title="Java数组和链表的区别"></a>Java数组和链表的区别</h2><p>从数据结构上说，数组的<strong>内存空间是连续的</strong>，我们创建数组的时候系统就会为我们开辟固定数目的内存空间，如果内存不足，就会创建失败，例如创建数组的两种方式：<br>int[] a=new int[3];<br>int[] b=new int[]{1,2,3};<br>可以看到我们创建数组的时候已经指定了数组的大小，且不能动态更改数组的大小，是因为创建时候已经分配了连续的固定内存空间，每个元素占用两个字节，这样我们就可以通过连续的内存，去访问数组的元素；</p>
<p><strong>链表的内存分配是动态的</strong>，链表的元素占用的空间包含元素占用的空间，还有指向上一个或者下一个元素的指针（双链表，单链表）；</p>
<p>这样我们可以得出各自的优缺点：</p>
<p>数组链表的优缺点：<br><strong>数组占用空间小</strong>，链表元素还要包涵上一元素和下一个元素的的信息<br><strong>数组的访问速度快</strong>，因为内存是连续的<br><strong>数组内部元素可以随机访问</strong>，而链表依赖于上一个元素的信息</p>
<p>链表的插入删除操作由于数组，因为内存不连续，只需要更改元素的前后节点信息就行了，并不需要更改元素内存地址，而数组的连续内存想要插入和删除的话就要移动所有的内存地址<br>链表的<strong>内存利用率高于数组</strong>，链表内存是分散的一个元素占用一块空间，数组元素少于内存空间的话，会有部分的内存浪费；<br>链表的<strong>扩展性强</strong>，数组的创建完成内存大小就确定了，满了就没法扩展只能再次创建新的数组，而链表可以随意的增加扩展</p>
<p>效率：数组查询效率高，链表增，删效率高</p>
<h2 id="列举两种单例模式"><a href="#列举两种单例模式" class="headerlink" title="列举两种单例模式"></a>列举两种单例模式</h2><p>Java中单例模式是一种常见的设计模式，单例模式的写法有好几种，这里主要介绍懒汉式单例、饿汉式单例.</p>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a><strong>介绍</strong></h3><p>意图：保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p>
<p>主要解决：一个全局使用的类频繁地创建与销毁。</p>
<p>何时使用：当您<strong>想控制实例数目，节省系统资源的时候。</strong></p>
<p>如何解决：判断系统是否已经有这个单例，如果有则返回，如果没有则创建。</p>
<p>关键代码：构造函数是私有的。</p>
<p>应用实例： 1、一个党只能有一个书记。 2、Windows 是多进程多线程的，在操作一个文件的时候，就不可避免地出现多个进程或线程同时操作一个文件的现象，所以所有文件的处理必须通过唯一的实例来进行。 3、一些设备管理器常常设计为单例模式，比如一个电脑有两台打印机，在输出的时候就要处理不能两台打印机打印同一个文件。</p>
<p>优点： 1、在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例（比如管理学院首页页面缓存）。 2、避免对资源的多重占用（比如写文件操作）。</p>
<p>缺点：没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。</p>
<p>使用场景： 1、要求生产唯一序列号。 2、WEB 中的计数器，不用每次刷新都在数据库里加一次，用单例先缓存起来。 3、创建的一个对象需要消耗的资源过多，比如 I/O 与数据库的连接等。</p>
<p>特点：</p>
<ol>
<li>单例模式只能有一个实例。</li>
<li>单例模式必须自己创建自己的唯一实例。</li>
<li>单例模式的构造器必须是私有，不允许外界通过构造器构建对象。</li>
<li>单例模式只能通过公开的静态方法向外界返回类的唯一实例。</li>
</ol>
<h3 id="饿汉式单例"><a href="#饿汉式单例" class="headerlink" title="饿汉式单例"></a><strong>饿汉式单例</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonEH</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *是否 Lazy 初始化：否</span></span><br><span class="line"><span class="comment">     *是否多线程安全：是</span></span><br><span class="line"><span class="comment">     *实现难度：易</span></span><br><span class="line"><span class="comment">     *描述：这种方式比较常用，但容易产生垃圾对象。</span></span><br><span class="line"><span class="comment">     *优点：没有加锁，执行效率会提高。</span></span><br><span class="line"><span class="comment">     *缺点：类加载时就初始化，浪费内存。</span></span><br><span class="line"><span class="comment">     *它基于 classloder 机制避免了多线程的同步问题，</span></span><br><span class="line"><span class="comment">     * 不过，instance 在类装载时就实例化，虽然导致类装载的原因有很多种，</span></span><br><span class="line"><span class="comment">    * 在单例模式中大多数都是调用 getInstance 方法，</span></span><br><span class="line"><span class="comment">     * 但是也不能确定有其他的方式（或者其他的静态方法）导致类装载，</span></span><br><span class="line"><span class="comment">     * 这时候初始化 instance 显然没有达到 lazy loading 的效果。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingletonEH instance = <span class="keyword">new</span> SingletonEH();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonEH</span> <span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonEH <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;instance:&quot;</span>+instance);</span><br><span class="line">        System.out.println(<span class="string">&quot;加载饿汉式....&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>饿汉就是类一旦加载，就把单例初始化完成，保证getInstance的时候，单例是已经存在的了。</p>
<h3 id="懒汉式单例"><a href="#懒汉式单例" class="headerlink" title="懒汉式单例"></a><strong>懒汉式单例</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonLH</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *是否 Lazy 初始化：是</span></span><br><span class="line"><span class="comment">     *是否多线程安全：否</span></span><br><span class="line"><span class="comment">     *实现难度：易</span></span><br><span class="line"><span class="comment">     *描述：这种方式是最基本的实现方式，这种实现最大的问题就是不支持多线程。因为没有加锁 synchronized，所以严格意义上它并不算单例模式。</span></span><br><span class="line"><span class="comment">     *这种方式 lazy loading 很明显，不要求线程安全，在多线程不能正常工作。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingletonLH instance;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonLH</span> <span class="params">()</span></span>&#123;&#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonLH <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> SingletonLH();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而懒汉比较懒，只有当调用getInstance的时候，才回去初始化这个单例。</p>
<h3 id="1、线程安全："><a href="#1、线程安全：" class="headerlink" title="1、线程安全："></a><strong>1、线程安全：</strong></h3><p>饿汉式天生就是线程安全的，可以直接用于多线程而不会出现问题，</p>
<p>懒汉式本身是非线程安全的，为了实现线程安全有几种写法。</p>
<p>例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">	</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonLHsyn</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *是否 Lazy 初始化：是</span></span><br><span class="line"><span class="comment">     *是否多线程安全：是</span></span><br><span class="line"><span class="comment">     *实现难度：易</span></span><br><span class="line"><span class="comment">     *描述：这种方式具备很好的 lazy loading，能够在多线程中很好的工作，但是，效率很低，99% 情况下不需要同步。</span></span><br><span class="line"><span class="comment">     *优点：第一次调用才初始化，避免内存浪费。</span></span><br><span class="line"><span class="comment">     *缺点：必须加锁 synchronized 才能保证单例，但加锁会影响效率。</span></span><br><span class="line"><span class="comment">     *getInstance() 的性能对应用程序不是很关键（该方法使用不太频繁）。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingletonLHsyn instance;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonLHsyn</span> <span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> SingletonLHsyn <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> SingletonLHsyn();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2、资源加载和性能："><a href="#2、资源加载和性能：" class="headerlink" title="2、资源加载和性能："></a><strong>2、资源加载和性能：</strong></h3><p>饿汉式在类创建的同时就实例化一个静态对象出来，不管之后会不会使用这个单例，都会占据一定的内存，但是相应的，在第一次调用时速度也会更快，因为其资源已经初始化完成。</p>
<p>而懒汉式顾名思义，会延迟加载，在第一次使用该单例的时候才会实例化对象出来，第一次调用时要做初始化，如果要做的工作比较多，性能上会有些延迟，之后就和饿汉式一样了。</p>
<h3 id="为什么要用单例模式？"><a href="#为什么要用单例模式？" class="headerlink" title="为什么要用单例模式？"></a><strong>为什么要用单例模式？</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Printer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Printer printer =<span class="keyword">null</span>;<span class="comment">//创建一个私有的全局变量</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 如果有多线程并发访问时，上锁，让其排队等候，一次只能一人用。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Printer <span class="title">getPrinter</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(printer==<span class="keyword">null</span>)&#123;<span class="comment">//如果为空，创建本实例</span></span><br><span class="line">            printer = <span class="keyword">new</span> Printer();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> printer;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 构造私有化，保证在系统的使用中，只有一个实例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Printer</span><span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从代码上来分析，单例模式，首先向外提供了一个可被访问的实例化的对象，如果没有此对象时，该printer类创建一个。如果遇到多线程并发访问，加上关键字Synchronized，上锁让没有持有该对象的类处于等待状态。当前持有该printer的线程任务结束之后，处于等待中的线程才能逐个去持有该实例，去操作其方法。这样的一个过程 在编程中被称为单例模式。<br>如果在系统中不使用单例模式的话，在碰到多线程访问的时候，<u>printer就会给要请求的类，分别在内存中new出一个printer对象</u>，让这些请求的类去做print方法。这样<u>大量占有内存，就会导致系统运行变慢</u>，像电脑的CPU一样，占有量极高，电脑卡死不动的感觉。因为系统的硬件设施需求变动量小，所以只能想出一个节约成本 的方法就是，单例模式，<u>让多线程处于等待的状态，一个 一个的去解决</u>，这样，即节约内存，提交了运行的成本。也就是单例存在的意义。</p>
<h2 id="重写和重载的区别"><a href="#重写和重载的区别" class="headerlink" title="重写和重载的区别"></a>重写和重载的区别</h2><p><strong>重写</strong>:</p>
<p>重写（Override）是<strong>父类与子类之间多态性的一种表现</strong>。如果在子类中定义某方法与其父类有<strong>相同的名称和参数</strong>，我们说该方法被重写 (Override)。子类的对象使用这个方法时，将调用子类中的定义，对它而言，父类中的定义如同被“<strong>屏蔽</strong>”了。</p>
<p><strong>重载：</strong></p>
<p>重载（Overload）是<strong>一个类中多态性的一种表现</strong>。如果在一个类中定义了多个同名的方法，它们<strong>参数列表不同</strong>，则称为方法的重载(Overload)</p>
<p><strong>区别：</strong>重载实现于一个类中;重写实现于子类中。</p>
<p>重载(Overload)：是一个类中多态性的一种表现，指同一个类中不同的函数使用<strong>相同的函数名</strong>，但是<strong>函数的参数个数或类型不同</strong>。可以有<strong>不同的返回类型</strong>;可以有不同的访问修饰符;可以抛出不同的异常。调用的时候根据函数的参数来区别不同的函数。</p>
<p>重写（Override): 是父类与子类之间的多态性，是<strong>子类对父类函数的重新实现</strong>。<strong>函数名和参数与父类一样</strong>，子类与父类<strong>函数体内容不一样</strong>。子类<strong>返回的类型</strong>必须与父类保持一致；子类方法访问修饰符的限制一定要大于父类方法的访问修饰（public&gt;protected&gt;default&gt;private）；子类重写方法一定不能抛出新的检查异常或者比被父类方法申明更加宽泛的检查型异常。</p>
<h2 id="重载"><a href="#重载" class="headerlink" title="重载"></a><strong>重载</strong></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.etime09;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Goods</span> </span>&#123;  <span class="comment">//创建一个商品类 </span></span><br><span class="line"><span class="keyword">private</span> String ID;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> price;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> String manufactureDate;</span><br><span class="line"><span class="comment">//实现构造函数的重载 参数个数或类型不同</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Goods</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">super</span>();</span><br><span class="line">	<span class="comment">// TODO Auto-generated constructor stub</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Goods</span><span class="params">(String iD)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">super</span>();</span><br><span class="line">	ID = iD;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Goods</span><span class="params">(String iD, <span class="keyword">int</span> price)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">super</span>();</span><br><span class="line">	ID = iD;</span><br><span class="line">	<span class="keyword">this</span>.price = price;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Goods</span><span class="params">(String iD, <span class="keyword">int</span> price, String name)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">super</span>();</span><br><span class="line">	ID = iD;</span><br><span class="line">	<span class="keyword">this</span>.price = price;</span><br><span class="line">	<span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Goods</span><span class="params">(String iD, <span class="keyword">int</span> price, String name, String manufactureDate)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">super</span>();</span><br><span class="line">	ID = iD;</span><br><span class="line">	<span class="keyword">this</span>.price = price;</span><br><span class="line">	<span class="keyword">this</span>.name = name;</span><br><span class="line">	<span class="keyword">this</span>.manufactureDate = manufactureDate;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="重写"><a href="#重写" class="headerlink" title="重写"></a><strong>重写</strong></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.etime09;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;  <span class="comment">//创建一个父类Person</span></span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"><span class="comment">//父类中写一个eat()方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;人都要吃饭&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br><span class="line">---------------------------------------------</span><br><span class="line"><span class="keyword">package</span> com.etime09;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;  <span class="comment">//Student子类继承Person父类</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="comment">//重写eat()方法   方法名，参数，返回类型相同；方法体内容不同</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	System.out.println(<span class="string">&quot;学生喜欢吃肉&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="面向对象三大特征"><a href="#面向对象三大特征" class="headerlink" title="面向对象三大特征"></a>面向对象三大特征</h2><h3 id="1-封装-Encapsulation"><a href="#1-封装-Encapsulation" class="headerlink" title="(1)封装(Encapsulation)"></a>(1)封装(Encapsulation)</h3><p><strong>所谓封装，也就是把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏</strong>。封装是面向对象的特征之一，是对象和类概念的主要特性。简单的说，一个类就是一个封装了数据以及操作这些数据的代码的逻辑实体。在一个对象内部，某些代码或某些数据可以是私有的，不能被外界访问。通过这种方式，对象对内部数据提供了不同级别的保护，以防止程序中无关的部分意外的改变或错误的使用了对象的私有部分。</p>
<hr>
<h3 id="2-继承-Inheritance"><a href="#2-继承-Inheritance" class="headerlink" title="(2)继承(Inheritance)"></a>(2)继承(Inheritance)</h3><p><strong>继承是指这样一种能力：它可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展</strong>。通过继承创建的新类称为“子类”或“派生类”，被继承的类称为“基类”、“父类”或“超类”。继承的过程，就是从一般到特殊的过程。要实现继承，可以通过“继承”（Inheritance）和“组合”（Composition）来实现。继承概念的实现方式有二类：<strong>实现继承与接口继承</strong>。</p>
<ul>
<li>实现继承是指直接使用基类的属性和方法而无需额外编码的能力；</li>
<li>接口继承是指仅使用属性和方法的名称、但是子类必须提供实现的能力。</li>
</ul>
<hr>
<h3 id="3-多态-Polymorphism"><a href="#3-多态-Polymorphism" class="headerlink" title="(3)多态(Polymorphism)"></a>(3)多态(Polymorphism)</h3><p><strong>所谓多态就是指一个类实例的相同方法在不同情形有不同表现形式。多态机制使具有不同内部结构的对象可以共享相同的外部接口</strong>。这意味着，虽然针对不同对象的具体操作不同，但通过一个公共的类，它们（那些操作）可以通过相同的方式予以调用。最常见的多态就是将子类传入父类参数中，运行时调用父类方法时通过传入的子类决定具体的内部结构或行为。</p>
<h2 id="MySQL两种引擎"><a href="#MySQL两种引擎" class="headerlink" title="MySQL两种引擎"></a>MySQL两种引擎</h2><p>MySQL应用最广泛的有两种存储引擎：</p>
<p><strong>一个是MyISAM</strong>，不支持事务处理，读性能处理快，表级别锁。</p>
<p><strong>一个是InnoDB</strong>，支持事务处理（ACID属性）,设计目标是为大数据处理，行级别锁，外键。</p>
<p>ACID（Atomicity 原子性、Consistency 一致性、Isolation 隔离性、Durability 持久性）是一系列属性</p>
<p>表锁：开销小，锁定粒度大，发生死锁概率高，相对并发也低。<br>行锁：开销大，锁定粒度小，发生死锁概率低，相对并发也高。</p>
<p>InnoDB不支持FULLTEXT类型的索引。</p>
<p>InnoDB 中不保存表的具体行数，也就是说，执行select count(<em>) from table时，InnoDB要扫描一遍整个表来计算有多少行，但是MyISAM只要简单的读出保存好的行数即可。注意的是，当count(</em>)语句包含 where条件时，两种表的操作是一样的。</p>
<p>对于AUTO_INCREMENT类型的字段，InnoDB中必须包含只有该字段的索引，但是在MyISAM表中，可以和其他字段一起建立联合索引。</p>
<p>DELETE FROM table时，InnoDB不会重新建立表，而是一行一行的删除。</p>
<p>LOAD TABLE FROM MASTER操作对InnoDB是不起作用的，解决方法是首先把InnoDB表改成MyISAM表，导入数据后再改成InnoDB表，但是对于使用的额外的InnoDB特性(例如外键)的表不适用。</p>
<p>另外，InnoDB表的行锁也不是绝对的，假如在执行一个SQL语句时MySQL不能确定要扫描的范围，InnoDB表同样会锁全表，例如update table set num=1 where name like “%aaa%”</p>
<p>作为使用MySQL的用户角度出发，Innodb和MyISAM都是比较喜欢的，如果数据库平台要达到需求：99.9%的稳定性，方便的扩展性和高可用性来说的话，MyISAM绝对是首选。</p>
<p>　　原因如下：</p>
<p>　　1、平台上承载的大部分项目是读多写少的项目，而MyISAM的读性能是比Innodb强不少的。</p>
<p>　　2、MyISAM的索引和数据是分开的，并且索引是有压缩的，内存使用率就对应提高了不少。能加载更多索引，而Innodb是索引和数据是紧密捆绑的，没有使用压缩从而会造成Innodb比MyISAM体积庞大不小。</p>
<p>　　3、经常隔1，2个月就会发生应用开发人员不小心update一个表where写的范围不对，导致这个表没法正常用了，这个时候MyISAM的优越性就体现出来了，随便从当天拷贝的压缩包取出对应表的文件，随便放到一个数据库目录下，然后dump成sql再导回到主库，并把对应的binlog补上。如果是Innodb，恐怕不可能有这么快速度，别和我说让Innodb定期用导出xxx.sql机制备份，因为最小的一个数据库实例的数据量基本都是几十G大小。</p>
<p>　　4、从接触的应用逻辑来说，select count(*) 和order by 是最频繁的，大概能占了整个sql总语句的60%以上的操作，而这种操作Innodb其实也是会锁表的，很多人以为Innodb是行级锁，那个只是where对它主键是有效，非主键的都会锁全表的。</p>
<p>　　5、还有就是经常有很多应用部门需要我给他们定期某些表的数据，MyISAM的话很方便，只要发给他们对应那表的frm.MYD,MYI的文件，让他们自己在对应版本的数据库启动就行，而Innodb就需要导出xxx.sql了，因为光给别人文件，受字典数据文件的影响，对方是无法使用的。</p>
<p>　　6、如果和MyISAM比insert写操作的话，Innodb还达不到MyISAM的写性能，如果是针对基于索引的update操作，虽然MyISAM可能会逊色Innodb,但是那么高并发的写，从库能否追的上也是一个问题，还不如通过多实例分库分表架构来解决。</p>
<p>　　7、如果是用MyISAM的话，merge引擎可以大大加快应用部门的开发速度，他们只要对这个merge表做一些select count(*)操作，非常适合大项目总量约几亿的rows某一类型(如日志，调查统计)的业务表。</p>
<p>　　当然Innodb也不是绝对不用，用事务的项目就用Innodb的。另外，可能有人会说你MyISAM无法抗太多写操作，但是可以通过架构来弥补。</p>
<h2 id="预防死锁"><a href="#预防死锁" class="headerlink" title="预防死锁"></a>预防死锁</h2><p><strong>死锁</strong><br>当线程A持有独占锁a，并尝试去获取独占锁b的同时，线程B持有独占锁b，并尝试获取独占锁a的情况下，就会发生AB两个线程由于互相持有对方需要的锁，而发生的阻塞现象，我们称为死锁。</p>
<p><strong>如何避免死锁？</strong></p>
<p>教科书般的回答应该是，结合“哲学家就餐”模型，分析并总结出以下死锁的原因，最后得出“避免死锁就是破坏造成死锁的，若干条件中的任意一个”的结论。</p>
<p>造成死锁必须达成的4个条件（原因）：</p>
<ol>
<li><strong>互斥条件</strong>：一个资源每次只能被一个线程使用。</li>
<li><strong>请求与保持条件</strong>：一个线程因请求资源而阻塞时，对已获得的资源保持不放。</li>
<li><strong>不剥夺条件</strong>：线程已获得的资源，在未使用完之前，不能强行剥夺。</li>
<li><strong>循环等待条件</strong>：若干线程之间形成一种头尾相接的循环等待资源关系。</li>
</ol>
<p>但是，“哲学家就餐”光看名字就很讨厌，然后以上这4个条件看起来也很绕口，再加上笔者又是个懒人，所以要让我在面试时把这些“背诵”出来实在是太难了！必须要想办法把这4个条件简化一下！<br> 于是，通过对4个造成死锁的条件进行逐条分析，我们可以得出以下4个结论。</p>
<ol>
<li>互斥条件 —&gt; 独占锁的特点之一。</li>
<li>请求与保持条件 —&gt; 独占锁的特点之一，尝试获取锁时并不会释放已经持有的锁</li>
<li>不剥夺条件 —&gt; 独占锁的特点之一。</li>
<li>循环等待条件 —&gt; 唯一需要记忆的造成死锁的条件。</li>
</ol>
<p>不错！复杂的死锁条件经过简化，现在需要记忆的仅只有独占锁与第四个条件而已。</p>
<p>所以，面对如何避免死锁这个问题，我们只需要这样回答！<br> :   在并发程序中，避免了逻辑中出现复数个线程互相持有对方线程所需要的独占锁的情况，就可以避免死锁。</p>
<h2 id="JVM内存结构-VS-Java内存模型-VS-Java对象模型"><a href="#JVM内存结构-VS-Java内存模型-VS-Java对象模型" class="headerlink" title="JVM内存结构 VS Java内存模型 VS Java对象模型"></a>JVM内存结构 VS Java内存模型 VS Java对象模型</h2><h3 id="JVM内存结构"><a href="#JVM内存结构" class="headerlink" title="JVM内存结构"></a>JVM内存结构</h3><p>Java代码是要运行在虚拟机上的，而虚拟机在执行Java程序的过程中会把所管理的内存划分为若干个不同的数据区域，这些区域都有各自的用途。其中有些区域随着虚拟机进程的启动而存在，而有些区域则依赖用户线程的启动和结束而建立和销毁。</p>
<p><img src="C:%5CUsers%5CPowerwenwh%5CDocuments%5CMyBlog%5Csource%5C_posts%5Cimgs%5CJava%E5%9F%BA%E7%A1%80%5CQQ20180624-150918.png" alt="QQ20180624-150918"></p>
<p>1、以上是Java虚拟机规范，不同的虚拟机实现会各有不同，但是一般会遵守规范。</p>
<p>2、规范中定义的方法区，只是一种概念上的区域，并说明了其应该具有什么功能。但是并没有规定这个区域到底应该处于何处。所以，对于不同的虚拟机实现来说，是由一定的自由度的。</p>
<p>3、不同版本的方法区所处位置不同，上图中划分的是逻辑区域，并不是绝对意义上的物理区域。因为某些版本的JDK中方法区其实是在堆中实现的。</p>
<p>4、运行时常量池用于存放编译期生成的各种字面量和符号应用。但是，Java语言并不要求常量只有在编译期才能产生。比如在运行期，String.intern也会把新的常量放入池中。</p>
<p>5、除了以上介绍的JVM运行时内存外，还有一块内存区域可供使用，那就是直接内存。Java虚拟机规范并没有定义这块内存区域，所以他并不由JVM管理，是利用本地方法库直接在堆外申请的内存区域。</p>
<p>6、堆和栈的数据划分也不是绝对的，如HotSpot的JIT会针对对象分配做相应的优化。</p>
<p>如上，做个总结，JVM内存结构，由Java虚拟机规范定义。描述的是Java程序执行过程中，由JVM管理的不同数据区域。各个区域有其特定的功能。</p>
<h3 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h3><p>Java内存模型看上去和Java内存结构（JVM内存结构）差不多，很多人会误以为两者是一回事。</p>
<p>在前面的关于JVM的内存结构的图中，我们可以看到，其中Java堆和方法区的区域是多个线程共享的数据区域。也就是说，多个线程可能可以操作保存在堆或者方法区中的同一个数据。这也就是我们常说的“Java的线程间通过共享内存进行通信”。</p>
<p>Java内存模型是根据英文Java Memory Model（JMM）翻译过来的。其实JMM并不像JVM内存结构一样是真实存在的。他只是一个<strong>抽象的概念</strong>。<a target="_blank" rel="noopener" href="http://www.cs.umd.edu/~pugh/java/memoryModel/jsr133.pdf">JSR-133: Java Memory Model and Thread Specification</a>中描述了，JMM是<strong>和多线程相关的</strong>，他描述了<strong>一组规则或规范</strong>，这个规范定义了一个线程对共享变量的写入时对另一个线程是可见的。</p>
<p>那么，简单总结下，<strong>Java的多线程之间是通过共享内存进行通信的</strong>，而由于采用共享内存进行通信，在通信过程中会存在一系列如<strong>可见性、原子性、顺序性等问题</strong>，而JMM就是围绕着多线程通信以及与其相关的一系列特性而建立的模型。JMM定义了一些语法集，这些语法集映射到Java语言中就是volatile、synchronized等关键字。</p>
<p><a target="_blank" rel="noopener" href="http://www.hollischuang.com/wp-content/uploads/2018/06/11.png"><img src="C:%5CUsers%5CPowerwenwh%5CDocuments%5CMyBlog%5Csource%5C_posts%5Cimgs%5CJava%E5%9F%BA%E7%A1%80%5C11.png" alt="11"></a></p>
<p>在Java中，JMM是一个非常重要的概念，正是由于有了JMM，Java的并发编程才能避免很多问题。这里就不对Java内存模型做更加详细的介绍了，想了解更多的朋友可以参考《Java并发编程的艺术》。</p>
<h3 id="Java对象模型"><a href="#Java对象模型" class="headerlink" title="Java对象模型"></a>Java对象模型</h3><p>Java是一种面向对象的语言，而Java对象在JVM中的存储也是有一定的结构的。而这个关于Java对象自身的存储模型称之为Java对象模型。</p>
<p>HotSpot虚拟机中，设计了一个OOP-Klass Model。OOP（Ordinary Object Pointer）指的是普通对象指针，而Klass用来描述对象实例的具体类型。</p>
<p>每一个Java类，在被JVM加载的时候，JVM会给这个类创建一个<code>instanceKlass</code>，保存在方法区，用来在JVM层表示该Java类。当我们在Java代码中，使用new创建一个对象的时候，JVM会创建一个<code>instanceOopDesc</code>对象，这个对象中包含了对象头以及实例数据。</p>
<p><a target="_blank" rel="noopener" href="http://www.hollischuang.com/wp-content/uploads/2018/06/20170615230126453.jpeg"><img src="C:%5CUsers%5CPowerwenwh%5CDocuments%5CMyBlog%5Csource%5C_posts%5Cimgs%5CJava%E5%9F%BA%E7%A1%80%5C20170615230126453.jpeg" alt="20170615230126453"></a></p>
<p>这就是一个简单的Java对象的OOP-Klass模型，即Java对象模型。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>我们再来区分下JVM内存结构、 Java内存模型 以及 Java对象模型 三个概念。</p>
<p>JVM内存结构，和Java虚拟机的运行时区域有关。 Java内存模型，和Java的并发编程有关。 Java对象模型，和Java对象在虚拟机中的表现形式有关。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://wenwenhuan.gitee.io/2021/04/12/Java%E9%9B%86%E5%90%88%E5%B9%B6%E5%8F%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="温文焕">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wenhuan Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/04/12/Java%E9%9B%86%E5%90%88%E5%B9%B6%E5%8F%91/" class="post-title-link" itemprop="url">Java的集合并发常用知识点</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-04-12 23:11:00 / 修改时间：23:17:58" itemprop="dateCreated datePublished" datetime="2021-04-12T23:11:00+08:00">2021-04-12</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="java并发面试题"><a href="#java并发面试题" class="headerlink" title="java并发面试题"></a>java并发面试题</h2><p>什么是多线程环境下的伪共享(false sharing)？<br>答：在多核的CPU架构中，每个<strong>处理器都有自己的局部缓存</strong>，<strong>缓存系统是以缓存行为单位存储</strong>的，当多线程修改互相独立的变量时，如果这些变量共享同一个缓存行，就会无意中影响彼此的性能，这就是伪共享。</p>
<p>同步和异步有何异同？<br>答：同步就是事情必须一件一件的做，下一件事的开始必须在上一件事结束后。异步就是下一件事的开始无需等待上一件事的结束，两件事之间没有强关联。</p>
<p>调用start()方法时会执行run()方法，为什么不能直接调用run()方法？<br>答：调用start()方法时，JVM底层会帮我们生产新的线程，然后再通过这个线程来调用run()方法里的逻辑，而直接调用run()方法则不同，不会产生新线程，就是简简单单把run()方法当成普通方法运行。</p>
<p>stop()方法和 suspend()方法为何不推荐使用？<br>答: 首先两者都做到停止线程的效果，其中stop() 方法的停止很暴力，<strong>不安全</strong>，容易造成数据的不一致。而 suspend() 方法的停止很无赖，它<strong>不会释放锁</strong>，这就容易造成死锁了。</p>
<p>如何让正在运行的线程暂停一段时间？<br>答:使用sleep()方法或wait()方法。</p>
<p>线程状态，BLOCKD和WAITING有什么区别？<br>答:当线程无法进入同步方法或者同步代码块中时，线程状态就是BLOCKD，这个线程这时处于同步队列。当线程调用了wait，join等方法就会进入WAITING状态，这时线程处于等待队列。当处于等待队列的线程通过notify()，notifyAll()等方法被唤醒时，就会进入同步队列。</p>
<p>提交任务时，线程池队列已满时会发会生什么？<br>答:调用拒绝策略，可参考本篇博客【<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_38106322/article/details/104121861">简单了解线程池</a>】中的线程池工作流程图。</p>
<p>ThreadPoolExecutor.AbortPolicy:丢弃任务并抛出RejectedExecutionException异常。注：默认策略！！！！！！</p>
<p>ThreadPoolExecutor.DiscardPolicy：也是丢弃任务，但是不抛出异常。</p>
<p>ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）</p>
<p>ThreadPoolExecutor.CallerRunsPolicy：由调用线程处理该任务</p>
<p>线程池中submit() 和 execute()方法有什么区别？<br>答:两者都可以用于向线程池提交任务。不过<strong>submit()方法的返回值是Future类型，而execute()方法无返回值。</strong>submit()方法方便Exception处理。</p>
<p>说说什么是CountDownLatch？<br>答:可参考本篇博客【<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_38106322/article/details/103743113">CountDownLatch的简单应用和实现原理</a> 】。</p>
<p>说说什么是CyclicBarrier?<br>答:可参考本篇博客【<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_38106322/article/details/103830014">CyclicBarrier的简单使用</a>】。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://wenwenhuan.gitee.io/2021/04/12/Linux/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="温文焕">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wenhuan Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/04/12/Linux/" class="post-title-link" itemprop="url">Linux的一些基础知识点</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-04-12 23:11:00" itemprop="dateCreated datePublished" datetime="2021-04-12T23:11:00+08:00">2021-04-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2021-04-20 11:57:00" itemprop="dateModified" datetime="2021-04-20T11:57:00+08:00">2021-04-20</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="Linux查看内存使用情况"><a href="#Linux查看内存使用情况" class="headerlink" title="Linux查看内存使用情况"></a>Linux查看内存使用情况</h2><p>包括：free、top、cat /proc/meminfo、vmstat、ps</p>
<h3 id="1-top命令"><a href="#1-top命令" class="headerlink" title="1. top命令"></a>1. top命令</h3><img src="/2021/04/12/Linux/image-20210407204911221.png" class="" title="image-20210407204911221">

<p>内容分析：</p>
<p>   PID：进程的ID</p>
<p>   USER：进程所有者</p>
<p>​    PR：进程的优先级别，越小越优先被执行</p>
<p>​    NI：进程Nice值，代表这个进程的优先值</p>
<p>​    VIRT：进程占用的虚拟内存</p>
<p>​    RES：进程占用的物理内存</p>
<p>​    SHR：进程使用的共享内存</p>
<p>   S：进程的状态。S表示休眠，R表示正在运行，Z表示僵死状态</p>
<p>​    %CPU：进程占用CPU的使用</p>
<p>​    %MEM：进程使用的物理内存和总内存的百分</p>
<p>​    TIME+：该进程启动后占用的总的CPU时间，即占用CPU使用时间的累加值</p>
<p>​    COMMAND：启动该进程的命令名称</p>
<h3 id="2-free命令："><a href="#2-free命令：" class="headerlink" title="2. free命令："></a>2. free命令：</h3><p>输入命令分类：</p>
<p>free   用KB为单位展示数据</p>
<p>free -m   用MB为单位展示数据</p>
<p>free -h   用GB为单位展示数据</p>
<img src="/2021/04/12/Linux/image-20210407205121916.png" class="" title="image-20210407205121916">

<p>total : 总计物理内存的大小</p>
<p>used : 已使用内存的大小</p>
<p>free : 可用内存的大小</p>
<p>shared : 多个进程共享的内存总额</p>
<p>buff/cache : 磁盘缓存大小</p>
<p>available : 可用内存大小 ， 从应用程序的角度来说：available = free + buff/cache .</p>
<h3 id="3-cat-proc-meminfo-命令："><a href="#3-cat-proc-meminfo-命令：" class="headerlink" title="3. cat  /proc/meminfo 命令："></a>3. cat  /proc/meminfo 命令：</h3><img src="/2021/04/12/Linux/image-20210407205332503.png" class="" title="image-20210407205332503">

<p>这是用来查看RAM使用情况最简单的方法。 这个动态更新的虚拟文件实际上是许多其他内存相关工具的组合显示，就如上面说列的 top, free等。它列出了所有我们想了解的内存的使用情况。</p>
<p>进程的内存使用信息也可以通过： /proc//statm 和 /proc//status 来查看。</p>
<h3 id="4-ps-命令：用于显示当前进程的状态"><a href="#4-ps-命令：用于显示当前进程的状态" class="headerlink" title="4. ps 命令：用于显示当前进程的状态"></a>4. ps 命令：用于显示当前进程的状态</h3><p>输入内容方式：</p>
<p>ps aux ：按照 pid 显示内容 （默认排序方式）</p>
<p>ps aux –sort -rss : 按照 rss 排序显示内容</p>
<img src="/2021/04/12/Linux/image-20210407205451578.png" class="" title="image-20210407205451578">

<h3 id="5-vmstat-命令："><a href="#5-vmstat-命令：" class="headerlink" title="5. vmstat 命令："></a>5. vmstat 命令：</h3><p>输入命令：</p>
<p>vmstat -s</p>
<p>输出内容：</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">温文焕</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  





  





</body>
</html>
