[{"title":"算法相关","url":"/2021/05/12/算法相关/","content":"\n![排序算法的稳定性](算法相关/v2-0872ff222124611b3403a888be76c2b9_1440w.jpg)","tags":["操作系统、计网、算法、数据结构、数据库"]},{"title":"Java中的&与&&运算符","url":"/2021/05/08/Java中的-与-运算符/","content":"\n“&”和“&&”都可以用作逻辑与的运算符，表示逻辑与（and） ，当运算符两边的表达式的结果都为 true 时，整个运算结果才为 true，否则，只要有一方为 false，则结果为 false。\n\n“&&”还具有短路的功能，即如果第一个表达式为 false，则不再计算第二个表达式。eg:\n\n```java\nif(str != null&&!str.equals(\"\"))\n//表达式，当 str 为 null 时，后面的表达式不会执行，所以不会出现 NullPointerException 如果将&&改为&，则会抛出 NullPointerException 异常。\n```\n\n“&”还可以用作位运算符，当“&”操作符两边的表达式不是 boolean 类型时，“&”表示按位与操作，我们通常使用0x0f 来与一个整数进行&运算，来获取该整数的最低4个 bit 位。eg:`0x31 & 0x0f  = 0x01`\n\n<<    :   左移运算符，num << 1,相当于num乘以2\n\n\\>>    :   右移运算符，num >> 1,相当于num除以2\n\n\\>>>   :   无符号右移，忽略符号位，空位都以0补齐","tags":["Java"]},{"title":"数据库","url":"/2021/05/05/数据库/","content":"\n## 数据库范式\n\n一张数据表的表结构所符合的某种设计标准的级别。主要解决**数据冗余过大**、**插入异常**、**删除异常**、**修改异常**。\n\n### **第一范式（1NF）**\n\n**符合1NF的关系中的每个属性都不可再分。**\n\n### 第二范式\n\n**2NF在1NF的基础之上，消除了非主属性对于码的部分函数依赖**。\n\n### **第三范式（3NF）**\n\n**3NF在2NF的基础之上，消除了非主属性对于码的传递函数依赖**。\n\n## mysql数据库引擎\n\n### **==两种存储引擎的大致区别表现在==**\n\n最重要：两种类型最主要的差别就是**Innodb 支持 `事务` 处理与 `外键` 和 `行级锁`**\n\n- **InnoDB支持事务，MyISAM不支持**，这一点是非常之重要。事务是一种高级的处理方式，如在一些列增删改中只要哪个出错还可以回滚还原，而MyISAM就不可以了。\n- **MyISAM适合查询以及插入为主的应用**。\n- **InnoDB适合频繁修改以及涉及到安全性较高的应用**。\n- InnoDB支持外键，MyISAM不支持。\n- **从MySQL5.5.5以后，InnoDB是默认引擎**。\n- InnoDB不支持FULLTEXT（全文索引）类型的索引。\n- **InnoDB中不保存表的行数**，如`select count(*) from table`时，InnoDB需要扫描一遍整个表来计算有多少行，但是MyISAM只要简单的读出保存好的行数即可。注意的是，当count(*)语句包含where条件时MyISAM也需要扫描整个表。\n- 对于自增长的字段，InnoDB中必须包含只有该字段的索引，但是在MyISAM表中可以和其他字段一起建立联合索引。\n- `DELETE FROM table`时，**InnoDB不会重新建立表，而是一行一行的 删除，效率非常慢**。**MyISAM则会重建表**。\n- InnoDB支持行锁（某些情况下还是锁整表，如 `update table set a=1 where user like '%lee%'`。\n\n## 事务\n\n事务是逻辑上的一组操作，要么都执行，要么都不执行。（转账例子）\n\n### 事务的特性(ACID)\n\n1. **原子性：** 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；\n2. **一致性：** 执行事务前后，数据保持一致，例如转账业务中，无论事务是否成功，转账者和收款人的总额应该是不变的；\n3. **隔离性：** 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；\n4. **持久性：** 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。\n\n### 并发事务带来的问题\t\n\n**脏读（Dirty read）** ：只读一次，读取的是没提交的数据\n\n**不可重复读** ： **一个事务两次读取同一个数据，两次读取的数据不一致** ，读取两次，第一次读取的时候事务的**修改**还没提交，第二次读取的时候事务提交了。\n\n**幻读** ： **一个事务两次读取一个范围的记录，两次读取的记录数不一致** ，读取两次，第一次读取的时候事务的**添加或者删除**还没提交，第二次读取的时候事务提交了。\n\n**丢失修改（Lost to modify）:** 指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。 例如：事务1读取某表中的数据A=20，事务2也读取A=20，事务1修改A=A-1，事务2也修改A=A-1，最终结果A=19，事务1的修改被丢失。\n\n不可重复度和幻读区别：\n\n不可重复读的重点是修改，幻读的重点在于新增或者删除。\n\n## 数据库调优（SQL调优）\n\n数据库组成结构图\n\n![img](数据库/v2-9cd1e45ad32c2aa83725d57b3a956507_1440w.jpg)\n\n测试时排除缓存干扰：执行SQL的时候，加上SQL NoCache去跑SQL，这样跑出来的时间就是真实的查询时间了。\n\nhttps://sq.163yun.com/blog/article/183654375478206464\n\nhttps://blog.csdn.net/u010520146/article/details/81161762\n\n### 一.创建索引\n\n1.要尽量避免全表扫描，首先应考虑**在 where 及 order by 涉及的列上建立索引**\n2.(1)在经常需要进行检索的字段上创建索引，比如要按照表字段username进行检索，那么就应该在姓名字段上创建索引，如果经常要按照员工部门和员工岗位级别进行检索，那么就应该在员工部门和员工岗位级别这两个字段上创建索引。\n(2)创建索引给检索带来的性能提升往往是巨大的，因此在发现检索速度过慢的时候应该首先想到的就是创建索引。\n(3)一个表的索引数最好不要超过6个，若太多则应考虑一些不常使用到的列上建的索引是否有 必要。索引并不是越多越好，**索引固然可以提高相应的 select 的效率，但同时也降低了 insert 及 update 的效率**，因为 insert 或 update 时有可能会重建索引，所以怎样建索引需要慎重考虑，视具体情况而定。\n\n### 二.避免在索引上使用计算\n\n在where字句中，如果索引列是计算或者函数的一部分，DBMS的优化器将不会使用索引而使用全表查询,函数\n属于计算的一种,同时在in和exists中通常情况下使用EXISTS，因为in不走索引\n\n效率低：\n\n```\n select * from user where salary*22>11000(salary是索引列)\n```\n\n效率高：\n\n```\n select * from user where salary>11000/22(salary是索引列)\n```\n\n### 三.使用预编译查询\n\n程序中通常是根据用户的输入来动态执行SQL，这时应该尽量使用参数化SQL,这样不仅可以避免SQL注入漏洞\n攻击，最重要数据库会对这些参数化SQL进行预编译，这样第一次执行的时候DBMS会为这个SQL语句进行查询优化\n并且执行预编译，这样以后再执行这个SQL的时候就直接使用预编译的结果，这样可以大大提高执行的速度。\n\n#### 判断是否存在 Sql 注入漏洞：**单引号判断法**\n\n#### Sql 注入漏洞的类型：数字型、字符型\n\n#### 防止SQL注入：对用户输入的数据进行转义\n\n### 四.调整Where字句中的连接顺序\n\nDBMS一般采用自下而上的顺序解析where字句，根据这个原理表连接最好写在其他where条件之前，那些可以\n过滤掉最大数量记录。\n\n#### 五.尽量将多条SQL语句压缩到一句SQL中\n\n每次执行SQL的时候都要建立网络连接、进行权限校验、进行SQL语句的查询优化、发送执行结果，这个过程\n是非常耗时的，因此应该尽量避免过多的执行SQL语句，能够压缩到一句SQL执行的语句就不要用多条来执行。\n\n#### 六.用where字句替换HAVING字句\n\n避免使用HAVING字句，因为HAVING只会在检索出所有记录之后才对结果集进行过滤，而**where则是在聚合前**\n**刷选记录**，如果能通过where字句限制记录的数目，那就能减少这方面的开销。HAVING中的条件一般用于聚合函数\n的过滤，除此之外，应该将条件写在where字句中。\n\n#### 七.使用表的别名\n\n当在SQL语句中连接多个表时，请使用表的别名并把别名前缀于每个列名上。这样就可以减少解析的时间并减\n少哪些友列名歧义引起的语法错误。\n\n#### 八.用union all替换union\n\n当SQL语句需要union两个查询结果集合时，即使检索结果中不会有重复的记录，如果使用union这两个结果集\n同样会尝试进行合并，然后在输出最终结果前进行排序，因此如果可以判断检索结果中不会有重复的记录时候，应\n该用union all，这样效率就会因此得到提高\n\n#### 九.考虑使用“临时表”暂存中间结果\n\n简化SQL语句的重要方法就是采用临时表暂存中间结果，但是，临时表的好处远远不止这些，将临时结果暂存在临时表，后面的查询就在tempdb中了，这可以避免程序中多次扫描主表，也大大减少了程序执行中“共享锁”阻塞“更新锁”，减少了阻塞，提高了并发性能。\n但是也得避免频繁创建和删除临时表，以减少系统表资源的消耗。\n","tags":["操作系统、计网、算法、数据结构、数据库"]},{"title":"面试题整理","url":"/2021/04/26/面试题整理/","content":"\n手写一种单例模式","tags":["面试题"]},{"title":"青蛙跳台阶（动态规划）","url":"/2021/04/26/青蛙跳台阶/","content":"\n一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。\n\n答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。\n\n**此类求多少种可能性的题目一般都有递推性质 ，即 f(n)和 f(n-1)…f(1)之间是有联系的。**\n\n![image-20210426115331679](青蛙跳台阶/image-20210426115331679.png)\n\n![Picture13.png](青蛙跳台阶/108249e4d62d429f9cd6cab5bbd6afca581ee61c7d762a4c8ea0c62e08e10762-Picture13.png)\n\n![image-20210426115433377](青蛙跳台阶/image-20210426115433377.png)\n\n![image-20210426115534280](青蛙跳台阶/image-20210426115534280.png)\n\n```java\npublic class Solution {\n    public int numWays(int n) {\n        if (n == 0 || n == 1) {\n            return 1;\n        }\n        int[] dp = new int[n + 1];\n        dp[1] = 1;\n        dp[2] = 2;\n        for (int i = 3; i <= n; i++) {\n            dp[i] = (dp[i - 2] + dp[i - 1]) % 1000_000_007;\n        }\n        return dp[n];\n    }\n}\n```\n\n或者不借助数组\n\n```java\nclass Solution {\n    public int numWays(int n) {\n        int a = 1, b = 1, sum;\n        for(int i = 0; i < n; i++){\n            sum = (a + b) % 1000000007;\n            a = b;\n            b = sum;\n        }\n        return a;\n    }\n}\n```\n\n求余问题：\n\na+b的和求余等价于a求余和b求余的和再求余，在此题中，a与b都在上次循环中求余，所以可以直接写作\n\n` sum = (a + b) % 1000000007;`\n\n![image-20210426120026171](青蛙跳台阶/image-20210426120026171.png)","tags":["leetcode刷题"]},{"title":"多线程","url":"/2021/04/25/多线程/","content":"\n## 一个线程的生命周期\n\n线程是一个动态执行的过程，它也有一个从产生到死亡的过程。\n\n下图显示了一个线程完整的生命周期。\n\n![img](多线程/java-thread.jpg)\n\n- 新建状态:\n\n  使用 **new** 关键字和 **Thread** 类或其子类建立一个线程对象后，该线程对象就处于新建状态。它保持这个状态直到程序 **start()** 这个线程。\n\n- 就绪状态:\n\n  当线程对象调用了start()方法之后，该线程就进入就绪状态。就绪状态的线程处于就绪队列中，要等待JVM里线程调度器的调度。\n\n- 运行状态:\n\n  如果就绪状态的线程获取 CPU 资源，就可以执行 **run()**，此时线程便处于运行状态。处于运行状态的线程最为复杂，它可以变为阻塞状态、就绪状态和死亡状态。\n\n- 阻塞状态:\n\n  如果一个线程执行了sleep（睡眠）、suspend（挂起）等方法，失去所占用资源之后，该线程就从运行状态进入阻塞状态。在睡眠时间已到或获得设备资源后可以重新进入就绪状态。可以分为三种：\n\n  - 等待阻塞：运行状态中的线程执行 wait() 方法，使线程进入到等待阻塞状态。\n  - 同步阻塞：线程在获取 synchronized 同步锁失败(因为同步锁被其他线程占用)。\n  - 其他阻塞：通过调用线程的 sleep() 或 join() 发出了 I/O 请求时，线程就会进入到阻塞状态。当sleep() 状态超时，join() 等待线程终止或超时，或者 I/O 处理完毕，线程重新转入就绪状态。\n\n- 死亡状态:\n\n  一个运行状态的线程完成任务或者其他终止条件发生时，该线程就切换到终止状态。\n\n一个线程还可以等待另一个线程直到其运行结束。例如，`main`线程在启动`t`线程后，可以通过`t.join()`等待`t`线程结束后再继续运行。\n\n## 线程的优先级\n\n每一个 Java 线程都有一个优先级，这样有助于操作系统确定线程的调度顺序。\n\nJava 线程的优先级是一个整数，其取值范围是 1 （Thread.MIN_PRIORITY ） - 10 （Thread.MAX_PRIORITY ）。\n\n默认情况下，每一个线程都会分配一个优先级 NORM_PRIORITY（5）。\n\n具有较高优先级的线程对程序更重要，并且应该在低优先级的线程之前分配处理器资源。但是，线程优先级不能保证线程执行的顺序，而且非常依赖于平台。\n\n## Java多线程实现的三种方式\n\n1.继承Thread类，重写run方法\n\n2.实现Runnable接口，重写run方法，实现Runnable接口的实现类的实例对象作为Thread构造函数的target\n\n3.通过Callable和FutureTask创建线程\n\n4.通过线程池创建线程\n\n前面两种可以归结为一类：无返回值，原因很简单，通过重写run方法，run方式的返回值是void，所以没有办法返回结果\n\n后面两种可以归结成一类：有返回值，通过Callable接口，就要实现call方法，这个方法的返回值是Object，所以返回的结果可以放在Object对象中\n\n### 方式1：通过继承Thread来创建线程\n\n```java\npublic class ThreadDemo01 extends Thread{\n    public ThreadDemo01(){\n        //编写子类的构造方法，可缺省\n    }\n    public void run(){\n        //编写自己的线程代码\n        System.out.println(Thread.currentThread().getName());\n    }\n    public static void main(String[] args){ \n        ThreadDemo01 threadDemo01 = new ThreadDemo01(); \n        threadDemo01.setName(\"我是自定义的线程1\");\n        threadDemo01.start();       \n        System.out.println(Thread.currentThread().toString());  \n    }\n}\n```\n\n程序结果：\n\nThread[main,5,main]\n\n我是自定义的线程1\n\n**使用到的方法：**\n\n`setName`:改变线程名称，使之与参数 `name` 相同。\n\n`currentThread`:返回对当前正在执行的线程对象的引用。返回：当前执行的线程。\n\n### 方式2：通过实现 Runnable 接口来创建线程\n\n接口的实现类的实例作为Thread的target作为参数传入带参的Thread构造函数，通过调用start()方法启动线程\n\n```java\npublic class ThreadDemo02 {\n\n    public static void main(String[] args){ \n        System.out.println(Thread.currentThread().getName());\n        Thread t1 = new Thread(new MyThread());\n        t1.start(); \n    }\n}\n\nclass MyThread implements Runnable{\n    @Override\n    public void run() {\n        // TODO Auto-generated method stub\n        System.out.println(Thread.currentThread().getName()+\"-->我是通过实现接口的线程实现方式！\");\n    }   \n}\n```\n\n程序运行结果：\n\nmain\n\nThread-0–>我是通过实现接口的线程实现方式！\n\n### 方式3：通过 Callable 和 Future 创建线程\n\n- 1. 创建 Callable 接口的实现类，并实现 call() 方法，该 call() 方法将作为线程执行体，并且有返回值。\n- 2. 创建 Callable 实现类的实例，使用 FutureTask 类来包装 Callable 对象，该 FutureTask 对象封装了该 Callable 对象的 call() 方法的返回值。\n- 3. 使用 FutureTask 对象作为 Thread 对象的 target 创建并启动新线程。\n- 4. 调用 FutureTask 对象的 get() 方法来获得子线程执行结束后的返回值。\n\n```java\npublic class CallableThreadTest implements Callable<Integer> {\n    public static void main(String[] args)  \n    {  \n        CallableThreadTest ctt = new CallableThreadTest();  \n        FutureTask<Integer> ft = new FutureTask<>(ctt);  \n        for(int i = 0;i < 100;i++)  \n        {  \n            System.out.println(Thread.currentThread().getName()+\" 的循环变量i的值\"+i);  \n            if(i==20)  \n            {  \n                new Thread(ft,\"有返回值的线程\").start();  \n            }  \n        }  \n        try  \n        {  \n            System.out.println(\"子线程的返回值：\"+ft.get());  \n        } catch (InterruptedException e)  \n        {  \n            e.printStackTrace();  \n        } catch (ExecutionException e)  \n        {  \n            e.printStackTrace();  \n        }  \n  \n    }\n    @Override  \n    public Integer call() throws Exception  \n    {  \n        int i = 0;  \n        for(;i<100;i++)  \n        {  \n            System.out.println(Thread.currentThread().getName()+\" \"+i);  \n        }  \n        return i;  \n    }  \n}\n```\n\n#### 创建线程的三种方式的对比\n\n- 采用实现 Runnable、Callable 接口的方式创建多线程时，线程类只是实现了 Runnable 接口或 Callable 接口，还可以继承其他类。\n- 使用继承 Thread 类的方式创建多线程时，编写简单，如果需要访问当前线程，则无需使用 Thread.currentThread() 方法，直接使用 this 即可获得当前线程。\n\n## 中断线程\n\n中断一个线程非常简单，只需要在其他线程中对目标线程调用`interrupt()`方法，目标线程需要反复检测自身状态是否是interrupted状态，如果是，就立刻结束运行。\n\n## volatile关键字\n\n线程间共享变量需要使用`volatile`关键字标记，确保每个线程都能读取到更新后的变量值。\n\n## 守护线程\n\nJava程序入口就是由JVM启动`main`线程，`main`线程又可以启动其他线程。当所有线程都运行结束时，JVM退出，进程结束。\n\n如果有一个线程没有退出，JVM进程就不会退出。所以，必须保证所有线程都能及时结束。\n\n当遇到无限循环线程的时候，就需要守护线程负责结束该线程。\n\n守护线程是指为其他线程服务的线程。在JVM中，所有非守护线程都执行完毕后，无论有没有守护线程，虚拟机都会自动退出。\n\n因此，JVM退出时，不必关心守护线程是否已结束。\n\n### 创建守护线程\n\n方法和普通线程一样，只是在调用`start()`方法前，调用`setDaemon(true)`把该线程标记为守护线程：\n\n```java\nThread t = new MyThread();\nt.setDaemon(true);\nt.start();\n```\n\n在守护线程中，编写代码要注意：守护线程不能持有任何需要关闭的资源，例如打开文件等，因为虚拟机退出时，守护线程没有任何机会来关闭文件，这会导致数据丢失。\n\n所有非守护线程都执行完毕后，虚拟机退出。\n\n## 线程同步\n\n解决多个线程同时读写共享变量，会出现数据不一致的问题。\n\n对变量进行读取和写入时，结果要正确，必须保证是原子操作。原子操作是指不能被中断的一个或一系列操作。\n\n保证一组指令以原子方式执行：即某一个线程执行时，其他线程必须等待。\n\n保证一段代码的原子性就是通过加锁和解锁实现的。Java程序使用`synchronized`关键字对一个对象进行加锁：\n\n```java\nsynchronized(lock) {\n    n = n + 1;\n}\n```\n\n```java\nsynchronized(Counter.lock) { // 获取锁\n    ...\n} // 释放锁\n```\n\n表示用`Counter.lock`实例作为锁，两个线程在执行各自的`synchronized(Counter.lock) { ... }`代码块时，必须先获得锁，才能进入代码块进行。执行结束后，在`synchronized`语句块结束会自动释放锁。这样一来，对`Counter.count`变量进行读写就不可能同时进行。\n\n## 线程的几个主要概念\n\n在多线程编程时，需要了解以下几个概念：\n\n- 线程同步\n- 线程间通信\n- 线程死锁\n- 线程控制：挂起、停止和恢复\n\n## 多线程优缺点\n\nhttps://cloud.tencent.com/developer/article/1416283\n\n### 1. 多线程的优点\n\n- 无需跨进程边界；\n- 程序逻辑和控制方式简单；\n- 所有线程可以直接共享内存和变量等；\n- 线程方式消耗的总资源比进程方式好；\n\n### 2. 多线程缺点\n\n- 每个线程与主程序共用地址空间，受限于2GB地址空间；\n- 线程之间的同步和加锁控制比较麻烦；\n- 一个线程的崩溃可能影响到整个程序的稳定性；\n- 到达一定的线程数程度后，即使再增加CPU也无法提高性能，例如Windows Server 2003，大约是1500个左右的线程数就快到极限了（线程堆栈设定为1M），如果设定线程堆栈为2M，还达不到1500个线程总数；\n- 线程能够提高的总性能有限，而且线程多了之后，线程本身的调度也是一个麻烦事儿，需要消耗较多的CPU","tags":["操作系统、计网、算法、数据结构、数据库"]},{"title":"缓存","url":"/2021/04/24/缓存/","content":"\n## 什么是缓存\n\n所谓缓存，就是将程序或系统经常要调用的对象存在内存中，以便其使用时可以快速调用，不必再去创建新的重复的实例。这样做可以减少系统开销，提高系统效率。\n\n缓存主要可分为二大类:\n\n1：通过文件缓存,顾名思义文件缓存是指把数据存储在磁盘上，不管你是以XML格式，序列化文件DAT格式还是其它文件格式；\n\n2：内存缓存，也就是创建一个静态内存区域，将数据存储进去，例如我们B/S架构的将数据存储在Application中或者存储在一个静态Map中。\n\n## 实现本地缓存\n\n### 1.存储集合的选择\n\n实现本地缓存，存储容器肯定是 **key/value 形式的数据结构**，在 Java 中，也就是我们常用的 Map 集合。Map 中有 HashMap、Hashtable、ConcurrentHashMap 几种供我们选择，如果不考虑高并发情况下数据安全问题，我们可以选择HashMap，如果考虑高并发情况下数据安全问题，我们可以选择 Hashtable、ConcurrentHashMap 中的一种集合，但是我们优先选择 ConcurrentHashMap，因为 ConcurrentHashMap 的性能比 Hashtable 要好。\n\n### 2、过期缓存处理\n\n因为缓存直接存储在内存中，如果我们不处理过期缓存，内存将被大量无效缓存占用，这不是我们想要的，所以我们需要清理这些失效的缓存。过期缓存处理可以参考 Redis 的策略来实现，Redis 采用的是定期删除 + 懒惰淘汰策略。\n\n#### 定期删除策略\n\n定期删除策略是每隔一段时间检测已过期的缓存，并且将之删除。这个策略的优点是能够确保过期的缓存都会被删除。同时也存在着缺点，过期的缓存不一定能够及时的被删除，这跟我们设置的定时频率有关系，另一个缺点是如果缓存数据较多时，每次检测也会给 cup 带来不小的压力。\n\n#### 懒惰淘汰策略\n\n懒惰淘汰策略是在使用缓存时，先判断缓存是否过期，如果过期将它删除，并且返回空。这个策略的优点是只有在查找的时候，才判断是否过期，对 CUP 影响较小。同时这种策略有致命的缺点，当存入了大量的缓存，这些缓存都没有被使用并且已过期，都将成为无效缓存，这些无效的缓存将占用你大量的内存空间，最后导致服务器内存溢出。\n\n我们简单的了解了一下 Redis 的两种过期缓存处理策略，每种策略都存在自己的优缺点。所以我们在使用过程中，可以将两种策略组合起来，结合效果还是非常理想的。\n\n### 3、缓存淘汰策略\n\n缓存淘汰跟过期缓存处理要区别开来，缓存淘汰是指当我们的缓存个数达到我们指定的缓存个数时，毕竟我们的内存不是无限的。如果我们需要继续添加缓存的话，我们就需要在现有的缓存中根据某种策略淘汰一些缓存，给新添加的缓存腾出位置，下面一起来认识几种常用的缓存淘汰策略。\n\n#### 先进先出策略\n\n最先进入缓存的数据在缓存空间不够的情况下会被优先被清除掉，以腾出新的空间接受新的数据。该策略主要比较缓存元素的创建时间。在一些对数据实效性要求比较高的场景下，可考虑选择该类策略，优先保障最新数据可用。\n\n#### 最少使用策略\n\n无论是否过期，根据元素的被使用次数判断，清除使用次数较少的元素释放空间。该策略主要比较元素的hitCount（命中次数），在保证高频数据有效性场景下，可选择这类策略。\n\n#### 最近最少使用策略\n\n无论是否过期，根据元素最后一次被使用的时间戳，清除最远使用时间戳的元素释放空间。该策略主要比较缓存最近一次被get使用时间。在热点数据场景下较适用，优先保证热点数据的有效性。\n\n#### 随机淘汰策略\n\n无论是否过期，随机淘汰某个缓存，如果对缓存数据没有任何要求，可以考虑使用该策略。\n\n#### 不淘汰策略\n\n当缓存达到指定值之后，不淘汰任何缓存，而是不能新增缓存，直到有缓存淘汰时，才能继续添加缓存。\n\n上面是实现本地缓存需要考虑的三个点，看完我们应该知该如何实现一个本地缓存了，不妨我们一起来实现一个本地缓存。\n\n### 实现本地缓存\n\n在该 Demo 中，我们采用 ConcurrentHashMap 作为存储集合，这样即使在高并发的情况下，我们也能够保证缓存的安全。过期缓存处理在这里我只使用了定时删除策略，并没有使用定时删除 + 懒惰淘汰策略，你可以自己动手尝试一下使用这两种策略进行过期缓存处理。在缓存淘汰方面，我在这里采用了最少使用策略。好了，技术选型都知道了，我们一起来看看代码实现。","tags":["操作系统、计网、算法、数据结构、数据库"]},{"title":"股票的最大利润","url":"/2021/04/17/股票的最大利润/","content":"\n假设把某股票的价格按照时间先后顺序存储在数组中，请问买卖该股票一次可能获得的最大利润是多少？\n\n### 审题\n\n关键的两个限制是“最大”利润和买卖股票的时间顺序。\n\n这两个限制表明，题目不是简单寻找数组中的最大最小值，而是要比较多种情况。\n\n###  自己的方法--暴力\n\n思路：两个for循环，把每一种情况都计算出来，不断刷新最大的利润值。\n\n```java\npublic int maxProfit(int[] prices) {\n    int res = 0;\n    for (int i = 0; i < prices.length; i++) {\n        for (int j = i+1; j < prices.length; j++) {\n            int profit = prices[j] - prices[i];\n            if (profit>res){\n                res = profit;\n            }\n        }\n    }\n    return res;\n}\n```\n\n#### 复杂度分析\n\n时间复杂度：O(n^2)，循环运行 [n(n-1)]/2次。\n\n空间复杂度：O(1)。只使用了常数个变量。\n\n### 动态规划解题\n\n思路：分析四要素\n\n![image-20210417110436812](股票的最大利润/image-20210417110436812.png)\n\n难点是转移方程的分析\n\n#### 效率优化：\n\n![image-20210417110556220](股票的最大利润/image-20210417110556220.png)\n\n时间复杂度降低较容易，相较于每次都要遍历一遍子数组寻找最低价格，借助变量保存并实时更新显然更合理。\n\n空间复杂度的降低很巧妙，也是动态规划的核心，本来状态方程中最难解决的就是`dp[i]`是与`dp[i-1]`相关的，很像递归，在实现上很难处理，答案使用了和时间复杂度降低相似的做法，借助变量记录`dp[i-1]`.\n\n```java\npublic int maxProfit(int[] prices) {\n    int profit = 0,cost = Integer.MAX_VALUE;\n    for (int i = 0; i < prices.length; i++) {\n        //更新最小的prices\n        if (prices[i]<cost) cost = prices[i];\n        profit = Math.max(profit, prices[i]-cost);\n    }\n    return profit;\n}\n```\n\n\n\n#### 复杂度分析：\n\n![image-20210417110618502](股票的最大利润/image-20210417110618502.png)","tags":["leetcode"]},{"title":"外伶仃岛攻略","url":"/2021/04/16/wldd/","content":"\n### 出行方式：地铁+高铁+打车+船\n\n**去程**\n\n+ 家→广州南：地铁，一小时，九点出门\n\n+ 广州南→珠海站：高铁65/人,一小时左右，10:25-11:24或10:57-11:53（这趟有点太赶）\n\n+ 珠海站→香洲港：打车28左右，半个小时左右\n\n+ 香洲港→外伶仃岛：坐船120/人，一个半小时左右,12:40-13:50，提前半个小时排队取票\n\n**回程**\n\n+ 外伶仃岛→香洲港：17：15→18:25\n+ 香洲港→珠海站：18:30-19:00\n+ 珠海站→广州南：19:20-20:29\n\n船票+高铁票往返=370￥\n\n### 住宿\n\n聆海居榻榻米海景客栈，双床房，185/晚\n\n距离码头走路6-7分钟\n\n**参考地图**\n\n![image-20210416193536381](wldd/map.png)\n\n### 游玩\n\n岛内交通包括骑车和走路\n![39538248fe8c99575d55fd13bbe16ba](wldd/骑车.png)\n\n**1.矿石湖**\n\n走路1-1.5小时\n\n![41bd865bf60abdfb260c8b23469958a](wldd/矿石湖1.jpg)\n![46ad7e878a8de0100135420a2af1d1e](wldd/矿石湖2.png)\n2.**看日出**\n\n参考路线\n\n去山顶可能四点就要起床了\n\n![1bcfa63e2a23a812b4850428c94937a](wldd/sun.jpg)\n\n### 饮食\n\n外伶仃岛特色小吃：海胆、狗爪螺和将军帽\n\n![acba6652fd072abc0b207235c0e43d7](wldd/饮食2.png)\n\n![image-20210416193716389](wldd/饮食.png)","tags":["其他"]},{"title":"字节流和字符流","url":"/2021/04/15/字节流和字符流/","content":"\n## [一]写在前面\n\n简单总结一下分别用(一直混淆的)字节流or字符流读写文件。\n\n## [二]字节流\n\n2.1 字节流介绍\n\n程序中的输入输出都是以`流`的形式保存的(输入流or输出流),流中保存的实际上全都是`字节`(一个字节等于一个Byte占8个bit)文件。Java提供了OutputStream、InputStream两个专门操作字节流的类。\n\n> 知识补充1：\n> 计算机能存储的唯一东西就是 bytes,为了在计算机中存储东西,我们首先得将其编码(encode),例如将其转化为 bytes。\n> 比如：要想保存音乐(以字节形式保存),我们首先得用 MP3, WAV 等将其编码；要想保存图片,我们首先得用 PNG, JPEG 等将其编码；要想保存文本,我们首先得用 ASCII, UTF-8 等将其编码.\n> 知识补充2:\n> Unicode 是字符集,不是字符编码。Unicode 把全世界的字符都搜集并且编号了,但是没有规定具体的编码规则。编码规则有 UTF-8、GBK等。\n\n2.2 字节流使用场景总结\n\n**字节流适合`所有类型文件`的数据传输,因为字节(Byte)是电脑中表示信息含义的最小单位**(通常情况下一个ACSII码就是一个字节的空间来存放)。\n\n如果是`音频文件、图片、歌曲`，就用`字节流`好,**如果是关系到`中文(文本)`的,用`字符流`好**。\n\n## [三]字符流\n\n3.1 字符流介绍\n\n字符流**按字符(一个字符占两个字节)读数据**：一次读两个字节，返回了这两个字节所对应的字符的int型数值(编码)。写入文件时把这两个字节的内容`解码`成这个字符在Unicode码下对应的二进制数据写入。即把原始文件中的二进制数据以字符形式读出,再将字符以二进制形式写入,所以得到的文件以字符方式存储。**字符流只能处理字符或者字符串。**\n\n3.2 字符流使用场景\n\n字符流只能够处理纯文本(中文)数据，其他类型数据不行，但是字符流处理文本要比字节流处理文本要方便。\n\n## [四]字节流与字符流区别\n\n1.**字节流没有使用到缓冲区(内存),是与文件本身直接操作的。字符流使用到了缓冲区**,在缓冲区的数据需要使用close()或者flush()方法强制刷新缓冲区将其输出(程序没有关闭数据是不会从缓冲区输出出来的)。\n\n2.**字节流在操作文件时,即使不关闭资源(close方法),文件也能输出,但是如果字符流不使用close方法的话,则不会输出任何内容**。\n\n3.在所有的`硬盘`上保存文件或进行传输的时候都是以`字节`的方法进行的,包括图片也是按字节完成,而`字符`是只有在`内存`中才会形成的,所以`使用字节`的操作是`最多`的。\n\n4.**字节流提供了处理任何类型的IO操作的功能,但它不能直接处理Unicode字符,而字符流就可以。**\n\n5.字节流按字节读数据,而字节不需要编码、解码,**只有字节与字符之间转换时才需要编码、解码**！","tags":["其他"]},{"title":"Java中布尔类型运算符的使用","url":"/2021/04/15/java数据的存储/","content":"\n# java数据的存储\n\n弄清楚Java中数据的存储方式很重要，由int和Integer的存储区别引起的思考。\n\n## 1.0内存中的堆(stack)与栈(heap)\n\nJava程序运行时有6个地方可以存储数据，它们分别是寄存器、栈、堆、静态存储、常量存储和非RAM存储，主要是堆与栈的存储。\n\n> 栈与堆都是Java用来在RAM中存放数据的地方。与C++不同，**Java自动管理栈和堆，程序员不能直接地设置栈或堆。**栈的优势是，存取速度比堆要快，仅次于直接位于CPU中的寄存器。另外，栈数据可以共享。但缺点是，存在栈中的数据大小与生存期必须是确定的，缺乏灵活性。堆的优势是可以动态地分配内存大小，生存期也不必事先告诉编译器，Java的垃圾收集器会自动收走这些不再使用的数据。但缺点是，由于要在运行时动态分配内存，存取速度较慢。\n\n1. 栈存储速度快，数据可以共享，但缺乏灵活性。\n2. 堆可以动态分配内存大小，但速度慢。\n\n## 2.0 Java中数据在内存中的存储\n\n### 2.1基本数据类型的存储\n\n> Java的基本数据类型共有8种，即int, short, long, byte, float, double, boolean, char(不包括string)。通过如int a = 3的形式来定义，称为**自动变量**。值得注意的是：自动变量**存的是字面值，不是类的实例**，即**不是类的引用**，这里并没有类的存在。如int a = 3；这里的**a是一个指向int类型的引用，指向3这个字面值**。这些字面值的数据，由于**大小可知，生存期可知**(这些字面值固定定义在某个程序块里面，程序块退出后，字段值就消失了)，出于追求速度的原因，就存在于栈中。\n> 另外，栈有一个很重要的特殊性，就是存在栈中的数据可以共享。   假设我们同时定义：\n>  <u>int a = 3；   int b=3\n>  编译器先处理int a = 3；首先它会在栈中创建一个变量为a的引用，然后查找有没有字面值为3的地址，没找到，就开辟一个存放3这个字面值的地址，然后将a指向3的地址。接着处理int b = 3；在创建完b这个引用变量后，由于在栈中已经有3这个字面值，便将b直接指向3的地址。这样，就出现了a与b同时均指向3的情况</u>。【上文提到了\"引用+数值+内存地址\"这三个名词,其中变量名就是引用，给变量赋的值就是数值，而所提到的内存是抽象的内容，让引用指向的不是数值，而是存取数值的那块内存地址】\n\n> 定义完a与b的值后，再令a = 4；那么，b不会等于4，还是等于3。在编译器内部，遇到时，它就<u>会重新搜索栈中是否有4的字面值，如果没有，重新开辟地址存放4的值</u>；如果已经有了，则直接将a指向这个地址。因此a值的改变不会影响到b的值。\n\n### 2.2对象的内存模型\n\n在Java中，创建一个对象包括对象的声明和实例化两步，下面用一个例题来说明对象的内存模型。\n 假设有类Rectangle定义如下：   【Rectangle：矩形】\n\n```java\n  class Rectangle{\n  \tdouble width,height；\n  \tRectangle(double w,double h){\n \t\t width=w；height=h； \n    }\n  }\n```\n\n#### (1)声明对象时的内存模型\n\n用Rectangle rect声明一个对象rect时，将在栈内存为对象的引用变量rect分配内存空间，但Rectangle的值为空，称rect是一个空对象。空对象不能使用，因为它还没有引用任何“实体”。\n\n#### (2)对象实例化时的内存模型\n\n当执行rect=new Rectangle(3,5)；时，会做两件事：\n在堆内存中为类的成员变量width,height分配内存，并将其初始化为各数据类型的默认值；接着进行显式初始化（类定义时的初始化值）；最后调用构造方法，为成员变量赋值。\n 返回堆内存中对象的引用（相当于首地址）给引用变量rect,以后就可以通过rect来引用堆内存中的对象了。\n\n####  (3)创建多个不同的对象实例\n\n 一个类通过使用new运算符可以创建多个不同的对象实例，这些对象实例将在堆中被分配不同的内存空间，改变其中一个对象的状态不会影响其他对象的状态。例如：\n Rectangle r1=new Rectangle(3,5)；\n Rectangle r2=new Rectangle(4,6)；\n 此时，将在堆内存中分别为两个对象的成员变量width、height分配内存空间，两个对象在堆内存中占据的空间是互不相同的。如果有\n Rectangle r1=new Rectangle(3,5)；\n Rectangle r2=r1；\n 则在堆内存中只创建了一个对象实例，在栈内存中创建了两个对象引用，两个对象引用同时指向一个对象实例。\n3.3包装类数据的存储\n基本型别都有对应的包装类：如int对应Integer类，double对应Double类等，基本类型的定义都是直接在栈中，如果用包装类来创建对象，就和普通对象一样了。例如：int i=0；i直接存储在栈中。  Integeri（i此时是对象）= new Integer(5)；这样，i对象数据存储在堆中，i的引用存储在栈中，通过栈中的引用来操作对象。【数据存储在堆中，引用存储在栈中】","tags":["Java"]},{"title":"Java的集合并发常用知识点","url":"/2021/04/12/Java集合并发/","content":"\n## java并发面试题\n\n什么是多线程环境下的伪共享(false sharing)？\n答：在多核的CPU架构中，每个**处理器都有自己的局部缓存**，**缓存系统是以缓存行为单位存储**的，当多线程修改互相独立的变量时，如果这些变量共享同一个缓存行，就会无意中影响彼此的性能，这就是伪共享。\n\n同步和异步有何异同？\n答：同步就是事情必须一件一件的做，下一件事的开始必须在上一件事结束后。异步就是下一件事的开始无需等待上一件事的结束，两件事之间没有强关联。\n\n调用start()方法时会执行run()方法，为什么不能直接调用run()方法？\n答：调用start()方法时，JVM底层会帮我们生产新的线程，然后再通过这个线程来调用run()方法里的逻辑，而直接调用run()方法则不同，不会产生新线程，就是简简单单把run()方法当成普通方法运行。\n\nstop()方法和 suspend()方法为何不推荐使用？\n答: 首先两者都做到停止线程的效果，其中stop() 方法的停止很暴力，**不安全**，容易造成数据的不一致。而 suspend() 方法的停止很无赖，它**不会释放锁**，这就容易造成死锁了。\n\n如何让正在运行的线程暂停一段时间？\n答:使用sleep()方法或wait()方法。\n\n线程状态，BLOCKD和WAITING有什么区别？\n答:当线程无法进入同步方法或者同步代码块中时，线程状态就是BLOCKD，这个线程这时处于同步队列。当线程调用了wait，join等方法就会进入WAITING状态，这时线程处于等待队列。当处于等待队列的线程通过notify()，notifyAll()等方法被唤醒时，就会进入同步队列。\n\n提交任务时，线程池队列已满时会发会生什么？\n答:调用拒绝策略，可参考本篇博客【[简单了解线程池](https://blog.csdn.net/weixin_38106322/article/details/104121861)】中的线程池工作流程图。\n\nThreadPoolExecutor.AbortPolicy:丢弃任务并抛出RejectedExecutionException异常。注：默认策略！！！！！！\n\nThreadPoolExecutor.DiscardPolicy：也是丢弃任务，但是不抛出异常。\n\nThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）\n\nThreadPoolExecutor.CallerRunsPolicy：由调用线程处理该任务\n\n\n线程池中submit() 和 execute()方法有什么区别？\n答:两者都可以用于向线程池提交任务。不过**submit()方法的返回值是Future类型，而execute()方法无返回值。**submit()方法方便Exception处理。\n\n说说什么是CountDownLatch？\n答:可参考本篇博客【[CountDownLatch的简单应用和实现原理](https://blog.csdn.net/weixin_38106322/article/details/103743113) 】。\n\n说说什么是CyclicBarrier?\n答:可参考本篇博客【[CyclicBarrier的简单使用](https://blog.csdn.net/weixin_38106322/article/details/103830014)】。\n\n","tags":["Java"]},{"title":"Linux的一些基础知识点","url":"/2021/04/12/Linux/","content":"\n## Linux查看内存使用情况\n\n包括：free、top、cat /proc/meminfo、vmstat、ps\n\n### 1. top命令\n\n![image-20210407204911221](Linux/image-20210407204911221.png)\n\n内容分析：\n\n   PID：进程的ID\n\n   USER：进程所有者\n\n​    PR：进程的优先级别，越小越优先被执行\n\n​    NI：进程Nice值，代表这个进程的优先值\n\n​    VIRT：进程占用的虚拟内存\n\n​    RES：进程占用的物理内存\n\n​    SHR：进程使用的共享内存\n\n   S：进程的状态。S表示休眠，R表示正在运行，Z表示僵死状态\n\n​    %CPU：进程占用CPU的使用\n\n​    %MEM：进程使用的物理内存和总内存的百分\n\n​    TIME+：该进程启动后占用的总的CPU时间，即占用CPU使用时间的累加值\n\n​    COMMAND：启动该进程的命令名称\n\n### 2. free命令：\n\n输入命令分类：\n\nfree   用KB为单位展示数据\n\nfree -m   用MB为单位展示数据\n\nfree -h   用GB为单位展示数据\n\n![image-20210407205121916](Linux/image-20210407205121916.png)\n\ntotal : 总计物理内存的大小\n\nused : 已使用内存的大小\n\nfree : 可用内存的大小\n\nshared : 多个进程共享的内存总额\n\nbuff/cache : 磁盘缓存大小\n\navailable : 可用内存大小 ， 从应用程序的角度来说：available = free + buff/cache .\n\n### 3. cat  /proc/meminfo 命令：\n\n![image-20210407205332503](Linux/image-20210407205332503.png)\n\n这是用来查看RAM使用情况最简单的方法。 这个动态更新的虚拟文件实际上是许多其他内存相关工具的组合显示，就如上面说列的 top, free等。它列出了所有我们想了解的内存的使用情况。\n\n进程的内存使用信息也可以通过： /proc//statm 和 /proc//status 来查看。\n\n### 4. ps 命令：用于显示当前进程的状态\n\n输入内容方式：\n\nps aux ：按照 pid 显示内容 （默认排序方式）\n\nps aux --sort -rss : 按照 rss 排序显示内容\n\n![image-20210407205451578](Linux/image-20210407205451578.png)\n\n### 5. vmstat 命令：\n\n输入命令：\n\nvmstat -s\n\n输出内容：","tags":["Linux"]},{"title":"操作系统常用知识点","url":"/2021/04/12/OS/","content":"\n## 进程\n\n### 进程和线程是什么的最新答法\n\n进程：指在系统中正在运行的一个应用程序；程序一旦运行就是进程；进程——资源分配的最小单位。\n\n线程：系统分配处理器时间资源的基本单元，或者说进程之内独立执行的一个单元执行流。线程——程序执行的最小单位。\n\n### 进程基本介绍\n\n进程是程序执行时的一个实例，**是系统进行资源分配的基本单位**。所有与该进程有关的资源，都被记录在进程控制块(PCB)中。以表示该进程拥有这些资源或正在使用它们。另外，进程也是抢占处理机的调度单位，它拥有一个完整的虚拟地址空间。当进程发生调度时，**不同的进程拥有不同的虚拟地址空间**，而同一进程内的不同线程共享同一地址空间。\n\n**程序运行时系统就会创建一个进程，并为它分配资源，然后把该进程放入进程就绪队列**，进程调度器选中它的时候就会为它分配CPU时间，程序开始真正运行。\n\n#### 记不住就这怎么答：\n\n> 进程是**是系统进行资源分配的基本单位**，**进程拥有自己的虚拟地址空间**，**程序运行时系统就会创建一个进程，并为它分配资源，然后把该进程放入进程就绪队列**。\n\n### 线程基本介绍\n\n线程，有时也被称为轻量级进程，是程序执行流的最小单元，是进程中的一个实体，**是被系统独立调度和分派的基本单位**。与进程不同，线程与资源分配无关，线程自己不拥有系统资源，它属于某一个进程，并与进程内的其他线程一起共享进程的资源。线程只由相关堆栈（系统栈或用户栈）寄存器和线程控制表TCB组成。\n\n**它是进程的一个执行流**，\n\n#### 记不住就这怎么答：\n\n> **线程是进程的一个执行流**，**是CPU调度和分派的基本单位**，**线程间共享进程的所有资源**。\n\n### 进程与线程的区别\n\n地址空间：线程共享本进程的地址空间，而进程之间是独立的地址空间。\n\n切换：\n\nhttps://www.cnblogs.com/coder-programming/p/10595804.html\n\n根本区别：进程是操作系统资源分配的基本单位，而线程是任务调度和执行的基本单位\n\n在**开销**方面：每个进程都有独立的代码和数据空间（程序上下文），程序之间的切换会有较大的开销；线程可以看做轻量级的进程，同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器（PC），线程之间切换的开销小。\n\n**所处环境**：在操作系统中能同时运行多个进程（程序）；而在同一个进程（程序）中有多个线程同时执行（通过CPU调度，在每个时间片中只有一个线程执行）\n\n**内存分配方面**：系统在运行的时候会为每个进程分配不同的内存空间；而对线程而言，除了CPU外，系统不会为线程分配内存（线程所使用的资源来自其所属进程的资源），线程组之间只能共享资源。\n\n包含关系：没有线程的进程可以看做是单线程的，如果一个进程内有多个线程，则执行过程不是一条线的，而是多条线（线程）共同完成的；线程是进程的一部分，所以线程也被称为轻权进程或者轻量级进程。\n\n### 进程的五种基本状态 \n\n![image-20210415081219424](OS/image-20210415081219424.png)\n\n+ 创建状态：进程在创建时需要申请一个空白PCB，向其中填写控制和管理进程的信息，完成资源分配。如果创建工作无法完成，比如资源无法满足，就无法被调度运行，把此时进程所处状态称为创建状态\n+ 就绪状态：进程已经准备好，已分配到所需资源，只要分配到CPU就能够立即运行\n+ 执行状态：进程处于就绪状态被调度后，进程进入执行状态\n+ 阻塞状态：正在执行的进程由于某些事件（I/O请求，申请缓存区失败）而暂时无法运行，进程受到阻塞。在满足请求时进入就绪状态等待系统调用\n+ 终止状态：进程结束，或出现错误，或被系统终止，进入终止状态。无法再执行\n\n### 进程间通信\n\nhttps://blog.csdn.net/gatieme/article/details/50908749\n\n1. 管道（pipe）,流管道(s_pipe)和有名管道（FIFO）\n2. 信号（signal）\n3. 消息队列\n4. 共享内存\n5. 信号量\n6. 套接字（socket)\n\n## 计算机内存模型\n\n## 为什么要有内存模型\n\n在介绍Java内存模型之前，先来看一下到底什么是计算机内存模型，然后再来看Java内存模型在计算机内存模型的基础上做了哪些事情。要说计算机的内存模型，就要说一下一段古老的历史，看一下为什么要有内存模型。\n\n**内存模型，英文名Memory Model，他是一个很老的老古董了。他是与计算机硬件有关的一个概念。那么我先给你介绍下他和硬件到底有啥关系。**\n\n### CPU和缓存一致性\n\n我们应该都知道，计算机在执行程序的时候，每条指令都是在CPU中执行的，而执行的时候，又免不了要和数据打交道。而计算机上面的数据，是存放在主存当中的，也就是计算机的物理内存啦。\n\n刚开始，还相安无事的，但是随着CPU技术的发展，CPU的执行速度越来越快。而由于内存的技术并没有太大的变化，所以从内存中读取和写入数据的过程和CPU的执行速度比起来差距就会越来越大,这就导致CPU每次操作内存都要耗费很多等待时间。\n\n> 这就像一家创业公司，刚开始，创始人和员工之间工作关系其乐融融，但是随着创始人的能力和野心越来越大，逐渐和员工之间出现了差距，普通员工原来越跟不上CEO的脚步。老板的每一个命令，传到到基层员工之后，由于基层员工的理解能力、执行能力的欠缺，就会耗费很多时间。这也就无形中拖慢了整家公司的工作效率。\n\n可是，不能因为内存的读写速度慢，就不发展CPU技术了吧，总不能让内存成为计算机处理的瓶颈吧。\n\n所以，人们想出来了一个好的办法，就是在CPU和内存之间增加高速缓存。缓存的概念大家都知道，就是保存一份数据拷贝。他的特点是速度快，内存小，并且昂贵。\n\n那么，程序的执行过程就变成了：\n\n**当程序在运行过程中，会将运算需要的数据从主存复制一份到CPU的高速缓存当中，那么CPU进行计算时就可以直接从它的高速缓存读取数据和向其中写入数据，当运算结束之后，再将高速缓存中的数据刷新到主存当中。**\n\n> 之后，这家公司开始设立中层管理人员，管理人员直接归CEO领导，领导有什么指示，直接告诉管理人员，然后就可以去做自己的事情了。管理人员负责去协调底层员工的工作。因为管理人员是了解手下的人员以及自己负责的事情的。所以，大多数时候，公司的各种决策，通知等，CEO只要和管理人员之间沟通就够了。\n\n而随着CPU能力的不断提升，一层缓存就慢慢的无法满足要求了，就逐渐的衍生出多级缓存。\n\n按照数据读取顺序和与CPU结合的紧密程度，CPU缓存可以分为一级缓存（L1），二级缓存（L3），部分高端CPU还具有三级缓存（L3），每一级缓存中所储存的全部数据都是下一级缓存的一部分。\n\n这三种缓存的技术难度和制造成本是相对递减的，所以其容量也是相对递增的。\n\n那么，在有了多级缓存之后，程序的执行就变成了：\n\n**当CPU要读取一个数据时，首先从一级缓存中查找，如果没有找到再从二级缓存中查找，如果还是没有就从三级缓存或内存中查找。**\n\n> 随着公司越来越大，老板要管的事情越来越多，公司的管理部门开始改革，开始出现高层，中层，底层等管理者。一级一级之间逐层管理。\n\n单核CPU只含有一套L1，L2，L3缓存；如果CPU含有多个核心，即多核CPU，则每个核心都含有一套L1（甚至和L2）缓存，而共享L3（或者和L2）缓存。\n\n> 公司也分很多种，有些公司只有一个大Boss，他一个人说了算。但是有些公司有比如联席总经理、合伙人等机制。\n>\n> 单核CPU就像一家公司只有一个老板，所有命令都来自于他，那么就只需要一套管理班底就够了。\n>\n> 多核CPU就像一家公司是由多个合伙人共同创办的，那么，就需要给每个合伙人都设立一套供自己直接领导的高层管理人员，多个合伙人共享使用的是公司的底层员工。\n>\n> 还有的公司，不断壮大，开始差分出各个子公司。各个子公司就是多个CPU了，互相之前没有共用的资源。互不影响。\n\n下图为一个单CPU双核的缓存结构。\n\n![image-20210415081321290](OS/image-20210415081321290.png)\n\n随着计算机能力不断提升，开始支持多线程。那么问题就来了。我们分别来分析下单线程、多线程在单核CPU、多核CPU中的影响。\n\n**单线程。**cpu核心的缓存只被一个线程访问。缓存独占，不会出现访问冲突等问题。\n\n**单核CPU，多线程。**进程中的多个线程会同时访问进程中的共享数据，CPU将某块内存加载到缓存后，不同线程在访问相同的物理地址的时候，都会映射到相同的缓存位置，这样即使发生线程的切换，缓存仍然不会失效。但由于任何时刻只能有一个线程在执行，因此不会出现缓存访问冲突。\n\n**多核CPU，多线程。**每个核都至少有一个L1 缓存。多个线程访问进程中的某个共享内存，且这多个线程分别在不同的核心上执行，则每个核心都会在各自的caehe中保留一份共享内存的缓冲。由于多核是可以并行的，可能会出现多个线程同时写各自的缓存的情况，而各自的cache之间的数据就有可能不同。\n\n在CPU和主存之间增加缓存，在多线程场景下就可能存在**缓存一致性问题**，也就是说，在多核CPU中，每个核的自己的缓存中，关于同一个数据的缓存内容可能不一致。\n\n> 如果这家公司的命令都是串行下发的话，那么就没有任何问题。\n>\n> 如果这家公司的命令都是并行下发的话，并且这些命令都是由同一个CEO下发的，这种机制是也没有什么问题。因为他的命令执行者只有一套管理体系。\n>\n> 如果这家公司的命令都是并行下发的话，并且这些命令是由多个合伙人下发的，这就有问题了。因为每个合伙人只会把命令下达给自己直属的管理人员，而多个管理人员管理的底层员工可能是公用的。\n>\n> 比如，合伙人1要辞退员工a，合伙人2要给员工a升职，升职后的话他再被辞退需要多个合伙人开会决议。两个合伙人分别把命令下发给了自己的管理人员。合伙人1命令下达后，管理人员a在辞退了员工后，他就知道这个员工被开除了。而合伙人2的管理人员2这时候在没得到消息之前，还认为员工a是在职的，他就欣然的接收了合伙人给他的升职a的命令。\n\n![image-20210415081258412](OS/image-20210415081258412.png)\n\n### 处理器优化和指令重排\n\n上面提到在在CPU和主存之间增加缓存，在多线程场景下会存在**缓存一致性问题**。除了这种情况，还有一种硬件问题也比较重要。那就是为了使处理器内部的运算单元能够尽量的被充分利用，处理器可能会对输入代码进行乱序执行处理。这就是**处理器优化**。\n\n除了现在很多流行的处理器会对代码进行优化乱序处理，很多编程语言的编译器也会有类似的优化，比如Java虚拟机的即时编译器（JIT）也会做**指令重排**。\n\n可想而知，如果任由处理器优化和编译器对指令重排的话，就可能导致各种各样的问题。\n\n> 关于员工组织调整的情况，如果允许人事部在接到多个命令后进行随意拆分乱序执行或者重排的话，那么对于这个员工以及这家公司的影响是非常大的。\n\n## 并发编程的问题\n\n前面说的和硬件有关的概念你可能听得有点蒙，还不知道他到底和软件有啥关系。但是关于并发编程的问题你应该有所了解，比如原子性问题，可见性问题和有序性问题。\n\n其实，原子性问题，可见性问题和有序性问题。是人们抽象定义出来的。而这个抽象的底层问题就是前面提到的缓存一致性问题、处理器优化问题和指令重排问题等。\n\n这里简单回顾下这三个问题，并不准备深入展开，感兴趣的读者可以自行学习。我们说，并发编程，为了保证数据的安全，需要满足以下三个特性：\n\n**原子性**是指在一个操作中就是cpu不可以在中途暂停然后再调度，既不被中断操作，要不执行完成，要不就不执行。\n\n**可见性**是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。\n\n**有序性**即程序执行的顺序按照代码的先后顺序执行。\n\n有没有发现，**缓存一致性问题**其实就是**可见性问题**。而**处理器优化**是可以导致**原子性问题**的。**指令重排**即会导致**有序性问题**。所以，后文将不再提起硬件层面的那些概念，而是直接使用大家熟悉的原子性、可见性和有序性。\n\n## 什么是内存模型\n\n前面提到的，缓存一致性问题、处理器器优化的指令重排问题是硬件的不断升级导致的。那么，有没有什么机制可以很好的解决上面的这些问题呢？\n\n最简单直接的做法就是废除处理器和处理器的优化技术、废除CPU缓存，让CPU直接和主存交互。但是，这么做虽然可以保证多线程下的并发问题。但是，这就有点因噎废食了。\n\n所以，为了保证并发编程中可以满足原子性、可见性及有序性。有一个重要的概念，那就是——内存模型。\n\n<u>**为了保证共享内存的正确性（可见性、有序性、原子性），内存模型定义了共享内存系统中多线程程序读写操作行为的规范。**</u>通过这些规则来规范对内存的读写操作，从而保证指令执行的正确性。它与处理器有关、与缓存有关、与并发有关、与编译器也有关。他解决了CPU多级缓存、处理器优化、指令重排等导致的内存访问问题，保证了并发场景下的一致性、原子性和有序性。\n\n内存模型解决并发问题主要采用两种方式：**限制处理器优化**和**使用内存屏障**。本文就不深入底层原理来展开介绍了，感兴趣的朋友可以自行学习。","tags":["操作系统、计网、算法、数据结构、数据库"]},{"title":"红黑树","url":"/2021/04/12/红黑树/","content":"\n## 性质\n\n红黑树是每个节点都带有*颜色*属性的二叉查找树，颜色为*红色*或*黑色*。在二叉查找树强制一般要求以外，对于任何有效的红黑树我们增加了如下的额外要求：\n\n1. 节点是红色或黑色。\n2. 根是黑色。\n3. 所有叶子都是黑色（叶子是NIL节点）。\n4. 每个红色节点必须有两个黑色的子节点。（从每个叶子到根的所有路径上不能有两个连续的红色节点。）\n5. 从任一节点到其每个叶子的所有[简单路径](https://zh.wikipedia.org/wiki/道路_(图论))都包含相同数目的黑色节点。\n\n![](450px-Red-black_tree_example.svg.png)\n\n这些约束确保了红黑树的关键特性：**从根到叶子的最长的可能路径不多于最短的可能路径的两倍长**。结果是这个树大致上是平衡的。因为操作比如插入、删除和查找某个值的最坏情况时间都要求与树的高度成比例，这个在高度上的理论上限允许红黑树在最坏情况下都是高效的，而不同于普通的[二叉查找树](https://zh.wikipedia.org/wiki/二叉查找树)。\n\n要知道为什么这些性质确保了这个结果，注意到性质4导致了路径不能有两个毗连的红色节点就足够了。最短的可能路径都是黑色节点，最长的可能路径有交替的红色和黑色节点。因为根据性质5所有最长的路径都有相同数目的黑色节点，这就表明了没有路径能多于任何其他路径的两倍长。\n\n在很多树数据结构的表示中，一个节点有可能只有一个子节点，而叶子节点包含数据。用这种范例表示红黑树是可能的，但是这会改变一些性质并使算法复杂。为此，本文中我们使用\"nil叶子\"或\"空（null）叶子\"，如上图所示，它不包含数据而只充当树在此结束的指示。这些节点在绘图中经常被省略，导致了这些树好像同上述原则相矛盾，而实际上不是这样。与此有关的结论是所有节点都有两个子节点，尽管其中的一个或两个可能是空叶子。\n\n## 操作\n\n因为每一个红黑树也是一个特化的[二叉查找树](https://zh.wikipedia.org/wiki/二叉查找树)，因此红黑树上的只读操作与普通[二叉查找树](https://zh.wikipedia.org/wiki/二叉查找树)上的只读操作相同。然而，在红黑树上进行插入操作和删除操作会导致不再符合红黑树的性质。恢复红黑树的性质需要少量（O(log n)）的颜色变更（实际是非常快速的）和不超过三次[树旋转](https://zh.wikipedia.org/wiki/树旋转)（对于插入操作是两次）。虽然插入和删除很复杂，但操作时间仍可以保持为O(log n)次。\n\n### 插入\n\n共5种可能\n\n### 删除\n\n共6种可能","tags":["数据结构"]},{"title":"计算机网络常用知识点","url":"/2021/04/12/计网/","content":"\n## OSI,TCP/IP,五层协议的体系结构，各层协议\n\n---\n\n\n\nOSI分层（7层）：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。\n\n**TCP/IP分层（4层）：网络接口层、网际层、运输层、应用层。**\n\n五层协议：物理层、数据链路层、网络层、运输层、应用层。\n\n**TCP/IP协议族：**\n\n+ 应用层：HTTP，SMTP，DNS,RTP\n+ 运输层：TCP,UDP\n+ 网际层：IP\n\n**HTTP协议：** 超文本传输协议，是一个属于应用层的面向对象的协议，由于其简捷、快速的方式，适用于分布式超媒体信息系统。\n\n## TCP三次握手和四次挥手的全过程\n\n---\n\n![image-20210415220355775](计网/image-20210415220355775.png)\n\n#### **三次握手**\n\n- 第一次握手：客户端给服务端发一个 SYN 报文，并指明客户端的初始化序列号 ISN(c)。此时客户端处于 `SYN_SEND` 状态。\n\n  首部的同步位SYN=1，初始序号seq=x，SYN=1的报文段不能携带数据，但要消耗掉一个序号。\n\n- 第二次握手：服务器收到客户端的 SYN 报文之后，会以自己的 SYN 报文作为应答，并且也是指定了自己的初始化序列号 ISN(s)。同时会把客户端的 ISN + 1 作为ACK 的值，表示自己已经收到了客户端的 SYN，此时服务器处于 `SYN_RCVD` 的状态。\n\n  在确认报文段中SYN=1，ACK=1，确认号ack=x+1，初始序号seq=y。\n\n- 第三次握手：客户端收到 SYN 报文之后，会发送一个 ACK 报文，当然，也是一样把服务器的 ISN + 1 作为 ACK 的值，表示已经收到了服务端的 SYN 报文，此时客户端处于 `ESTABLISHED` 状态。服务器收到 ACK 报文之后，也处于 `ESTABLISHED` 状态，此时，双方已建立起了连接。\n\n  确认报文段ACK=1，确认号ack=y+1，序号seq=x+1（初始为seq=x，第二个报文段所以要+1），ACK报文段可以携带数据，不携带数据则不消耗序号。\n\n**状态整理**：\n\n+ 客户端：关闭（CLOSE）、同步已发送（SYN-SEND）、已建立连接（ESTABLISHED）\n+ 服务器：关闭（CLOSE）、收听（LISTEN）、同步收到（SYN-RCVD）、已建立连接（ESTABLISHED）\n\n#### 为什么需要三次握手，两次不行吗？\n\n关键字：**客户端重传**。**第一次握手**可能是一次**失效的握手**，**第三次握手**是对第一次握手的**确认**。\n\n假如两次，也就是客户端一发送，服务端就建立连接。那么假如客户端发送两次，因为第一次滞留，那么客户端相当于建立了两次连接，但实际上第一次已经是无效的了。\n\n如客户端发出连接请求，但因连接请求报文丢失而未收到确认，于是客户端再重传一次连接请求。后来收到了确认，建立了连接。数据传输完毕后，就释放了连接，客户端共发出了两个连接请求报文段，其中第一个丢失，第二个到达了服务端，但是第一个丢失的报文段只是在**某些网络结点长时间滞留了，延误到连接释放以后的某个时间才到达服务端**，此时服务端误认为客户端又发出一次新的连接请求，于是就向客户端发出确认报文段，同意建立连接，不采用三次握手，只要服务端发出确认，就建立新的连接了，此时客户端忽略服务端发来的确认，也不发送数据，则服务端一致等待客户端发送数据，浪费资源。\n\n### 四次挥手\n\n![image-20210415220422325](计网/image-20210415220422325.png)\n\n#### 四次挥手的过程如下：\n\n- 第一次挥手：客户端发送一个 FIN 报文，报文中会指定一个序列号。此时客户端处于 `FIN_WAIT1` 状态。 即发出**连接释放报文段**（FIN=1，序号seq=u），并停止再发送数据，主动关闭TCP连接，进入FIN_WAIT1（终止等待1）状态，等待服务端的确认。\n\n- 第二次挥手：服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序列号值 +1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 `CLOSE_WAIT` 状态。 即服务端收到连接释放报文段后即发出**确认报文段**（ACK=1，确认号ack=u+1，序号seq=v），服务端进入CLOSE_WAIT（关闭等待）状态，此时的TCP处于**半关闭状态**，客户端到服务端的连接释放。客户端收到服务端的确认后，进入FIN_WAIT2（终止等待2）状态，等待服务端发出的连接释放报文段。\n\n- 第三次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号。此时服务端处于 `LAST_ACK` 的状态。 即服务端没有要向客户端发出的数据，服务端发出**连接释放报文段**（FIN=1，ACK=1，序号seq=w，确-认号ack=u+1），服务端进入LAST_ACK（最后确认）状态，等待客户端的确认。\n\n- 第四次挥手：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 +1 作为自己 ACK 报文的序列号值，此时客户端处于 `TIME_WAIT` 状态。需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态，服务端收到 ACK 报文之后，就处于关闭连接了，处于 `CLOSED` 状态。 即客户端收到服务端的连接释放报文段后，对此发出**确认报文段**（ACK=1，seq=u+1，ack=w+1），客户端进入TIME_WAIT（时间等待）状态。此时TCP未释放掉，需要经过时间等待计时器设置的时间2MSL后，客户端才进入CLOSED状态。\n\n  时间MSL叫做**最长报文段寿命**（Maximun Segment Lifetime）\n\n**状态整理**：\n\n+ 客户端：已建立连接（ESTABLISHED）、FIN_WAIT1（终止等待1）、FIN_WAIT2（终止等待2）、TIME_WAIT（时间等待）\n+ 服务器：已建立连接（ESTABLISHED）、CLOSE_WAIT（关闭等待）、LAST_ACK（最后确认）\n\n### 挥手为什么需要四次\n\n关键字：半关闭，**服务端还想要发送数据**\n\n### 四次挥手释放连接时，等待2MSL的意义?\n\n#### 两个理由：\n\n1. 关键字：**客户端重传**，确保客户端最后一个 ACK 能够到达服务端（这个 ACK 可能丢失）\n\n   保证客户端发送的最后一个ACK报文段能够到达服务端。 **客户端的ACK报文段有可能丢失**（**所以客户端怎么着也得重传一次，不然服务端没办法正常关闭**），使得处于LAST-ACK状态的B收不到对已发送的FIN+ACK报文段的确认，服务端超时重传FIN+ACK报文段，而客户端能在2MSL时间内收到这个重传的FIN+ACK报文段，接着客户端重传一次确认，重新启动2MSL计时器，最后客户端和服务端都进入到CLOSED状态，若客户端在TIME-WAIT状态不等待一段时间，而是发送完ACK报文段后立即释放连接，则无法收到服务端重传的FIN+ACK报文段，所以不会再发送一次确认报文段，则服务端无法正常进入到CLOSED状态。\n\n2. 关键字：**已失效的连接请求报文段**\n\n   防止“已失效的连接请求报文段”出现在本连接中。 客户端在发送完最后一个ACK报文段后，再经过2MSL，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失，使下一个新的连接中不会出现这种旧的连接请求报文段。\n\n**ACK报文**：在TCP/IP协议中，如果接收方成功的接收到数据，那么会回复一个ACK数据。通常ACK信号有自己固定的格式,长度大小,由接收方回复给发送方。\n\n**TCP 对应的一些函数**\n\n#### TCP 三次握手发生在哪个函数之间\n\nTCP 三次握手是发送在**客户端**调用 `connect()` 函数的时候，注意服务器响应 ack 跟 `accept()` 没什么关系，服务器在 listen() 之后，就可以响应 ack，所以如果问发生在服务器端的哪个函数，应该说是 `listen()` 之后。\n\n## tcp和udp的区别\n\n---\n\n**比较方向**\n\ntcp 是一个 **可靠** 的 **面向连接** 的 **字节流** 服务\n\n可靠性，是否有连接，报文格式，双工性，传输速度\n\n![image-20210415220450406](计网/image-20210415220450406.png)\n\n## TCP如何保证可靠性\n\n---\n\n主要方向：**校验和**，**握手**，**流量控制**，**拥塞控制**\n\n+ 校验和，按16位为一个数据**相加**，最后的进位继续加，最终的值**取反**\n\n![image-20210415220516424](计网/image-20210415220516424.png)\n\n- 发送方：在发送数据之前计算检验和，并进行校验和的填充。 接收方：收到数据后，对数据以同样的方式进行计算，求出校验和，与发送方的进行比对。\n- 确认应答和序列号\n- 超时重传\n- 连接管理，三次握手，四次挥手\n- 流量控制\n- 拥塞控制\n\n## HTTP\n\n---\n\n### http状态码\n\n#### 201 Created （已创建）\n\n- 响应结果：该请求已成功，并因此创建了一个新的资源。\n- 使用场景：作为PUT请求的返回值。\n\n### 204 No Content (没有内容)\n\n- 响应结果：服务器成功处理了客户端请求，但服务器无返回内容。204是HTTP中数据量最少的响应状态，204的**响应中没有body**，而且Content-Length=0。\n- 使用场景：204状态在一些网站分析的代码中**最常用**到，只需要把客户端的一些信息提交给服务器而无需关心响应。\n\n### 301 Moved Permanently（永久性重定向)\n\n- 响应结果：表示请求的资源已被分配了新的URL，以后应使用现在所指的URL。也就是说如果已经吧资源对应的URL保存为书签了，这时应该按Location首部字段提示的URL重新保存。\n- 使用场景：\n- - 域名到期不想续费（或者发现了更适合网站的域名），想换个域名。\n- - 在搜索引擎的搜索结果中出现了不带www的域名，而带www的域名却没有收录，这个时候可以用301重定向来告诉搜索引擎我们目标的域名是哪一个。\n- - 空间服务器不稳定，换空间的时候。\n\n### 302 Found（临时性重定向）\n\n- 响应结果：该状态码表示请求的资源已被分配了新的URL，希望用户（本次）能使用新的URL访问。\n- 使用场景：尽量使用301！\n\n### 304 Not Modified\n\n字面意思是：资源未改变，可直接使用缓存。\n\n这种响应一般是GET请求中带有附加条件，例如请求头中含有if-Match,if-Modified-Since等（if-Match表示只请求带有特殊标记的资源，if-Modified-Since表示请求指定时间后未变更的资源，因为本文主要讲解状态码，所以不在此引入太多http头部的相关内容，这里是为了简单解释下附加条件请求的含义）。\n\n这种情况下，**服务端不会返回响应主体**，含义就是：”**从你上次访问以来这个资源都没变过哟，直接使用你本地的缓存就行啦**“。\n\n304就是3xx里面的一个特例，因为它不算是一个重定向。（一般我们认为重定向要给出一个新的地址让客户端去访问，304如果一定要解释为重定向，只能解释为让客户端转去访问缓存-_-）\n\n### 401 Unauthorized（未授权）\n\n- 响应结果：表示发送的请求需要有通过HTTP认证的认证信息。另外若之前已进行过一次请求，则表示用户认证失败。返回含有401响应必须包含一个适用于被请求资源的WWW-Authenticate 首部用以质询用户信息。当浏览器初次接收到401响应，会弹出认证用的对话窗口。\n- 出现原因：客户端错误，指的是由于缺乏目标资源要求的身份验证凭证，发送的请求未得到满足。\n\n### 403 Forbidden （禁止）\n\n- 响应结果：对请求资源的访问服务器拒绝了。服务器端没有必要给出拒绝的详细理由，但如果想作说明的话，可以在实体的主题部分对原因进行描述，这样就能让用户看到了。\n- 出现原因：未获得文件系统的访问授权，访问权限出现某些问题（从未授权的发送源IP地址试图访问）等列举情况都可能是发生403的原因。\n\n### 502 Bad Gateway\n\n作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应。这里说明下网关和代理服务器的概念：前面我们举例子都是直接客户端向服务器发请求，实际上客户端有时候不是直接向服务器请求，这中间可能存在网关和代理。画个简单的图：\n\n### 503 Service Unavailable\n\n服务器暂时无法使用，可能是维护或者升级，反正无法使用。\n\n### 504 Gateway Timeout\n\n作为网关或者代理工作的服务器访问超时。\n\n## ARQ协议\n\n---\n\n也是为了实现**可靠传输**的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组\n\n#### ARQ协议是什么？\n\n**自动重传请求**（Automatic Repeat-reQuest，ARQ）是OSI模型中数据链路层和传输层的错误纠正协议之一。它通过使用**确认**和**超时**这两个机制，在不可靠服务的基础上实现可靠的信息传输。如果发送方在发送后一段时间之内没有收到确认帧，它通常会重新发送。ARQ包括停止等待ARQ协议和连续ARQ协议。\n\n#### 根据arq协议可以延申出停止等待和连续arq协议\n\n### 停止等待ARQ协议\n\n- 停止等待协议是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认（回复ACK）。如果过了一段时间（超时时间后），还是没有收到 ACK 确认，说明没有发送成功，需要重新发送，直到收到确认后再发下一个分组；\n- 在停止等待协议中，若接收方收到重复分组，就丢弃该分组，但同时还要发送确认；\n\n### 连续ARQ协议\n\n连续 ARQ 协议可提高信道利用率。发送方维持一个发送窗口，凡位于发送窗口内的分组可以连续发送出去，而不需要等待对方确认。接收方一般采用累计确认，对按序到达的最后一个分组发送确认，表明到这个分组为止的所有分组都已经正确收到了。\n\n## 各层对应协议\n\n---\n\n```\n 每一层的协议如下：\n 物理层：RJ45、CLOCK、IEEE802.3    （中继器，集线器）\n 数据链路：PPP、FR、HDLC、VLAN、MAC  （网桥，交换机）\n 网络层：IP、ICMP、ARP、RARP、OSPF、IPX、RIP、IGRP、 （路由器）\n 传输层：TCP、UDP、SPX\n 会话层：NFS、SQL、NETBIOS、RPC\n 表示层：JPEG、MPEG、ASII\n 应用层：FTP、DNS、Telnet、SMTP、HTTP、WWW、NFS\n 每一层的作用如下：\n 物理层：通过媒介传输比特,确定机械及电气规范（比特Bit）\n 数据链路层：将比特组装成帧和点到点的传递（帧Frame）\n 网络层：负责数据包从源到宿的传递和网际互连（包PackeT）\n 传输层：提供端到端的可靠报文传递和错误恢复（段Segment）\n 会话层：建立、管理和终止会话（会话协议数据单元SPDU）\n 表示层：对数据进行翻译、加密和压缩（表示协议数据单元PPDU）\n 应用层：允许访问OSI环境的手段（应用协议数据单元APDU）\n```\n\n## 常用端口\n\n---\n\n```\n20,21：FTP\n22：SSH\n23：Telnet\n25：SMTP\n53：DNS（UDP）\n69：TFTP（类似FTP）\n80：HTTP\n443：HTTPS\n1080：socks代理服务\n8080：用户www代理服务\n```\n\n## HTTPS加密过程\n\n---\n\n### HTTP和HTTPS区别\n\nhttps://blog.csdn.net/xionghuixionghui/article/details/68569282\n\nHTTP协议以明文方式发送内容，不提供任何方式的数据加密，如果攻击者截取了Web浏览器和网站服务器之间的传输报文，就可以直接读懂其中的信息，因此，HTTP协议不适合传输一些敏感信息，比如：信用卡号、密码等支付信息。\n\n安全套接字层超文本传输协议HTTPS，为了数据传输的安全，HTTPS在HTTP的基础上加入了SSL协议，SSL依靠证书来验证服务器的身份，并为浏览器和服务器之间的通信加密。\n\nHTTPS协议的主要作用可以分为两种：一种是建立一个信息安全通道，来保证数据传输的安全；另一种就是确认网站的真实性。\n\n简单来说，HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全。\n\nHTTPS和HTTP的区别主要如下：\n\n1、https协议需要到ca**申请证书**，一般免费证书较少，因而需要一定费用。\n\n2、http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。\n\n3、http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。\n\n4、http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。\n\n最新推出的TLS协议，是SSL 3.0协议的升级版\n\n![图片](计网/640)\n\nhttps://mp.weixin.qq.com/s?__biz=MzA5MzY4NTQwMA==&mid=2651008910&idx=4&sn=049fa10eecb3de61b98d7f58bbb78f74&chksm=8bad9c79bcda156fc2097361977595d4a19a56ded9c8b1ca55890bfe800db0551b1723f2d7b9&mpshare=1&scene=24&srcid=08287mXFO8ufu50J99Dwdfcp&sharer_sharetime=1566958392180&sharer_shareid=21a49bdfc44694f7d1e3ef9964b3998f#rd\n\n1. 客户端请求服务器获取证书**公钥**。\n2. 客户端(SSL/TLS)解析证书（无效会弹出警告）。\n3. 客户端生成随机值（这个随机值就是密钥）。\n4. 客户端用公钥加密密钥，发送给服务器。\n5. 服务端用私钥解密密钥得到随机值（密钥）。---从此以后就用密钥通信\n6. 将信息和随机值混合在一起进行对称加密。\n7. 将加密的内容发送给客户端。\n8. 客户端用秘钥解密信息。\n\nhttp://www.ruanyifeng.com/blog/2011/08/what_is_a_digital_signature.html\n\nca证书https://www.cnblogs.com/handsomeBoys/p/6556336.html\n\n## TCP KeepAlive 原理\n\n---\n\nTCP KeepAlive 的基本原理是，**隔一段时间给连接对端发送一个探测包**，如果收到对方回应的 ACK，则认为连接还是存活的，在超过一定重试次数之后还是没有收到对方的回应，则丢弃该 TCP 连接。\n\n## PING 的过程/实现\n\n---\n\nhttps://blog.51cto.com/wanicy/335207","tags":["操作系统、计网、算法、数据结构、数据库"]},{"title":"Java的一些基础知识点","url":"/2021/04/12/Java基础/","content":"\n## hashmap如何实现\n\nHashMap是使用**hash算法**,然后基于**数组+链表+红黑树**来实现的,或许还知道HashMap内部数组的初始长度为**16**,并且还能**自动扩容**.\n\n**简单来说，HashMap由数组+链表组成的，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的，如果定位到的数组位置不含链表（当前entry的next指向null）,那么对于查找，添加等操作很快，仅需一次寻址即可；如果定位到的数组包含链表，对于添加操作，其时间复杂度为O(n)，首先遍历链表，存在即覆盖，否则新增；对于查找操作来讲，仍需遍历链表，然后通过key对象的equals方法逐一比对查找。所以，性能考虑，HashMap中的链表出现越少，性能才会越好。**\n\n![img](C:%5CUsers%5CPowerwenwh%5CDocuments%5CMyBlog%5Csource%5C_posts%5Cimgs%5CJava%E5%9F%BA%E7%A1%80%5C1024555-20161113235348670-746615111.png)\n\n![img](C:%5CUsers%5CPowerwenwh%5CDocuments%5CMyBlog%5Csource%5C_posts%5Cimgs%5CJava%E5%9F%BA%E7%A1%80%5C1292434-20171210003109576-1016700625.jpg)\n\n我们可以看到12和0的位置冲突了，然后我们把该数组的每一个元素变成了一个链表头，冲突的元素放在了链表中，这样在找到对应的链表头之后会顺着链表找下去，至于**为什么采用链表，是为了节省空间，链表在内存中并不是连续存储**，所以我们可以更充分地使用内存。\n\n## ReentrantLock与synchronized（同步锁）锁\n\n**线程不同步的原因**\n\n线程之所以会不同步，**本质原因在于每个线程的高速缓存区**。每个线程在创建后会有自己的一个缓存区，在线程要访问主存中的变量的时候会先将主存中的变量加入缓存，然后进行操作，这样可以避免主存访问过于频繁，可以加快线程的执行效率（类似于cache）。但问题在于每个线程的缓存区之间不可见，如果载入的是主存中的同一个变量，分别进行了更改，就会出现线程不同步的问题。\n\n**synchronized是如何实现同步的##**\n\n好吧其实很简单，比较机智的读者可能已经猜到了，他其实是使各个线程之间的高速缓存区失效了，然后线程要获取该变量的时候需要在主存中读写，这个时候对该变量的操作对于各个线程之间是可见的，然后操作结束之后再刷新其缓存区，\n\n**reentrantlock**\n\nsynchonized的缺点。一是不灵活，**synchonized在锁定之后必须要代码块结束之后才能释放锁**，然后被其他线程获得。那么如果获取到锁的这个线程要执行非常长的时间呢，那其他的线程不是会一直阻塞在这里，这时如果有哪个线程生气了不想等了怎么办？抱歉不可以，需要一直等待。另一方面，同步锁的**释放顺序也很固定**，必须是加锁的反顺序，很不潇洒等等。。。\n\n声明了ReentrantLock对象后只需调用其中的lock方法便可直接加锁，而释放锁需要unlock方法。这样一是很灵活，**不需要代码块结束再释放**，还有就是 ReentrantLock是可中断的，如果等待的线程不想等了，好说，interrupt掉就好了，另外， **ReentrantLock可以设为悲观锁和乐观锁，而synchonized则默认为悲观锁**，不可改变，不够灵活。所以综上，ReentrantLock更加灵活多变。但大家在使用时一定要记得unlock，最好写在finally里面防止忘记，不然就会造成其他线程阻塞。\n\n## Java中的锁分类\n\nJava中锁分为以下几种：\n\n- 乐观锁、悲观锁\n- 独享锁、共享锁\n- 公平锁、非公平锁\n- 互斥锁、读写锁\n- 可重入锁\n- 分段锁\n- 锁升级(无锁 -> 偏向锁 -> 轻量级锁 -> 重量级锁) JDK1.6\n\n这些锁的分类并不全是指锁的状态，有的指**锁的特性，有的指锁的设计**，下面总结的内容是对每个锁的名词进行一定的解释。\n\n### 1、乐观锁 & 悲观锁\n\n两种锁只是一种概念\n\n**乐观锁：**乐观锁认为一个线程去拿数据的时候不会有其他线程对数据进行更改，所以不会上锁。\n\n实现方式：CAS机制、版本号机制\n\n**悲观锁：**悲观锁认为一个线程去拿数据时一定会有其他线程对数据进行更改。所以一个线程在拿数据的时候都会顺便加锁，这样别的线程此时想拿这个数据就会阻塞。比如Java里面的synchronized关键字的实现就是悲观锁。实现方式：就是加锁。\n\n### 2、独享锁 & 共享锁\n\n两种锁只是一种概念\n\n**独享锁：**该锁一次只能被一个线程所持有\n\n**共享锁：**该锁可以被多个线程所持有\n\n举例：\n\nsynchronized是独享锁；\n\n可重入锁ReentrantLock是独享锁；\n\n读写锁ReentrantReadWriteLock中的读锁ReadLock是共享锁，写锁WriteLock是独享锁。\n\n独享锁与共享锁通过AQS(AbstractQueuedSynchronizer)来实现的，通过实现不同的方法，来实现独享或者共享。\n\n### 3、互斥锁 & 读写锁\n\n上面讲的独享锁/共享锁就是一种概念，互斥锁/读写锁是具体的实现。\n\n**互斥锁**的具体实现就是synchronized、ReentrantLock。ReentrantLock是JDK1.5的新特性，采用ReentrantLock可以完全替代替换synchronized传统的锁机制，更加灵活。\n\n**读写锁**的具体实现就是读写锁ReadWriteLock。\n\n### 4、可重入锁\n\n定义：对于同一个线程在外层方法获取锁的时候，在进入内层方法时也会自动获取锁。\n\n优点：避免死锁\n\n举例：ReentrantLock、synchronized\n\n### 5、公平锁 & 非公平锁\n\n**公平锁：**多个线程相互竞争时要排队，多个线程按照申请锁的顺序来获取锁。\n\n**非公平锁：**多个线程相互竞争时，先尝试插队，插队失败再排队，比如：synchronized、ReentrantLock\n\n### 6、分段锁\n\n分段锁并不是具体的一种锁，只是一种锁的设计。\n\n分段锁的设计目的是细化锁的粒度，当操作不需要更新整个数组的时候，就仅仅针对数组中的一项进行加锁操作。CurrentHashMap底层就用了分段锁，使用Segment，就可以进行并发使用了，而HashMap确实非线程安全的，就差在了分段锁上。\n\n### 7、偏向锁 & 轻量级锁 & 重量级锁\n\nJDK 1.6 为了减少获得锁和释放锁所带来的性能消耗，在JDK 1.6里引入了4种锁的状态：**无锁、偏向锁、轻量级锁和重量级锁**，它会随着多线程的竞争情况逐渐升级，但不能降级。\n\n研究发现大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了不让这个线程每次获得锁都需要CAS操作的性能消耗，就引入了偏向锁。当一个线程访问对象并获取锁时，会在对象头里存储锁偏向的这个线程的ID，以后该线程再访问该对象时只需判断对象头的Mark Word里是否有这个线程的ID，如果有就不需要进行CAS操作，这就是偏向锁。当线程竞争更激烈时，偏向锁就会升级为轻量级锁，轻量级锁认为虽然竞争是存在的，但是理想情况下竞争的程度很低，通过自旋方式等待一会儿上一个线程就会释放锁，但是当自旋超过了一定次数，或者一个线程持有锁，一个线程在自旋，又来了第三个线程访问时（反正就是竞争继续加大了），轻量级锁就会膨胀为重量级锁，重量级锁就是Synchronized,重量级锁会使除了此时拥有锁的线程以外的线程都阻塞。\n\n## Java数组和链表的区别\n\n从数据结构上说，数组的**内存空间是连续的**，我们创建数组的时候系统就会为我们开辟固定数目的内存空间，如果内存不足，就会创建失败，例如创建数组的两种方式：\nint[] a=new int[3];\nint[] b=new int[]{1,2,3};\n可以看到我们创建数组的时候已经指定了数组的大小，且不能动态更改数组的大小，是因为创建时候已经分配了连续的固定内存空间，每个元素占用两个字节，这样我们就可以通过连续的内存，去访问数组的元素；\n\n**链表的内存分配是动态的**，链表的元素占用的空间包含元素占用的空间，还有指向上一个或者下一个元素的指针（双链表，单链表）；\n\n这样我们可以得出各自的优缺点：\n\n数组链表的优缺点：\n**数组占用空间小**，链表元素还要包涵上一元素和下一个元素的的信息\n**数组的访问速度快**，因为内存是连续的\n**数组内部元素可以随机访问**，而链表依赖于上一个元素的信息\n\n链表的插入删除操作由于数组，因为内存不连续，只需要更改元素的前后节点信息就行了，并不需要更改元素内存地址，而数组的连续内存想要插入和删除的话就要移动所有的内存地址\n链表的**内存利用率高于数组**，链表内存是分散的一个元素占用一块空间，数组元素少于内存空间的话，会有部分的内存浪费；\n链表的**扩展性强**，数组的创建完成内存大小就确定了，满了就没法扩展只能再次创建新的数组，而链表可以随意的增加扩展\n\n效率：数组查询效率高，链表增，删效率高\n\n## 列举两种单例模式\n\nJava中单例模式是一种常见的设计模式，单例模式的写法有好几种，这里主要介绍懒汉式单例、饿汉式单例.\n\n### **介绍**\n\n意图：保证一个类仅有一个实例，并提供一个访问它的全局访问点。\n\n主要解决：一个全局使用的类频繁地创建与销毁。\n\n何时使用：当您**想控制实例数目，节省系统资源的时候。**\n\n如何解决：判断系统是否已经有这个单例，如果有则返回，如果没有则创建。\n\n关键代码：构造函数是私有的。\n\n应用实例： 1、一个党只能有一个书记。 2、Windows 是多进程多线程的，在操作一个文件的时候，就不可避免地出现多个进程或线程同时操作一个文件的现象，所以所有文件的处理必须通过唯一的实例来进行。 3、一些设备管理器常常设计为单例模式，比如一个电脑有两台打印机，在输出的时候就要处理不能两台打印机打印同一个文件。\n\n优点： 1、在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例（比如管理学院首页页面缓存）。 2、避免对资源的多重占用（比如写文件操作）。\n\n缺点：没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。\n\n使用场景： 1、要求生产唯一序列号。 2、WEB 中的计数器，不用每次刷新都在数据库里加一次，用单例先缓存起来。 3、创建的一个对象需要消耗的资源过多，比如 I/O 与数据库的连接等。\n\n特点：\n\n1. 单例模式只能有一个实例。\n2. 单例模式必须自己创建自己的唯一实例。\n3. 单例模式的构造器必须是私有，不允许外界通过构造器构建对象。\n4. 单例模式只能通过公开的静态方法向外界返回类的唯一实例。\n\n### **饿汉式单例**\n\n```java\npublic class SingletonEH {\n    /**\n     *是否 Lazy 初始化：否\n     *是否多线程安全：是\n     *实现难度：易\n     *描述：这种方式比较常用，但容易产生垃圾对象。\n     *优点：没有加锁，执行效率会提高。\n     *缺点：类加载时就初始化，浪费内存。\n     *它基于 classloder 机制避免了多线程的同步问题，\n     * 不过，instance 在类装载时就实例化，虽然导致类装载的原因有很多种，\n    * 在单例模式中大多数都是调用 getInstance 方法，\n     * 但是也不能确定有其他的方式（或者其他的静态方法）导致类装载，\n     * 这时候初始化 instance 显然没有达到 lazy loading 的效果。\n     */\n    private static SingletonEH instance = new SingletonEH();\n    private SingletonEH (){}\n    public static SingletonEH getInstance() {\n        System.out.println(\"instance:\"+instance);\n        System.out.println(\"加载饿汉式....\");\n        return instance;\n    }\n}\n```\n\n饿汉就是类一旦加载，就把单例初始化完成，保证getInstance的时候，单例是已经存在的了。\n\n### **懒汉式单例**\n\n```java\n\npublic class SingletonLH {\n    /**\n     *是否 Lazy 初始化：是\n     *是否多线程安全：否\n     *实现难度：易\n     *描述：这种方式是最基本的实现方式，这种实现最大的问题就是不支持多线程。因为没有加锁 synchronized，所以严格意义上它并不算单例模式。\n     *这种方式 lazy loading 很明显，不要求线程安全，在多线程不能正常工作。\n     */\n    private static SingletonLH instance;\n    private SingletonLH (){}\n \n    public static SingletonLH getInstance() {\n        if (instance == null) {\n            instance = new SingletonLH();\n        }\n        return instance;\n    }\n}\n```\n\n而懒汉比较懒，只有当调用getInstance的时候，才回去初始化这个单例。\n\n### **1、线程安全：**\n\n饿汉式天生就是线程安全的，可以直接用于多线程而不会出现问题，\n\n懒汉式本身是非线程安全的，为了实现线程安全有几种写法。\n\n例：\n\n```java\n\t\npublic class SingletonLHsyn {\n    /**\n     *是否 Lazy 初始化：是\n     *是否多线程安全：是\n     *实现难度：易\n     *描述：这种方式具备很好的 lazy loading，能够在多线程中很好的工作，但是，效率很低，99% 情况下不需要同步。\n     *优点：第一次调用才初始化，避免内存浪费。\n     *缺点：必须加锁 synchronized 才能保证单例，但加锁会影响效率。\n     *getInstance() 的性能对应用程序不是很关键（该方法使用不太频繁）。\n     */\n    private static SingletonLHsyn instance;\n    private SingletonLHsyn (){}\n    public static synchronized SingletonLHsyn getInstance() {\n        if (instance == null) {\n            instance = new SingletonLHsyn();\n        }\n        return instance;\n    }\n}\n```\n\n### **2、资源加载和性能：**\n\n饿汉式在类创建的同时就实例化一个静态对象出来，不管之后会不会使用这个单例，都会占据一定的内存，但是相应的，在第一次调用时速度也会更快，因为其资源已经初始化完成。\n\n而懒汉式顾名思义，会延迟加载，在第一次使用该单例的时候才会实例化对象出来，第一次调用时要做初始化，如果要做的工作比较多，性能上会有些延迟，之后就和饿汉式一样了。\n\n### **为什么要用单例模式？**\n\n```java\npublic class Printer {\n    private static Printer printer =null;//创建一个私有的全局变量\n    /*\n     * 如果有多线程并发访问时，上锁，让其排队等候，一次只能一人用。\n     */\n    public static synchronized Printer getPrinter(){\n        if(printer==null){//如果为空，创建本实例\n            printer = new Printer();\n        }\n        return printer;\n    }\n    /*\n     * 构造私有化，保证在系统的使用中，只有一个实例\n     */\n    private Printer(){\n        \n    }\n}\n```\n\n从代码上来分析，单例模式，首先向外提供了一个可被访问的实例化的对象，如果没有此对象时，该printer类创建一个。如果遇到多线程并发访问，加上关键字Synchronized，上锁让没有持有该对象的类处于等待状态。当前持有该printer的线程任务结束之后，处于等待中的线程才能逐个去持有该实例，去操作其方法。这样的一个过程 在编程中被称为单例模式。\n如果在系统中不使用单例模式的话，在碰到多线程访问的时候，<u>printer就会给要请求的类，分别在内存中new出一个printer对象</u>，让这些请求的类去做print方法。这样<u>大量占有内存，就会导致系统运行变慢</u>，像电脑的CPU一样，占有量极高，电脑卡死不动的感觉。因为系统的硬件设施需求变动量小，所以只能想出一个节约成本 的方法就是，单例模式，<u>让多线程处于等待的状态，一个 一个的去解决</u>，这样，即节约内存，提交了运行的成本。也就是单例存在的意义。\n\n## 重写和重载的区别\n\n**重写**:\n\n重写（Override）是**父类与子类之间多态性的一种表现**。如果在子类中定义某方法与其父类有**相同的名称和参数**，我们说该方法被重写 (Override)。子类的对象使用这个方法时，将调用子类中的定义，对它而言，父类中的定义如同被“**屏蔽**”了。\n\n**重载：**\n\n重载（Overload）是**一个类中多态性的一种表现**。如果在一个类中定义了多个同名的方法，它们**参数列表不同**，则称为方法的重载(Overload)\n\n**区别：**重载实现于一个类中;重写实现于子类中。\n\n重载(Overload)：是一个类中多态性的一种表现，指同一个类中不同的函数使用**相同的函数名**，但是**函数的参数个数或类型不同**。可以有**不同的返回类型**;可以有不同的访问修饰符;可以抛出不同的异常。调用的时候根据函数的参数来区别不同的函数。\n\n重写（Override): 是父类与子类之间的多态性，是**子类对父类函数的重新实现**。**函数名和参数与父类一样**，子类与父类**函数体内容不一样**。子类**返回的类型**必须与父类保持一致；子类方法访问修饰符的限制一定要大于父类方法的访问修饰（public>protected>default>private）；子类重写方法一定不能抛出新的检查异常或者比被父类方法申明更加宽泛的检查型异常。\n\n## **重载**\n\n```java\npackage com.etime09;\n\npublic class Goods {  //创建一个商品类 \nprivate String ID;\nprivate int price;\nprivate String name;\nprivate String manufactureDate;\n//实现构造函数的重载 参数个数或类型不同\npublic Goods() {\n\tsuper();\n\t// TODO Auto-generated constructor stub\n}\npublic Goods(String iD) {\n\tsuper();\n\tID = iD;\n}\npublic Goods(String iD, int price) {\n\tsuper();\n\tID = iD;\n\tthis.price = price;\n}\npublic Goods(String iD, int price, String name) {\n\tsuper();\n\tID = iD;\n\tthis.price = price;\n\tthis.name = name;\n}\npublic Goods(String iD, int price, String name, String manufactureDate) {\n\tsuper();\n\tID = iD;\n\tthis.price = price;\n\tthis.name = name;\n\tthis.manufactureDate = manufactureDate;\n}\n\n}\n```\n\n## **重写**\n\n```java\npackage com.etime09;\n\npublic class Person {  //创建一个父类Person\nprivate String name;\nprivate int age;\n//父类中写一个eat()方法\n\tpublic void eat() {\n\t\tSystem.out.println(\"人都要吃饭\");\n\t\t}\n}\n---------------------------------------------\npackage com.etime09;\n\npublic class Student extends Person {  //Student子类继承Person父类\n@Override\n//重写eat()方法   方法名，参数，返回类型相同；方法体内容不同\npublic void eat() {\n\tSystem.out.println(\"学生喜欢吃肉\");\n\t\t\t}\n}\n```\n\n## 面向对象三大特征\n\n### (1)封装(Encapsulation)\n\n**所谓封装，也就是把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏**。封装是面向对象的特征之一，是对象和类概念的主要特性。简单的说，一个类就是一个封装了数据以及操作这些数据的代码的逻辑实体。在一个对象内部，某些代码或某些数据可以是私有的，不能被外界访问。通过这种方式，对象对内部数据提供了不同级别的保护，以防止程序中无关的部分意外的改变或错误的使用了对象的私有部分。\n\n------\n\n### (2)继承(Inheritance)\n\n**继承是指这样一种能力：它可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展**。通过继承创建的新类称为“子类”或“派生类”，被继承的类称为“基类”、“父类”或“超类”。继承的过程，就是从一般到特殊的过程。要实现继承，可以通过“继承”（Inheritance）和“组合”（Composition）来实现。继承概念的实现方式有二类：**实现继承与接口继承**。\n\n- 实现继承是指直接使用基类的属性和方法而无需额外编码的能力；\n- 接口继承是指仅使用属性和方法的名称、但是子类必须提供实现的能力。\n\n------\n\n### (3)多态(Polymorphism)\n\n**所谓多态就是指一个类实例的相同方法在不同情形有不同表现形式。多态机制使具有不同内部结构的对象可以共享相同的外部接口**。这意味着，虽然针对不同对象的具体操作不同，但通过一个公共的类，它们（那些操作）可以通过相同的方式予以调用。最常见的多态就是将子类传入父类参数中，运行时调用父类方法时通过传入的子类决定具体的内部结构或行为。\n\n## MySQL两种引擎\n\nMySQL应用最广泛的有两种存储引擎：\n\n**一个是MyISAM**，不支持事务处理，读性能处理快，表级别锁。\n\n**一个是InnoDB**，支持事务处理（ACID属性）,设计目标是为大数据处理，行级别锁，外键。\n\nACID（Atomicity 原子性、Consistency 一致性、Isolation 隔离性、Durability 持久性）是一系列属性\n\n表锁：开销小，锁定粒度大，发生死锁概率高，相对并发也低。\n行锁：开销大，锁定粒度小，发生死锁概率低，相对并发也高。\n\nInnoDB不支持FULLTEXT类型的索引。\n\nInnoDB 中不保存表的具体行数，也就是说，执行select count(*) from table时，InnoDB要扫描一遍整个表来计算有多少行，但是MyISAM只要简单的读出保存好的行数即可。注意的是，当count(*)语句包含 where条件时，两种表的操作是一样的。\n\n对于AUTO_INCREMENT类型的字段，InnoDB中必须包含只有该字段的索引，但是在MyISAM表中，可以和其他字段一起建立联合索引。\n\nDELETE FROM table时，InnoDB不会重新建立表，而是一行一行的删除。\n\nLOAD TABLE FROM MASTER操作对InnoDB是不起作用的，解决方法是首先把InnoDB表改成MyISAM表，导入数据后再改成InnoDB表，但是对于使用的额外的InnoDB特性(例如外键)的表不适用。\n\n另外，InnoDB表的行锁也不是绝对的，假如在执行一个SQL语句时MySQL不能确定要扫描的范围，InnoDB表同样会锁全表，例如update table set num=1 where name like “%aaa%”\n\n作为使用MySQL的用户角度出发，Innodb和MyISAM都是比较喜欢的，如果数据库平台要达到需求：99.9%的稳定性，方便的扩展性和高可用性来说的话，MyISAM绝对是首选。\n\n　　原因如下：\n\n　　1、平台上承载的大部分项目是读多写少的项目，而MyISAM的读性能是比Innodb强不少的。\n\n　　2、MyISAM的索引和数据是分开的，并且索引是有压缩的，内存使用率就对应提高了不少。能加载更多索引，而Innodb是索引和数据是紧密捆绑的，没有使用压缩从而会造成Innodb比MyISAM体积庞大不小。\n\n　　3、经常隔1，2个月就会发生应用开发人员不小心update一个表where写的范围不对，导致这个表没法正常用了，这个时候MyISAM的优越性就体现出来了，随便从当天拷贝的压缩包取出对应表的文件，随便放到一个数据库目录下，然后dump成sql再导回到主库，并把对应的binlog补上。如果是Innodb，恐怕不可能有这么快速度，别和我说让Innodb定期用导出xxx.sql机制备份，因为最小的一个数据库实例的数据量基本都是几十G大小。\n\n　　4、从接触的应用逻辑来说，select count(*) 和order by 是最频繁的，大概能占了整个sql总语句的60%以上的操作，而这种操作Innodb其实也是会锁表的，很多人以为Innodb是行级锁，那个只是where对它主键是有效，非主键的都会锁全表的。\n\n　　5、还有就是经常有很多应用部门需要我给他们定期某些表的数据，MyISAM的话很方便，只要发给他们对应那表的frm.MYD,MYI的文件，让他们自己在对应版本的数据库启动就行，而Innodb就需要导出xxx.sql了，因为光给别人文件，受字典数据文件的影响，对方是无法使用的。\n\n　　6、如果和MyISAM比insert写操作的话，Innodb还达不到MyISAM的写性能，如果是针对基于索引的update操作，虽然MyISAM可能会逊色Innodb,但是那么高并发的写，从库能否追的上也是一个问题，还不如通过多实例分库分表架构来解决。\n\n　　7、如果是用MyISAM的话，merge引擎可以大大加快应用部门的开发速度，他们只要对这个merge表做一些select count(*)操作，非常适合大项目总量约几亿的rows某一类型(如日志，调查统计)的业务表。\n\n　　当然Innodb也不是绝对不用，用事务的项目就用Innodb的。另外，可能有人会说你MyISAM无法抗太多写操作，但是可以通过架构来弥补。\n\n## 预防死锁\n\n**死锁**\n当线程A持有独占锁a，并尝试去获取独占锁b的同时，线程B持有独占锁b，并尝试获取独占锁a的情况下，就会发生AB两个线程由于互相持有对方需要的锁，而发生的阻塞现象，我们称为死锁。\n\n**如何避免死锁？**\n\n教科书般的回答应该是，结合“哲学家就餐”模型，分析并总结出以下死锁的原因，最后得出“避免死锁就是破坏造成死锁的，若干条件中的任意一个”的结论。\n\n造成死锁必须达成的4个条件（原因）：\n\n1. **互斥条件**：一个资源每次只能被一个线程使用。\n2. **请求与保持条件**：一个线程因请求资源而阻塞时，对已获得的资源保持不放。\n3. **不剥夺条件**：线程已获得的资源，在未使用完之前，不能强行剥夺。\n4. **循环等待条件**：若干线程之间形成一种头尾相接的循环等待资源关系。\n\n但是，“哲学家就餐”光看名字就很讨厌，然后以上这4个条件看起来也很绕口，再加上笔者又是个懒人，所以要让我在面试时把这些“背诵”出来实在是太难了！必须要想办法把这4个条件简化一下！\n 于是，通过对4个造成死锁的条件进行逐条分析，我们可以得出以下4个结论。\n\n1. 互斥条件 ---> 独占锁的特点之一。\n2. 请求与保持条件 ---> 独占锁的特点之一，尝试获取锁时并不会释放已经持有的锁\n3. 不剥夺条件 ---> 独占锁的特点之一。\n4. 循环等待条件 ---> 唯一需要记忆的造成死锁的条件。\n\n不错！复杂的死锁条件经过简化，现在需要记忆的仅只有独占锁与第四个条件而已。\n\n所以，面对如何避免死锁这个问题，我们只需要这样回答！\n :   在并发程序中，避免了逻辑中出现复数个线程互相持有对方线程所需要的独占锁的情况，就可以避免死锁。\n\n## JVM内存结构 VS Java内存模型 VS Java对象模型\n\n### JVM内存结构\n\nJava代码是要运行在虚拟机上的，而虚拟机在执行Java程序的过程中会把所管理的内存划分为若干个不同的数据区域，这些区域都有各自的用途。其中有些区域随着虚拟机进程的启动而存在，而有些区域则依赖用户线程的启动和结束而建立和销毁。\n\n![QQ20180624-150918](C:%5CUsers%5CPowerwenwh%5CDocuments%5CMyBlog%5Csource%5C_posts%5Cimgs%5CJava%E5%9F%BA%E7%A1%80%5CQQ20180624-150918.png)\n\n1、以上是Java虚拟机规范，不同的虚拟机实现会各有不同，但是一般会遵守规范。\n\n2、规范中定义的方法区，只是一种概念上的区域，并说明了其应该具有什么功能。但是并没有规定这个区域到底应该处于何处。所以，对于不同的虚拟机实现来说，是由一定的自由度的。\n\n3、不同版本的方法区所处位置不同，上图中划分的是逻辑区域，并不是绝对意义上的物理区域。因为某些版本的JDK中方法区其实是在堆中实现的。\n\n4、运行时常量池用于存放编译期生成的各种字面量和符号应用。但是，Java语言并不要求常量只有在编译期才能产生。比如在运行期，String.intern也会把新的常量放入池中。\n\n5、除了以上介绍的JVM运行时内存外，还有一块内存区域可供使用，那就是直接内存。Java虚拟机规范并没有定义这块内存区域，所以他并不由JVM管理，是利用本地方法库直接在堆外申请的内存区域。\n\n6、堆和栈的数据划分也不是绝对的，如HotSpot的JIT会针对对象分配做相应的优化。\n\n如上，做个总结，JVM内存结构，由Java虚拟机规范定义。描述的是Java程序执行过程中，由JVM管理的不同数据区域。各个区域有其特定的功能。\n\n### Java内存模型\n\nJava内存模型看上去和Java内存结构（JVM内存结构）差不多，很多人会误以为两者是一回事。\n\n在前面的关于JVM的内存结构的图中，我们可以看到，其中Java堆和方法区的区域是多个线程共享的数据区域。也就是说，多个线程可能可以操作保存在堆或者方法区中的同一个数据。这也就是我们常说的“Java的线程间通过共享内存进行通信”。\n\nJava内存模型是根据英文Java Memory Model（JMM）翻译过来的。其实JMM并不像JVM内存结构一样是真实存在的。他只是一个**抽象的概念**。[JSR-133: Java Memory Model and Thread Specification](http://www.cs.umd.edu/~pugh/java/memoryModel/jsr133.pdf)中描述了，JMM是**和多线程相关的**，他描述了**一组规则或规范**，这个规范定义了一个线程对共享变量的写入时对另一个线程是可见的。\n\n那么，简单总结下，**Java的多线程之间是通过共享内存进行通信的**，而由于采用共享内存进行通信，在通信过程中会存在一系列如**可见性、原子性、顺序性等问题**，而JMM就是围绕着多线程通信以及与其相关的一系列特性而建立的模型。JMM定义了一些语法集，这些语法集映射到Java语言中就是volatile、synchronized等关键字。\n\n[![11](C:%5CUsers%5CPowerwenwh%5CDocuments%5CMyBlog%5Csource%5C_posts%5Cimgs%5CJava%E5%9F%BA%E7%A1%80%5C11.png)](http://www.hollischuang.com/wp-content/uploads/2018/06/11.png)\n\n在Java中，JMM是一个非常重要的概念，正是由于有了JMM，Java的并发编程才能避免很多问题。这里就不对Java内存模型做更加详细的介绍了，想了解更多的朋友可以参考《Java并发编程的艺术》。\n\n### Java对象模型\n\nJava是一种面向对象的语言，而Java对象在JVM中的存储也是有一定的结构的。而这个关于Java对象自身的存储模型称之为Java对象模型。\n\nHotSpot虚拟机中，设计了一个OOP-Klass Model。OOP（Ordinary Object Pointer）指的是普通对象指针，而Klass用来描述对象实例的具体类型。\n\n每一个Java类，在被JVM加载的时候，JVM会给这个类创建一个`instanceKlass`，保存在方法区，用来在JVM层表示该Java类。当我们在Java代码中，使用new创建一个对象的时候，JVM会创建一个`instanceOopDesc`对象，这个对象中包含了对象头以及实例数据。\n\n[![20170615230126453](C:%5CUsers%5CPowerwenwh%5CDocuments%5CMyBlog%5Csource%5C_posts%5Cimgs%5CJava%E5%9F%BA%E7%A1%80%5C20170615230126453.jpeg)](http://www.hollischuang.com/wp-content/uploads/2018/06/20170615230126453.jpeg)\n\n这就是一个简单的Java对象的OOP-Klass模型，即Java对象模型。\n\n### 总结\n\n我们再来区分下JVM内存结构、 Java内存模型 以及 Java对象模型 三个概念。\n\nJVM内存结构，和Java虚拟机的运行时区域有关。 Java内存模型，和Java的并发编程有关。 Java对象模型，和Java对象在虚拟机中的表现形式有关。","tags":["Java"]},{"title":"一份Java面试题记录","url":"/2021/03/14/面试题一记录/","content":"\n### 一、int和Integer有什么区别？\n\n#### 1.Java两种数据类型分类\n\n为了编程的方便还是引入了基本数据类型，但是为了能够将这些基本数据类型当成对象操作，Java为每 一个基本数据类型都引入了对应的包装类型（wrapper class），int的包装类就是Integer，从Java 5开始引入了自动装箱/拆箱机制，使得二者可以相互转换。\n\n（1）基本数据类型，分为boolean、byte、int、char、long、short、double、float；\n（2）引用数据类型 ，分为数组、类、接口。\n\n```java\n基本数据类型: boolean，char，byte，short，int，long，float，double\n封装类类型：Boolean，Character，Byte，Short，Integer，Long，Float，Double\n```\n\n####  2.int与Integer的基本使用对比\n\n- Integer是int的包装类；int是基本数据类型；\n- Integer变量必须实例化后才能使用；int变量不需要；\n- Integer实际是对象的引用，指向此new的Integer对象；int是直接存储数据值 ；\n- Integer的默认值是null；int的默认值是0。\n\n#### int与Integer的深入对比\n\n（1）由于Integer变量实际上是对一个Integer对象的引用，所以两个通过new生成的Integer变量永远是不相等的（**因为new生成的是两个对象，其内存地址不同**）。\n\n（2）Integer变量和int变量比较时，只要两个变量的值是向等的，则结果为true（因为**包装类Integer和基本数据类型int比较时，java会自动拆包装为int，然后进行比较，实际上就变为两个int变量的比较**）\n\n（3）非new生成的Integer变量和new Integer()生成的变量比较时，结果为false。因为**非new生成的Integer变量指向的是静态常量池中cache数组中存储的指向了堆中的Integer对象，而new Integer()生成的变量指向堆中新建的对象，两者在内存中的对象引用（地址）不同**。\n\n```java\nInteger i = new Integer(100);\nInteger j = 100;\nSystem.out.print(i == j); //false\n```\n\n### 二、String和StringBuffer的区别\n\n#### 什么是StringBuffer？\n\n> 线程安全的可变字符序列。一个类似于 [`String`](https://tool.oschina.net/uploads/apidocs/jdk-zh/java/lang/String.html) 的字符串缓冲区，但不能修改。虽然在任意时间点上它都包含某种特定的字符序列，但通过某些方法调用可以改变该序列的长度和内容。\n\n> 可将字符串缓冲区安全地用于多个线程。可以在必要时对这些方法进行同步，因此任意特定实例上的所有操作就好像是以串行顺序发生的，该顺序与所涉及的每个线程进行的方法调用顺序一致。\n\n> `StringBuffer` 上的主要操作是 `append` 和 `insert` 方法，可重载这些方法，以接受任意类型的数据。每个方法都能有效地将给定的数据转换成字符串，然后将该字符串的字符追加或插入到字符串缓冲区中。`append` 方法始终将这些字符添加到缓冲区的末端；而 `insert` 方法则在指定的点添加字符。\n\n> 通常，如果 sb 引用 `StringBuilder` 的一个实例，则 `sb.append(x)` 和 `sb.insert(sb.length(), x)` 具有相同的效果。\n\n> 当发生与源序列有关的操作（如源序列中的追加或插入操作）时，该类只在执行此操作的字符串缓冲区上而不是在源上实现同步。\n\n> 从 JDK 5 开始，为该类补充了一个单个线程使用的等价类，即 [`StringBuilder`](https://tool.oschina.net/uploads/apidocs/jdk-zh/java/lang/StringBuilder.html)。与该类相比，通常应该优先使用 `StringBuilder` 类，因为它支持所有相同的操作，但由于它不执行同步，所以速度更快。\n\n> 将 `StringBuilder` 的实例用于多个线程是不安全的。如果需要这样的同步，则建议使用 [`StringBuffer`](https://tool.oschina.net/uploads/apidocs/jdk-zh/java/lang/StringBuffer.html)。\n\n> Java 语言提供对字符串串联符号（\"+\"）以及将其他对象转换为字符串的特殊支持。字符串串联是通过 `StringBuilder`（或 `StringBuffer`）类及其 `append` 方法实现的。字符串转换是通过 `toString` 方法实现的，该方法由 `Object` 类定义，并可被 Java 中的所有类继承。\n\n#### 总结\n\n简单地说，就是一个变量和常量的关系。StringBuffer对象的内容可以修改；而String对象一旦产生后就不可以被修改，重新赋值其实是两个对象。\nStringBuffer的内部实现方式和String不同，**StringBuffer在进行字符串处理时，不生成新的对象，在内存使用上要优于String类。**所以在实际使用时，如果经常需要对一个字符串进行修改，例如插入、删除等操作，使用StringBuffer要更加适合一些。\nString:在String类中没有用来改变已有字符串中的某个字符的方法，由于不能改变一个java字符串中的某个单独字符，所以在JDK文档中称String类的对象是不可改变的。然而，不可改变的字符串具有一个很大的优点:编译器可以把字符串设为共享的。 \nStringBuffer:**StringBuffer类属于一种辅助类，可预先分配指定长度的内存块建立一个字符串缓冲区。**这样使用StringBuffer类的append方法追加字符 比 String使用 + 操作符添加字符到一个已经存在的字符串后面有效率得多。因为使用 + 操作符每一次将字符添加到一个字符串中去时，字符串对象都需要寻找一个新的内存空间来容纳更大的字符串，这无凝是一个非常消耗时间的操作。添加多个字符也就意味着要一次又一次的对字符串重新分配内存。使用StringBuffer类就避免了这个问题。\n**StringBuffer是线程安全的**，在多线程程序中也可以很方便的进行使用，但是程序的执行效率相对来说就要稍微慢一些。\n\n1.  StringBuffer在进行字符串处理时，不生成新的对象，在内存使用优于String类。\n2. StringBuffer可预先分配指定长度的内存块建立一个字符串缓冲区。\n3. StringBuffer是线程安全的。\n\n### 三、运行时异常与一般异常有何区别\n\n#### 异常和错误（Exception&Error）\n\n![img](面试题一记录/Exception&Error.png)\n\nThrowable： 有两个重要的子类：**Exception（异常）和 Error（错误）**，二者都是 Java 异常处理的重要子类，各自都包含大量子类。\n\nError（错误）:\n\n　　是**程序无法处理的错误**，表示运行应用程序中较严重问题。**大多数错误与代码编写者执行的操作无关**，而表示代码运行时 JVM（Java 虚拟机）出现的问题。例如，Java虚拟机运行错误（Virtual MachineError），当 JVM 不再有继续执行操作所需的内存资源时，将出现 OutOfMemoryError。这些异常发生时，Java虚拟机（JVM）一般会选择线程终止。\n\nException（异常）:\n\n　　是**程序本身可以处理的异常。**\n\nException可以分为checked exceptions和unchecked exceptions：\n\n1. unchecked exceptions（**运行时异常**）都是RuntimeException类及其子类异常，就是我们在开发中测试功能时程序终止，控制台出现的异常，比如：\n\n- NullPointerException(空指针异常)、\n- IndexOutOfBoundsException(下标越界异常)\n- ClassCastException(类转换异常)\n- ArrayStoreException(数据存储异常，操作数组时类型不一致)\n- IO操作的BufferOverflowException异常\n\n2.  checked exceptions 非运行时异常 （编译异常）：是RuntimeException以外的异常，类型上都属于Exception类及其子类。从程序语法角度讲是必须进行处理的异常，如果不处理，程序就不能编译通过。如IOException、SQLException等以及用户自定义的Exception异常，一般情况下不自定义检查异常。\n   通俗的话说就是在写代码时出现红线，需要try catch或者throws时出现的异常。\n\n**1、运行时异常与一般异常有何异同？**\n\n异常表示程序运行过程中可能出现的非正常状态，运行时异常表示虚拟机的通常操作中可能遇到的异常，是一种常见运行错误。java编译器要求方法必须声明抛出可能发生的非运行时异常，但是并不要求必须声明抛出未被捕获的运行时异常。\n\n　　**理解：**\n\n　　<u>运行时异常，我们**可以不处理**。当出现这样的异常时，**总是由虚拟机接管**。</u>比如：我们从来没有人去处理过 NullPointerException 异常，它就是运行时异常，并且，这种异常还是最常见的异常之一。RuntimeException 体系包括**错误的类型转换、数组越界访问和试图访问空指针**等等。处理 RuntimeException 的原则是：假如出现 RuntimeException，那么一定是程序员的错误，例如，可以通过检查数组小标和数组边界来避免越界访问异常。\n\n　　一般异常：<u>定义方法时**必须声明**所有可能会抛出的checked exception</u>；在调用这个方法时，必须捕获它的checked exception，不然就得把它的exception传递下去；checked exception是从java.lang.Exception类衍生出来的。\n\n**2、error和exception有什么区别?**\n\n　　error 是**程序无法处理的错误**。比如说内存溢出。**不可能指望程序能处理这样的情况**。 **exception 表示一种设计或实现问题**。也就是说，它表示如果程序运行正常，从不会发生的情况。\n\n**3.Java中的异常处理机制的简单原理和应用**\n\n　　异常是指java程序运行时（非编译）所发生的非正常情况或错误，与现实生活中的事件很相似，现实生活中的事件可以包含事件发生的时间、地点、人物、情节等信息，可以用一个对象来表示，Java使用面向对象的方式来处理异常，它把程序中发生的每个异常也都分别封装到一个对象来表示的，该对象中包含有异常的信息。\n\n　　Java对异常进行了分类，不同类型的异常分别用不同的Java类来表示，所有异常的根类为java.lang.Throwable，Throwable下面又派生了两个子类：Error和Exception,Error表示应用程序本身无法克服和恢复的一种严重问题，程序只有死的份了，例如，说内存溢出和线程死锁等系统问题。Exception表示程序表示程序还能够克服和恢复的一种严重问题，其中又分为系统异常和普通异常，系统异常是软件本身缺陷所导致的问题，也就是软件开发人员考虑不周所导致的问题，软件使用者无法克服和恢复这种问题，但在这种问题下还可以让软件系统继续运行或者让软件死掉，例如，数组脚本越界（ArrayIndexOutOfBoundsException）、空指针异常（NullPointerException）、类转换异常（ClassCastException）；普通异常是运行环境的变化或异常所导致的问题，是用户能够克服的问题，例如，网络断线，硬盘空间不够，发生这样的异常后，程序不应该死掉。\n\n　　java为系统异常和普通异常提供了不同的解决方案，编译器强制普通异常必须try···catch处理或用throws声明继续抛给上层调用方法处理，所以普通异常也称为checked异常，而系统异常可以处理也可以不处理，所以，编译器不强制用try...catch处理或用throws声明，所以系统异常也称为unchecked异常。\n\n### 四、final和finally的区别\n\n1. final修饰符（关键字）。**被final修饰的类不能被其他子类继承。**因此一个类不能既被abstract声明，又被final声明。**将变量或方法声明为final，可以保证他们在使用的过程中不被修改。**被声明为final的变量必须在声明时给出变量的初始值，而在以后的引用中只能读取。**被final声明的方法也同样只能使用，即不能方法重写。**\n2. **finally是在异常处理时提供finally块来执行任何清除操作。不管有没有异常被抛出、捕获，finally块都会被执行。**try块中的内容是在无异常时执行到结束。catch块中的内容，是在try块内容发生catch所声明的异常时，跳转到catch块中执行。finally块则是无论异常是否发生，都会执行finally块的内容，所以在代码逻辑中有需要无论发生什么都必须执行的代码，就可以放在finally块中。\n\n### 五、abstract class和interface有什么区别\n\n#### 抽象类是什么？ \n\n本文中的抽象类表示的是一个抽象体\n\n- 在面向对象的概念中，所有的对象都是通过类来描绘的，但是并不是所有的类都是用来描绘对象的，**如果一个类中没有包含足够的信息来描绘一个具体的对象，这样的类就是抽象类。**\n- 抽象类的定义\n  是对一系列看上去不同，但是本质上相同的具体概念的抽象，往往用来表征我们在对问题进行分析、设计中得出的抽象概念\n- 它和具体类的核心区别是，抽象类不能创建对象(比如，不能使用new Shape())，而具体类可以。\n- 一个类在继承抽象类后，必须实现抽象类中定义的所有抽象方法，除非它自己也声明为抽象类。\n\n#### 为什么要有抽象类？\n\n- 待总结\n\n#### 抽象类（abstract class）\n\n- 定义：包含抽象方法的的类是abstract class\n\n  > 用abstract关键字修饰\n\n- 作用：abstractclass是为了把相同的东西提取出来,**即重用**\n\n- 使用abstractclass语法规定\n\n| 语法                                                       |                          备注                          |\n| :--------------------------------------------------------- | :----------------------------------------------------: |\n| 抽象类定义用abstract关键字修饰                             |                  要通过子类进行实例化                  |\n| 抽象类是不能被实例化的                                     |                  要通过子类进行实例化                  |\n| **子类必须重写父类的所有抽象方法**                         | 抽象方法：声明但却未被实现的方法，用abstract关键字修饰 |\n| 含有抽象方法的类一定是抽象类，但是抽象类不一定含有抽象方法 |                           无                           |\n| 抽象类是用来被它的子类继承的                               |                   **关键字extends**                    |\n\n#### Interface\n\n- 定义：比abstract class更加抽象，是一种特殊的abstract class\n\n  > 用Interface关键字修饰\n\n- 作用：Interface是为了把程序模块进行固化的契约,是**为了降低偶合**\n\n- 使用Interface的语法规定\n\n| 语法                                       |                      备注                       |\n| :----------------------------------------- | :---------------------------------------------: |\n| 接口定义用Interface关键字修饰              |                                                 |\n| 接口中的所有方法都是抽象的                 |       **可以用abstract修饰，也可以省略**        |\n| 接口中的方法**必须是用public修饰，或不写** |            但是不能被其他修饰符修饰             |\n| 接口中的属性**必须是全局常量**             |           **public static final修饰**           |\n| 抽象类是用来被它的子类实现的               |              **关键字Implements**               |\n| 接口不能被实例化                           |                       无                        |\n| **子类实现接口时需要实现接口中的所有方法** | 若有一个未不实现，该子类就是抽象类abstractclass |\n\n#### 二者的相同点\n\n都不能被实例化\n\n#### 二者的区别\n\n| 类型       |                        abstract class                        |                          Interface                           |\n| :--------- | :----------------------------------------------------------: | :----------------------------------------------------------: |\n| 定义       |                     abstract class关键字                     |                       Interface关键字                        |\n| 继承       |                 **子类只可以继承一个抽象类**                 |  **接口只可以继承接口（一个或多个）；子类可以实现多个接口**  |\n| 访问修饰符 | 抽象方法可以有**public**、**protected**和**default**这些修饰符 |    接口方法默认修饰符是**public**。你不可以使用其它修饰符    |\n| 方法实现   |         可定义构造方法，**可以有抽象方法和具体方法**         | 接口完全是抽象的，没构造方法，且方法都是抽象的，不存在方法的实现 |\n| 实现方式   | 子类使用**extends**关键字来继承抽象类。如果子类不是抽象类的话，它需要提供抽象类中所有声明的方法的实现 | 子类使用关键字**implements**来实现接口。它需要提供接口中所有声明的方法的实现 |\n| 作用       |               把相同的东西提取出来,**即重用**                |       为了把程序模块进行固化的契约,是**为了降低偶合**        |\n\n1. 抽象类中抽象方法的访问权限可以是public、protectedl；接口只能是public\n2. 抽象类中可以有非抽象方法；接口中的方法都是抽象方法\n3. 抽象类中可以定义普通成员变量；接口中不能定义普通成员变量\n4. 抽象类和接口都能定义静态成员变量，抽象类访问权限可以是任意的；但是接口只能是 public static final即常量\n5. 抽象类中可以有构造方法；接口中不能有构造方法\n6. 一个类只能实现一个抽象类；但一个类可以实现多个接口，接口可以继承多个接口\n   \n\n### 六、数据连接池的工作机制\n\n1. 初始化时建立由最大维持连接数决定数量的连接。\n2. 用户申请连接直到达到最大连接数的时候，请求将被添加到等待队列。\n3. 用户断开连接后，超过最大维持连接数的连接不会马上销毁，最大等待时间过后才会销毁\n4. 对数据库连接的管理能显著影响到整个应用程序的伸缩性和健壮性，影响到程序的性能指标。\n\n### 七、数组有无length()方法，String有无length()方法？\n\n数组有length属性，String有length()方法。\n\n### 八、try{}里有一个return语句，那么紧跟在try后的finally{}里的code什么时候执行？\n\n在return前执行\n\n### 九、当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底时值传递还是引用传递？\n\n是值传递。Java编程语言只有值传递参数。当一个对象实例作为一个参数被传递到方法中时，参数的值就是该对象的引用一个副本。指向同一个对象,对象的内容可以在被调用的方法中改变，但**对象的引用(不是引用的副本)是永远不会改变的**。\n\n### 十、当一个线程进入一个对象的一个synchronized方法后，其他线程是否可进入此对象的其他方法？\n\n不可以\n\n### 十一、集合类都有哪些？主要方法是？\n\n![Java集合类](面试题一记录/Java集合类.png))\n\n**Set**\n\nSet中不能包含重复的元素。\n\n**List接口**\n\nList是一个有序的集合，可以包含重复的元素。\n\n```java\nadd(E e),add(int index, E e),contains(Object o),addAll(Collection c),equals(Object o),get(int index),indexOf(Object o),\nisEmpty(),set(int index, E element),remove(int index),remove(Object o),size(),toArray()\n```\n\nArrayList：\n\n```java\nensureCapacity()\n```\n\nLinkList:\n\n除了实现 List 接口外，LinkedList 类还为在列表的开头及结尾 get、remove 和 insert 元素提供了统一的命名方法。这些操作允许将链接列表用作堆栈、队列或双端队列。\n\n```java\npeek(),peekFirst(),\tpeekLast(),//获取不移除\npoll(),pollFirst(),pollLast(),//获取并移除\npop(),push(E e)、、堆栈操作\n```\n\nVector：\n\nStack：\n\n通过五个操作对类 `Vector` 进行了扩展\n\n```java\nempty(),peek(),pop(),push(E item),search(Object o)\n```\n\n**queue**\n\n### 十二、线程的基本概念、基本状态及状态间的关系？\n\n**什么是线程**\n\n一个线程是<u>进程的一个顺序执行流</u>。同类的多个线程<u>共享一块内存空间和一组系统资源</u>，线程本身有一个供程序执行时的堆栈。线程在切换时负荷小，因此，线程也被称为轻负荷进程。一个进程中可以包含多个线程。\n\n**进程与线程的区别**\n\n一个进程至少有一个线程。线程的划分尺度小于进程，使得多线程程序的并发性高。另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。\n\n线程在执行过程中与进程的区别在于每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。\n\n从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操<u>作系统并没有将多个线程看做多个独立的应用来实现进程的调度和管理以及资源分配</u>。\n\n**并发原理**\n\n多个线程或进程”同时”运行只是我们感官上的一种表现。事实上进程和线程是并发运行的，OS的线程调度机制将时间划分为很多时间片段（时间片），尽可能均匀分配给正在运行的程序，获取CPU时间片的线程或进程得以被执行，其他则等待。而CPU则在这些进程或线程上来回切换运行。微观上所有进程和线程是走走停停的，宏观上都在运行，这种都运行的现象叫并发，但是不是绝对意义上的“同时发生”。\n\n**线程状态**\n\n**1.新建**\n\n用new语句创建的线程对象处于新建状态，此时它和其他java对象一样，仅被分配了内存。\n\n**2.等待**\n\n当线程在new之后，并且在调用start方法前，线程处于等待状态。\n\n**3.就绪**\n\n当一个线程对象创建后，其他线程调用它的start()方法，该线程就进入就绪状态。处于这个状态的线程<u>位于Java虚拟机的可运行池中</u>，等待cpu的使用权。\n\n**4.运行状态**\n\n处于这个状态的线程占用CPU，执行程序代码。在并发运行环境中，如果计算机只有一个CPU，那么任何时刻只会有一个线程处于这个状态。\n\n<u>只有处于就绪状态的线程才有机会转到运行状态。</u>\n\n**5.阻塞状态**\n\n阻塞状态是指线程因为某些原因放弃CPU，暂时停止运行。当线程处于阻塞状态时，Java虚拟机不会给线程分配CPU，直到线程重新进入就绪状态，它才会有机会获得运行状态。\n\n**阻塞状态分为三种:**\n\n1、等待阻塞:运行的线程执行wait（）方法，JVM会把该线程放入等待池中。\n\n2、同步阻塞:运行的线程在获取对象同步锁时，若该同步锁被别的线程占用，则JVM会把线程放入锁池中。\n\n3、其他阻塞:运行的线程执行Sleep（）方法，或者发出I/O请求时，JVM会把线程设为阻塞状态。当Sleep（）状态超时、或者I/O处理完毕时，线程重新转入就绪状态。\n\n**6.死亡状态**\n\n当线程执行完run()方法中的代码，或者遇到了未捕获的异常，就会退出run()方法，此时就进入死亡状态，该线程结束生命周期。\n\n### 十三、java写一段代码读取C:\\test.txt文件\n\n```java\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\n\npublic class Test {\n    public static void main(String[] args) throws IOException {\n        Path path = Paths.get(\"C:/test.txt\");\n        byte[] data = Files.readAllBytes(path);\n        String result = new String(data, \"utf-8\");\n        System.out.println(result);\n    }\n}\n```\n\n问题整理：\n\n1. 了解path类\n\n   **Path用于来表示文件路径和文件**。\n\n   创建path对象的常用方式,要注意异常的处理。\n\n   ```java\n   // 1.以当前路径创建Path对象\n   String filePath = \"E:\\\\tempCSDN\\\\Paths\";\n   Path path = Paths.get(filePath);\n    try {\n        if(!Files.exists(target2))\n            Files.createFile(target2);\n    } catch (IOException e) {\n        e.printStackTrace();\n   }\n   \n   ```\n\n   \n\n2. files类\n\n   files类被path类取代了\n\n3. String构造方法\n\n   ```java\n   public String(byte[] bytes, String charsetName)\n   ```\n\n   通过使用指定的charset解码指定的 byte 数组，构造一个新的 `String`。\n\n### 十四、List、Map、Set三个接口，存取元素时，各有什么特点？\n\nList是有序存储，\n\nMap时键值对存储，\n\nSet不允许重复元素\n\n### 十五、SpringMVC（或Struts）、Spring、Hibernate（或MyBatis）分别是什么，用它有什么好处？谈谈你的理解。\n\nJavaEE体系结构包括四层，从上到下分别是**应用层、Web层、业务层、持久层**。Struts和SpringMVC是Web层的框架，Spring是业务层的框架，Hibernate和MyBatis是持久层的框架。\n\n**为什么要使用SpringMVC？**\n\n很多应用程序的问题在于处理业务数据的对象和显示业务数据的视图之间存在紧密耦合，通常，更新业务对象的命令都是从视图本身发起的，使视图对任何业务对象更改都有高度敏感性。而且，当多个视图依赖于同一个业务对象时是没有灵活性的。\n\nSpringMVC是一种基于Java，实现了Web MVC设计模式，请求驱动类型的轻量级Web框架，即使用了MVC架构模式的思想，将Web层进行职责解耦。基于请求驱动指的就是使用请求-响应模型，框架的目的就是帮助我们简化开发，SpringMVC也是要简化我们日常Web开发。\n\n\n**MVC设计模式**\n\nMVC设计模式的任务是**将包含业务数据的模块与显示模块的视图解耦**。这是怎样发生的？在模型和视图之间引入重定向层可以解决问题。此重定向层是控制器，控制器将接收请求，执行更新模型的操作，然后通知视图关于模型更改的消息。\n\n**SpringMVC的核心架构：**\n\n![在这里插入图片描述](C:%5CUsers%5CPowerwenwh%5CDocuments%5CMyBlog%5Csource%5C_posts%5Cimgs%5C%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B8%80%E8%AE%B0%E5%BD%95%5C20190630145911981.png)\n\n具体流程：\n\n（1）首先浏览器发送请求——>DispatcherServlet，前端控制器收到请求后自己不进行处理，而是委托给其他的解析器进行处理，作为统一访问点，进行全局的流程控制；\n\n（2）DispatcherServlet——>HandlerMapping，处理器映射器将会把请求映射为HandlerExecutionChain对象（包含一个Handler处理器对象、多个HandlerInterceptor拦截器）对象；\n\n（3）DispatcherServlet——>HandlerAdapter，处理器适配器将会把处理器包装为适配器，从而支持多种类型的处理器，即适配器设计模式的应用，从而很容易支持很多类型的处理器；\n\n（4）HandlerAdapter——>调用处理器相应功能处理方法，并返回一个ModelAndView对象（包含模型数据、逻辑视图名）；\n\n（5）ModelAndView对象（Model部分是业务对象返回的模型数据，View部分为逻辑视图名）——> ViewResolver， 视图解析器将把逻辑视图名解析为具体的View；\n\n（6）View——>渲染，View会根据传进来的Model模型数据进行渲染，此处的Model实际是一个Map数据结构；\n\n（7）返回控制权给DispatcherServlet，由DispatcherServlet返回响应给用户，到此一个流程结束。\n\n\n==待总结==\n\n### 十六、sql语句\n\n### ![image-20210321153913927](C:%5CUsers%5CPowerwenwh%5CDocuments%5CMyBlog%5Csource%5C_posts%5Cimgs%5C%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B8%80%E8%AE%B0%E5%BD%95%5Cimage-20210321153913927.png)\n\n**思路：对除了自动编号外的字段进行分组即可筛选出不重复的数据**\n\n```sql\ncreate table tb_student_score(id int,sid int,name varchar2(20),kid int,kname varchar2(20),score int);\n \n--插入数据\ninsert into tb_student_score values(1,2018001,'张三',0001,'数学',69);\ninsert into tb_student_score values(2,2018002,'李四',0001,'数学',89);\ninsert into tb_student_score values(3,2018001,'张三',0001,'数学',69);\ninsert into tb_student_score values(4,2018002,'李四',0002,'语文',79);\ninsert into tb_student_score values(5,2018001,'张三',0002,'语文',80);\ninsert into tb_student_score values(6,2018002,'李四',0002,'语文',79);\n \ncommit;\n\n--查询数据\nselect * from tb_student_score;\nID    SID      NAME  KID    KNAME  SCORE\n1    2018001    张三    1    数学    69\n2    2018002    李四    1    数学    89\n3    2018001    张三    1    数学    69\n4    2018002    李四    2    语文    79\n5    2018001    张三    2    语文    80\n6    2018002    李四    2    语文    79\n\n--执行删除SQL语句\ndelete from tb_student_score\n where id not in (\n                   select min(id)\n                     from tb_student_score t\n                    group by t.sid, t.name, t.kid, t.kname, t.score\n                  );\ncommit;\n\n--查询数据\nselect * from tb_student_score;\nID    SID        NAME    KID    KNAME        SCORE\n1    2018001    张三    1          数学         69\n2    2018002    李四    1          数学         89\n4    2018002    李四    2          语文         79\n5    2018001    张三    2          语文         80\n```\n\n### 十七、一个叫team的表，里面只有一个字段name，一共有4条记录，分别是a，b，c，d，对应四个球队，现在四个球队进行比赛，用一条sql语句显示所有可能的比赛组合。\n\n```sql\nselect * from team a,team b where a.name>b.name;\n```\n\n由于需求为讲四个球队两两组合，故我们可以考虑相当于两张一样的表进行笛卡尔积多表查询,由上可看到两两组合的所有可能，但是结合实际，组合(a,a),(b,b)……在比赛中是不可能出现的，而(a,b)和(b,a)组合相当于一样。[故需要加where条件a.name](http://xn--wherea-m18i23wlm9bqoeo77it37a.name/)>b.name排除以上的情况发生\n\n### 十八、String的**[substring](https://tool.oschina.net/uploads/apidocs/jdk-zh/java/lang/String.html#substring(int))**(int beginIndex)、**[concat](https://tool.oschina.net/uploads/apidocs/jdk-zh/java/lang/String.html#concat(java.lang.String))**([String](https://tool.oschina.net/uploads/apidocs/jdk-zh/java/lang/String.html) str)方法。\n\n**[substring](https://tool.oschina.net/uploads/apidocs/jdk-zh/java/lang/String.html#substring(int))**(int beginIndex)\n\n返回一个新的字符串，它是此字符串的一个子字符串。该子字符串从指定索引处的字符开始，直到此字符串末尾。\n\n示例：\n\n> ```java\n>  \"unhappy\".substring(2) returns \"happy\"\n>  \"Harbison\".substring(3) returns \"bison\"\n>  \"emptiness\".substring(9) returns \"\" (an empty string)\n> ```\n\n**[concat](https://tool.oschina.net/uploads/apidocs/jdk-zh/java/lang/String.html#concat(java.lang.String))**([String](https://tool.oschina.net/uploads/apidocs/jdk-zh/java/lang/String.html) str)\n\n将指定字符串连接到此字符串的结尾。\n\n如果参数字符串的长度为 `0`，则返回此 `String` 对象。否则，创建一个新的 `String` 对象，用来表示由此 `String` 对象表示的字符序列和参数字符串表示的字符序列连接而成的字符序列。\n\n示例：\n\n> ```java\n>  \"cares\".concat(\"s\") returns \"caress\"\n>  \"to\".concat(\"get\").concat(\"her\") returns \"together\"\n> ```\n\n### 十九、Javascript相关\n\n以下哪一条Javascript语句会产生运行错误？\n\n- ```\n  var obj=( );//错误\n  ```\n\n- ```\n  var obj=[ ];//声明obj为数组对象\n  ```\n\n- ```\n  var obj={ };//声明obj为对象\n  ```\n\n- ```\n  var obj=/ /;//声明obj为正则对象\n  ```\n\n\n\nfoo对象有att属性，那么获取att属性的值，以下哪些做法是可以的：（javascript）\n\njavascrit获取对象属性的方法有两种：分别是采用'.'和[]。所以ADE都正确\n\n- ```\n  foo[\"att\"]\n  ```\n\n- ```\n  foo(\"att\")\n  ```\n\n- ```\n  foo{\"att\"}\n  ```\n\n- ```\n  foo.att\n  ```\n\n- ```\n  foo[[\"a\",\"t\",\"t\"].join(\"\")]\n  ```\n\n### 二十、html相关\n\n在不指定特殊属性的情况下，以下标签可以手动输入文本的是B\n\n`<textarea>` 标签定义多行的文本输入控件。\n\n`<input type=\"hidden\"/>`  \n`<textarea></textarea>`  \n`<div></div>`  \n`<a></a>`  \n\n\ntable标签\n\n**定义和用法**\n\n简单的 HTML 表格由 table 元素以及一个或多个 tr、th 或 td 元素组成。\n\n**tr 元素定义表格行，th 元素定义表头，td 元素定义表格单元。**\n\n更复杂的 HTML 表格也可能包括 caption、col、colgroup、thead、tfoot 以及 tbody 元素。\n\n```html\n<p>每个表格由 table 标签开始。</p>\n<p>每个表格行由 tr 标签开始。</p>\n<p>每个表格数据由 td 标签开始。</p>\n\n<h4>一列：</h4>\n<table border=\"1\">//规定表格边框的宽度。\n<tr>\n  <td>100</td>\n</tr>\n</table>\n\n<h4>一行三列：</h4>\n<table border=\"1\">\n<tr>\n  <td>100</td>\n  <td>200</td>\n  <td>300</td>\n</tr>\n</table>\n\n<h4>两行三列：</h4>\n<table border=\"1\">\n<tr>\n  <td>100</td>\n  <td>200</td>\n  <td>300</td>\n</tr>\n<tr>\n  <td>400</td>\n  <td>500</td>\n  <td>600</td>\n</tr>\n</table>\n```\n\n![image-20210325101611783](面试题一记录/效果.png))\n\n### 二十一、请你根据任意一个外卖app的使用经历，画出你所理解的外卖的流程。请画出主要的环节，以及每个环节涉及的角色。（比如用户、商家等）\n\n![preview](面试题一记录/外卖软件流程.jpg))\n\n二十二、图形题解题技巧\n\n1. 三角形或圆心类：找周围的数字与圆心数字关系\n\n   例子：![image](面试题一记录/eg.png)))\n\n2. 图形题目：观察点的数目，线的数目（直线、曲线、线头），笔画，角（有无，角度，数目），面（封闭区域数，部分数），对称（对称轴）","tags":["Java"]},{"title":"Java中布尔类型运算符的使用","url":"/2021/03/07/Java中布尔类型运算符的使用/","content":"\n## &=，|=与^=的使用\n\n1.&=\ntrue &= true ==> true\ntrue &= false ==> false\nfalse &= true ==> false\nfalse &= false ==> false\n\n2.|=\ntrue |= true ==> true\ntrue |= false ==> true\nfalse |= true ==> true\nfalse |= false ==> false\n\n3.^=(异或)\n相同为假，不同为真\n(男性和女性能生出孩子，否则就不行。)\ntrue ^= true ==> false\ntrue ^= false ==> true\nfalse ^= true ==> true\nfalse ^= false ==> false","tags":["Java"]},{"title":"正则表达式匹配","url":"/2021/03/07/正则表达式匹配/","content":"\n## 正则表达式匹配\n\n请实现一个函数用来匹配包含'. '和'※'的正则表达式。模式中的字符'.'表示任意一个字符，而\"※\"表示它前面的字符可以出现任意次（含0次）。在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串\"aaa\"与模式\"a.a\"和\"ab*ac*a\"匹配，但与\"aa.a\"和\"ab*a\"均不匹配。\n\n## 解题\n\n本题的思路选用**动态规划**的思路解题，构造动态规划矩阵来推导结果。对我来说难点在如何分，分几种情况考虑。并且※可以代表没有和无数次，用一般的方法很难用编程语言描述。\n\n> 假设主串为 A，模式串为 B 从最后一步出发，需要关注最后进来的字符。假设 A 的长度为 n ，B 的长度为 m ，关注正则表达式 B 的最后一个字符是谁，它有三种可能，正常字符、∗ 和 .（点），那针对这三种情况讨论即可，如下：\n>\n> 1. 如果 B 的最后一个字符是正常字符，那就是看 A[n-1] 是否等于 B[m-1]，相等则看 A_{0..n-2}与 B_{0..m-2}，不等则是不能匹配，这就是子问题。\n> 2. 如果 B 的最后一个字符是.，它能匹配任意字符，直接看 A_{0..n-2}与 B_{0..m-2}\n>\n> 3. 如果 B 的最后一个字符是∗它代表 B[m-2]=c 可以重复0次或多次，它们是一个整体 c∗4\n>\n>    + 情况一：A[n-1] 是 0 个 c，B 最后两个字符废了，能否匹配取决于 A_{0..n-1}和 B_{0..m-3}是否匹配\n>    + 情况二：A[n-1]是多个 c 中的最后一个（这种情况必须 A[n-1]=c或者 c='.'），所以 A 匹配完往前挪一个，B 继续匹配，因为可以匹配多个，继续看 A_{0..n-2}和 B_{0..m-1}是否匹配。\n>\n>    ### 转移方程\n>\n>    f[i]\\[j\\] 代表 A 的前 i 个和 B 的前 j 个能否匹配\n>\n>    对于前面两个情况，可以合并成一种情况 f[i]\\[j\\] = f\\[i-1][j-1]\n>\n>    对于第三种情况，对于 c∗ 分为看和不看两种情况\n>\n>    不看：直接砍掉正则串的后面两个， f[i]\\[j] = f[i]\\[j-2]\n>    看：正则串不动，主串前移一个，f[i]\\[j] = f[i-1]\\[j]\n>\n>    ### 初始条件\n>\n>    特判：需要考虑空串空正则\n>\n>    空串和空正则是匹配的，f[0]\\[0] = true\n>    空串和非空正则，不能直接定义 true 和 false，必须要计算出来。（比如A= '' '' ,B=a∗b∗c）\n>    非空串和空正则必不匹配，f[1]\\[0]=...=f[n]\\[0]=false\n>    非空串和非空正则，那肯定是需要计算的了。\n>    大体上可以分为空正则和非空正则两种，空正则也是比较好处理的，对非空正则我们肯定需要计算，非空正则的三种情况，前面两种可以合并到一起讨论，第三种情况是单独一种，那么也就是分为当前位置是 ∗ 和不是 ∗ 两种情况了。\n>\n>    ### 结果\n>\n>    我们开数组要开 n+1 ，这样对于空串的处理十分方便。结果就是 f[n]\\[m]\n\n看完解题思路，觉得这道题的关键是理解和分析出转移方程，也是动态规划的核心。细节方面则是需要考虑空串和空正则。\n\n```java\nclass Solution {\n    public boolean isMatch(String A, String B) {\n        int n = A.length();\n        int m = B.length();\n        boolean[][] f = new boolean[n + 1][m + 1];\n\n        for (int i = 0; i <= n; i++) {\n            for (int j = 0; j <= m; j++) {\n                //分成空正则和非空正则两种\n                if (j == 0) {\n                    f[i][j] = i == 0;\n                } else {\n                    //非空正则分为两种情况 * 和 非*\n                    if (B.charAt(j - 1) != '*') {\n                        if (i > 0 && (A.charAt(i - 1) == B.charAt(j - 1) || B.charAt(j - 1) == '.')) {\n                            f[i][j] = f[i - 1][j - 1];\n                        }\n                    } else {\n                        //碰到 * 了，分为看和不看两种情况\n                        //不看\n                        if (j >= 2) {\n                            f[i][j] |= f[i][j - 2];\n                        }\n                        //看\n                        if (i >= 1 && j >= 2 && (A.charAt(i - 1) == B.charAt(j - 2) || B.charAt(j - 2) == '.')) {\n                            f[i][j] |= f[i - 1][j];\n                        }\n                    }\n                }\n            }\n        }\n        return f[n][m];\n    }\n}\n\n```\n\n","tags":["Leetcode"]},{"title":"Java中的除法保留全部小数位","url":"/2021/03/03/Java中的除法保留全部小数位/","content":"\n情景展示\n\n```java\ndouble a = 1/10;\nSystem.out.println(d);//0.0\n```\n\n用int类型接受也可以\n\n```java\nint a = 1/10;\nSystem.out.println(d);//0\n```\n\n没有报错，因为在Java中整数之间 的除法运算，不管小数位有几位，小数是几，都会舍弃，只返回整数位数字。\n\n之所以用double类型接受也可以，是因为double类型的取值要大于int类型，属于向上类型转换，Java会自动转换。使用float或long类型接受也没有问题。\n\n在Java中，运算结果由被运算数的最高数据类型决定。所以想要得到完整的运算结果只需要将其中一个数据类型转换为double类型或float类型，而不是只改变接受运算结果的数据类型。 ","tags":["Java"]},{"title":"Java中的接口","url":"/2021/02/28/Java接口/","content":"\n## Java接口\n\n### 1、几个问题\n\n1. 为什么不直接在类里面写对应的方法, 而要多写1个接口(或抽象类)?\n\n2. 既然接口跟抽象类差不多, 什么情况下要用接口而不是抽象类.\n\n3. 为什么interface叫做接口呢? 跟一般范畴的接口例如usb接口, 显卡接口有什么联系呢?\n\n### 2、**接口是不可以被实例化, 但是接口引用可以指向1个实现该接口的对象.**\n\n假如类A impletments 了接口B\n\n那么下面是合法的:\n\n`B b = new A();`\n\n也可以把A的对象强制转换为 接口B的对象\n\n`A a = new A90;\nB b = (B)a;`\n\n这个特性是下面内容的前提.\n\n### 3、接口(或抽象类)的存在是为了多态的实现.\n\n详细代码用抽象举1个例子：\n\n先定义几个类,\n\n动物(Animal) 抽象类\n\n爬行动物(Reptile) 抽象类  继承动物类\n\n哺乳动物(Mammal) 抽象类 继承动物类\n\n山羊(Goat) 继承哺乳动物类\n老虎(Tiger)  继承哺乳动物类\n兔子(Rabbit) 继承哺乳动物类\n蛇(Snake)   继承爬行动物类\n\n农夫(Farmer)   没有继承任何类 但是农夫可以给Animal喂水(依赖关系)\n\n#### 3.1 Animal类\n\n这个是抽象类, 显示也没有\"动物\" 这种实体\n\n类里面包含3个抽象方法.\n1. 静态方法getName()\n\n2. 移动方法move(), 因为动物都能移动.  但是各种动物有不同的移动方法, 例如老虎和山羊会跑着移动, 兔子跳着移动, 蛇会爬着移动.\n\n<u>作为抽象基类, 我们不关心继承的实体类是如何移动的, 所以移动方法move()是1个抽象方法.  这个就是多态的思想.</u>\n\n\n3. 喝水方法drink(), 同样, 各种动物有各种饮水方法. 这个也是抽象方法.\n\n```java\n    \nabstract class Animal{\n    public abstract String getName();\n    public abstract void move(String destination);\n    public abstract void drink();\n}\n```\n\n#### 3.2 Mammal类\n\n这个是继承动物类的哺乳动物类, 后面的老虎山羊等都继承自这个类.\nMammal类自然继承了Animal类的3个抽象方法, 实体类不再用写其他代码.\n\n`abstract class Mammal extends Animal{}`\n\n#### 3.3 Reptile类\n\n这个是代表爬行动物的抽象类, 同上, 都是继承自Animal类.\n`abstract class Reptile extends Animal{}`\n\n3.4 Tiger类\n<u>老虎类就是1个实体类, 所以它必须重写所有继承自超类的抽象方法</u>, 至于那些方法如何重写, 则取决于老虎类本身.\n\n```java\nclass Tiger extends Mammal{\n    private static String name = \"Tiger\";\n    public String getName(){\n        return this.name;\n    }\n \n    public void move(String destination){\n        System.out.println(\"Goat moved to \" + destination + \".\");\n    }\n \n    public void drink(){\n        System.out.println(\"Goat lower it's head and drink.\");\n    }\n}\n```\n\n\n\n\n如上, 老虎的移动方法很普通, 低头喝水.\n\n#### 3.5 Goat类 和 Rabbit类\n\n这个两个类与Tiger类似, 它们都继承自Mammal这个类.\n\n```java\nclass Goat extends Mammal{\n    private static String name = \"Goat\";\n    public String getName(){\n        return this.name;\n    }\n \n    public void move(String destination){\n        System.out.println(\"Goat moved to \" + destination + \".\");\n    }\n \n    public void drink(){\n        System.out.println(\"Goat lower it's head and drink.\");\n    }\n}\n```\n\n兔子: 喝水方法有点区别\n\n```java\nclass Rabbit extends Mammal{\n    private static String name = \"Rabbit\";\n    public String getName(){\n        return this.name;\n    }\n \n    public void move(String destination){\n        System.out.println(\"Rabbit moved to \" + destination + \".\");\n    }\n \n    public void drink(){\n        System.out.println(\"Rabbit put out it's tongue and drink.\");\n    }\n}\n```\n\n\n\n#### 3.6 Snake类\n\n蛇类继承自Reptile(爬行动物)\n移动方法和喝水方法都跟其他3动物有点区别.\n\n```java\nclass Snake extends Reptile{\n    private static String name = \"Snake\";\n    public String getName(){\n        return this.name;\n    }\n \n    public void move(String destination){\n        System.out.println(\"Snake crawled to \" + destination + \".\");\n    } \n \n    public void drink(){\n        System.out.println(\"Snake dived into water and drink.\");\n    }\n}\n```\n\n#### 3.7 Farmer 类\n\nFarmer类不属于 Animal类族, 但是Farmer农夫可以给各种动物, 喂水.\n\nFarmer类有2个关键方法, 一个是\n`bringWater(String destination)`    --> 把水带到某个地点\n\n\n另1个就是`feedWater()`了, \n\nfeedWater这个方法分为三步:\n\n首先是农夫带水到饲养室,(`bringWater())`\n\n接着被喂水动物走到饲养室,(`move()`)\n\n接着动物喝水(`drink()`)\n\nFarmer可以给老虎喂水, 可以给山羊喂水, 还可以给蛇喂水, 那么feedWater()里的参数类型到底是老虎,山羊还是蛇呢.\n\n\n实际上<u>因为老虎,山羊, 蛇都继承自Animal这个类, 所以feedWater里的参数类型设为Animal就可以了.</u>\n\nFarmer类首先调用bringWater(\"饲养室\"),\n至于<u>这个动物是如何走到饲养室和如何喝水的, Farmer类则不用关心.</u>\n\n<u>因为执行时, Animal超类会根据引用指向的对象类型不同 而 指向不同的被重写的方法.  这个就是多态的意义.</u>\n\n\n代码如下:\n\n```java\nclass Farmer{\n    public void bringWater(String destination){\n        System.out.println(\"Farmer bring water to \" + destination + \".\");\n    }\n \n    public void feedWater(Animal a){ // polymorphism多态性\n        this.bringWater(\"Feeding Room\");\n        a.move(\"Feeding Room\");\n        a.drink();\n    }\n}\n```\n\n\n\n#### 3.7 执行农夫喂水的代码.\n\n下面的代码是1个农夫依次喂水给一只老虎, 一只羊, 以及一条蛇\n\n```java\npublic static void f(){\n        Farmer fm = new Farmer();\n        Snake sn = new Snake();\n        Goat gt = new Goat();\n        Tiger tg = new Tiger();\n \n        fm.feedWater(sn);\n        fm.feedWater(gt);\n        fm.feedWater(tg);\n    }\n```\n\n\n\n#### 3.8总结\n\n农夫只负责带水过去制定地点, 而不必关心老虎, 蛇, 山羊它们是如何过来的. 它们如何喝水. 这些农夫都不必关心.\n只需要调用同1个方法`feedWater()`.  \n\n不使用多态的后果:\n而如果老虎, 蛇, 山羊的`drink() `方法不是重写自同1个抽象方法的话, 多态就不能实现.\n<u>农夫类就可能要根据参数类型的不同而重载很多个 ` feedWater()`方法了.</u>\n\n而且每增加1个类(例如 狮子Lion)\n\n就需要在农夫类里增加1个feedWater的重载方法` feedWater(Lion l)`...\n\n而接口跟抽象类类似,\n这个就回答了本文第一个问题.\n1.为什么不直接在类里面写对应的方法,  而要多写1个接口(或抽象类)?\n\n### 4、抽象类解决不了的问题.\n\n既然抽象类很好地实现了多态性, 那么什么情况下用接口会更加好呢?\n\n\n对于上面的例子, 我们加一点需求.\n\n\nFarmer 农夫多了1个技能, 就是给另1个动物喂兔子(囧).\n\n`BringAnimal(Animal a, String destination)  ` 把兔子带到某个地点...\n\n`feedAnimal(Animal ht, Animal a) ` 把动物a丢给动物ht\n\n注意农夫并没有把兔子宰了, 而是把小动物(a)丢给另1个被喂食的动物(ht).\n\n那么问题来了, 那个动物必须有捕猎这个技能.  也就是我们要给被喂食的动物加上1个方法(捕猎) `hunt(Animal a)`.\n\n\n但是现实上不是所有动物都有捕猎这个技能的, 所以我们不应该把`hunt(Animal a)`方法加在Goat类和Rabbit类里,  只加在Tiger类和Snake类里.\n\n\n而且老虎跟蛇的捕猎方法也不一样, 则表明<u>hunt()的方法体在Tiger类里和Snake类里是不一样的.</u>\n\n\n下面有3个方案.\n\n1. 分别在Tiger类里和Snake类里加上Hunt() 方法.  其它类(例如Goat) 不加.\n\n2. 在基类Animal里加上Hunt()抽象方法. 在Tiger里和Snake里重写这个Hunt() 方法.\n\n3. 添加肉食性动物这个抽象类.   \n\n\n先来说第1种方案.\n\n这种情况下, Tiger里的`Hunt(Animal a)`方法与 Snake里的`Hunt(Animal a)`方法毫无关联. 也就是说不能利用多态性.\n\n导致Farm类里的`feedAnimal()`方法需要分别为Tiger 与 Snake类重载. 否决.\n\n\n第2种方案:\n\n如果在抽象类Animal里加上`Hunt()`方法, 则所有它的非抽象派生类都要重写实现这个方法, 包括 Goat类和 Rabbit类.\n\n这是不合理的, 因为Goat类根本没必要用到Hunt()方法, 造成了资源(内存)浪费.\n\n\n第3种方案:\n加入我们在哺乳类动物下做个分叉, 加上肉食性哺乳类动物, 非肉食性哺乳动物这两个抽象类?\n\n\n首先,\n肉食性这种分叉并不准确, 例如很多腐蚀性动物不会捕猎, 但是它们是肉食性.\n\n其次\n\n这种方案会另类族图越来越复杂, 假如以后再需要辨别能否飞的动物呢, 增加飞翔 `fly()`这个方法呢? 是不是还要分叉?\n\n再次,\n\n很现实的问题, 在项目中, 你很可能没机会修改上层的类代码, 因为它们是用Jar包发布的, 或者你没有修改权限.\n\n\n这种情况下就需要用到接口了.\n\n### 5、接口与多态 以及 多继承性.\n\n上面的问题, 抽象类解决不了, 根本问题是Java的类不能多继承.\n\n因为Tiger类继承了动物Animal类的特性(例如 move() 和 drink()) , 但是严格上来将 捕猎(hunt())并不算是动物的特性之一. 有些植物, 单细胞生物也会捕猎的.\n\n\n所以Tiger要从别的地方来继承Hunt()这个方法.  接口就发挥作用了.\n\n#### 5.1 Huntable接口\n\n我们增加1个Huntable接口.\n\n接口里有1个方法hunt(Animal a), 就是捕捉动物, 至于怎样捕捉则由实现接口的类自己决定.\n\n```java\ninterface Huntable{\n    public void hunt(Animal a);\n}\n```\n\n#### 5.2 Tiger 类\n\n既然定义了1个Huntable(可以捕猎的)接口.\n\nTiger类就要实现这个接口并重写接口里hunt()方法.\n\n```java\nclass Tiger extends Mammal implements Huntable{\n    private static String name = \"Tiger\";\n    public String getName(){\n        return this.name;\n    }\n \n    public void move(String destination){\n        System.out.println(\"Goat moved to \" + destination + \".\");\n    }\n \n    public void drink(){\n        System.out.println(\"Goat lower it's head and drink.\");\n    }\n \n    public void hunt(Animal a){\n        System.out.println(\"Tiger catched \" + a.getName() + \" and eated it\");\n    }\n    \n}\n```\n\n#### 5.3 Snake类\n\n同样:\n\n```java\nclass Snake extends Reptile implements Huntable{\n    private static String name = \"Snake\";\n    public String getName(){\n        return this.name;\n    }\n \n    public void move(String destination){\n        System.out.println(\"Snake crawled to \" + destination + \".\");\n    } \n \n    public void drink(){\n        System.out.println(\"Snake dived into water and drink.\");\n    }\n \n    public void hunt(Animal a){\n        System.out.println(\"Snake coiled \" + a.getName() + \" and eated it\");\n    }\n}\n```\n\n可见同样实现接口的`hunt()`方法, 但是蛇与老虎的捕猎方法是有区别的.\n\n#### 5.4 Farmer类\n\n这样的话. Farmer类里的`feedAnimal(Animal ht, Animal a)`就可以实现多态了.\n\n```java\nclass Farmer{\n    public void bringWater(String destination){\n        System.out.println(\"Farmer bring water to \" + destination + \".\");\n    }\n    \n    public void bringAnimal(Animal a,String destination){\n        System.out.println(\"Farmer bring \" + a.getName() + \" to \" + destination + \".\");\n    }\n \n    public void feedWater(Animal a){\n        this.bringWater(\"Feeding Room\");\n        a.move(\"Feeding Room\");\n        a.drink();\n    }\n \n    public void feedAnimal(Animal ht , Animal a){\n        this.bringAnimal(a,\"Feeding Room\");\n        ht.move(\"Feeding Room\");\n        Huntable hab = (Huntable)ht;\n        hab.hunt(a);\n    }\n \n}\n```\n\n关键是这一句\n`Huntable hab = (Huntable)ht;`\n本文一开始讲过了, 接口的引用可以指向实现该接口的对象.\n当然, 如果把Goat对象传入Farmer的feedAnimal()里就会有异常, 因为Goat类没有实现该接口. 上面那个代码执行失败.\n\n\n如果要避免上面的问题.\n\n可以修改feedAnimal方法:\n\n```java\n  public void feedAnimal(Huntable hab, Animal a){\n        this.bringAnimal(a,\"Feeding Room\");\n        Animal ht = (Animal)hab;\n        ht.move(\"Feeding Room\");\n        hab.hunt(a);\n    }\n```\n\n这样的话, 传入的对象就必须是实现了Huntable的对象, 如果把Goat放入就会编译报错.\n\n但是里面一样有一句强制转换\n\n`Animal ht = (Animal)hab`\n\n反而更加不安全, 因为实现的Huntable的接口的类不一定都是Animal的派生类.\n相反, 接口的出现就是鼓励多种不同的类实现同样的功能(方法)\n\n\n例如,假如一个机械类也可以实现这个接口, 那么那个机械就可以帮忙打猎了(囧)\n\n1个植物类(例如捕蝇草),实现这个接口, 也可以捕猎苍蝇了.\n\n\n也就是说, <u>接口不会限制实现接口的类的类型.</u>\n\n<u>这样, Tiger类与Snake类不但继承了Animal的方法, 还继承(实现)了接口Huntable的方法, 一定程度上弥补java的class不支持多继承的特点.</u>\n\n### 6、接口上应用泛型.\n\n上面的Huntable里还是有点限制的,\n\n就是它里面的hunt()方法的参数是 Animal a, 也就是说这个这个接口只能用于捕猎动物.\n\n\n但是在java的世界里, 接口里的方法(行为)大多数是与类的类型无关的.\n\n也就是说, Huntable接口里的hunt()方法里不单只可以捕猎动物, 还可以捕猎其他东西(例如 捕猎植物... 敌方机械等)\n\n#### 6.1 Huntable接口\n\n首先要在Huntable接口上添加泛型标志:<T>\n\n```java\ninterface Huntable<T>{\n    public void hunt(T o);\n}\n```\n\n然后里面的hunt()的参数的类型就写成T, 表示hunt()方法可以接受多种参数, 取决于实现接口的类.\n\n#### 6.2 Tiger类(和Snake类)\n\n同样, 定义tiger类时必须加上接口的泛型标志<Animal>, 表示要把接口应用在Animal这种类型.\n\n```java\nclass Tiger extends Mammal implements Huntable<Animal>{\n    private static String name = \"Tiger\";\n    public String getName(){\n        return this.name;\n    }\n \n    public void move(String destination){\n        System.out.println(\"Goat moved to \" + destination + \".\");\n    }\n \n    public void drink(){\n        System.out.println(\"Goat lower it's head and drink.\");\n    }\n \n    public void hunt(Animal a){\n        System.out.println(\"Tiger catched \" + a.getName() + \" and eated it\");\n    }\n \n}\n```\n\n这样, 在里面hunt()参数就可以指明类型Animal了, 表示老虎虽然有捕猎这个行为, 但是只能捕猎动物.\n\n### 7、什么情况下应该使用接口而不用抽象类.\n\n好了, 回到本文最重要的一个问题.\n\n做个总结\n\n1. 需要实现多态\n\n2. 要实现的方法(功能)不是当前类族的必要(属性).\n\n3. 要为不同类族的多个类实现同样的方法(功能).\n\n#### 7.1 需要实现多态\n\n很明显, 接口其中一个存在意义就是为了实现多态. 这里不多说了.\n\n而抽象类(继承) 也可以实现多态\n\n#### 7.2. 要实现的方法(功能)不是当前类族的必要(属性).\n\n上面的例子就表明, 捕猎这个方法不是动物这个类必须的,\n在动物的派生类中, 有些类需要, 有些不需要.  \n\n如果把捕猎方法写在动物超类里面是不合理的浪费资源.\n\n\n所以把捕猎这个方法封装成1个接口, 让派生类自己去选择实现!\n\n#### 7.3  . 要为不同类族的多个类实现同样的方法(功能).\n\n上面说过了, 其实不是只有Animal类的派生类才可以实现Huntable接口.\n如果Farmer实现了这个接口, 那么农夫自己就可以去捕猎动物了...\n\n\n我们拿另个常用的接口Comparable来做例子.\n\n\n这个接口是应用了泛型,\n\n首先, 比较(CompareTo) 这种行为很难界定适用的类族, 实际上, 几乎所有的类都可以比较.\n\n比如 数字类可以比较大小,   人类可以比较财富,  动物可以比较体重等.\n\n\n所以各种类都可以实现这个比较接口.\n\n一旦实现了这个比较接口. 就可以开启另1个隐藏技能:\n\n就是可以利用Arrays.sort()来进行排序了.\n\n就如实现了捕猎的动物,\n可以被农夫Farmer喂兔子一样...\n\n#### 8、接口为什么会被叫做接口, 跟真正的接口例如usb接口有联系吗?\n\n对啊, 为什么叫接口, 而不叫插件(plugin)呢,  貌似java接口的功能更类似1个插件啊.\n\n插上某个插件, 就有某个功能啊.\n\n\n实际上, 插件与接口是相辅相成的.\n\n\n例如有1个外部存储插件(U盘), 也需要使用设备具有usb接口才能使用啊.\n\n\n再举个具体的例子.\n\n个人电脑是由大型机发展而来的\n\n\n大型机->小型机->微机(PC)\n\n\n而笔记本是继承自微机的.\n\n\n那么问题来了.\n\n\n对于, 计算机的CPU/内存/主板/独显/光驱/打印机 有很多功能(方法/行为), 那么到底哪些东西是继承, 哪些东西是接口呢.\n\n\n首先,  cpu/内存/主板 是从大型机开始都必备的, 任何计算机都不能把它们去掉.\n所以, 这三样东西是继承的, 也就说笔记本的cpu/内存/主板是继承自微机(PC)的\n\n\n但是/光驱/呢,    现实上很多超薄笔记本不需要光驱的功能.\n\n如果光驱做成继承, 那么笔记本就必须具有光驱, 然后屏蔽光驱功能, 那么这台笔记本还能做到超薄吗? 浪费了资源.\n\n\n所以光驱,打印机这些东西就应该做成插件.\n\n\n然后, 在笔记本上做1个可以插光驱和打印机的接口(usb接口).\n\n也就是说, PC的派生类, 有些(笔记本)可以不实现这个接口, 有些(台式机)可以实现这个接口,只需要把光驱插到这个接口上.\n\n\n至于光驱是如何实现的,\n\n例如一些pc派生类选择实现蓝光光驱, 有些选择刻录机.  但是usb接口本身并不关心. 取决与实现接口的类.\n\n这个就是现实意义上的多态性啊.\n————————————————\n版权声明：本文为CSDN博主「nvd11」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。\n原文链接：https://blog.csdn.net/nvd11/article/details/41129935","tags":["Java"]},{"title":"Springboot","url":"/2020/12/28/Springboot/","content":"# **Springboot**\n\n## 一、静态资源访问\n\n### 1、静态资源目录\n\n只要静态资源放在类路径下： called `/static` (or `/public` or `/resources` or `/META-INF/resources`\n\n访问 ： 当前项目根路径/ + 静态资源名 （直接访问）\n\n\n\n原理： 静态映射/**。\n\n请求进来，先去找Controller看能不能处理。不能处理的所有请求又都交给静态资源处理器。静态资源也找不到则响应404页面\n\n\n\n改变默认的静态资源路径\n\n```yml\nspring:\n  mvc:\n    static-path-pattern: /res/**\n\n  resources:\n    static-locations: [classpath:/haha/]\n```\n\n### 2、静态资源访问前缀\n\n默认无前缀\n\n```yml\nspring:\n  mvc:\n    static-path-pattern: /res/**\n```\n\n当前项目 + static-path-pattern + 静态资源名 = 静态资源文件夹下找\n\n### 3、欢迎页支持\n\n- 静态资源路径下  index.html\n\n- - 可以配置静态资源路径\n  - 但是不可以配置静态资源的访问前缀。否则导致 index.html不能被默认访问\n\n- ```yml\n  spring:\n  #  mvc:\n  #    static-path-pattern: /res/**   这个会导致welcome page功能失效\n  \n    resources:\n      static-locations: [classpath:/haha/]\n  ```\n\n### 4、自定义 `Favicon`\n\nfavicon.ico 放在静态资源目录下即可。\n\n```yml\nspring:\n#  mvc:\n#    static-path-pattern: /res/**   这个会导致 Favicon 功能失效\n```\n\n## 二、请求参数处理\n\n### 1、rest使用与原理\n\n- @xxxMapping；\n- Rest风格支持（*使用**HTTP**请求方式动词来表示对资源的操作*）\n\n- - *以前：**/getUser*  *获取用户*   */deleteUser* *删除用户*   */editUser*  *修改用户*    */saveUser* *保存用户*\n  - *现在： /user*   *GET-**获取用户*   *DELETE-**删除用户*   *PUT-**修改用户*    *POST-**保存用户*\n  - 核心Filter；HiddenHttpMethodFilter\n\n- - - 用法： 表单method=post，隐藏域 _method=put\n    - SpringBoot中手动开启\n\n```java\n\t//@RequestMapping(value = \"/user\",method = RequestMethod.GET)\n\t@GetMapping(\"/user\")\n    public String getUser(){\n        return \"GET-张三\";\n    }\n\n    //@RequestMapping(value = \"/user\",method = RequestMethod.POST)\n\t@PostMapping(\"/user\")\n    public String saveUser(){\n        return \"POST-张三\";\n    }\n\n\n    //@RequestMapping(value = \"/user\",method = RequestMethod.PUT)\n\t@PutMapping(\"/user\")\n    public String putUser(){\n        return \"PUT-张三\";\n    }\n\n    //@RequestMapping(value = \"/user\",method = RequestMethod.DELETE)\n\t@DeleteMapping(\"/user\")\t\n    public String deleteUser(){\n        return \"DELETE-张三\";\n    }\n\n    @Bean\n    @ConditionalOnMissingBean(HiddenHttpMethodFilter.class)\n    @ConditionalOnProperty(prefix = \"spring.mvc.hiddenmethod.filter\", name = \"enabled\", matchIfMissing = false)\n    public OrderedHiddenHttpMethodFilter hiddenHttpMethodFilter() {\n        return new OrderedHiddenHttpMethodFilter();\n    }\n\n\n//自定义filter\n    @Bean\n    public HiddenHttpMethodFilter hiddenHttpMethodFilter(){\n        HiddenHttpMethodFilter methodFilter = new HiddenHttpMethodFilter();\n        methodFilter.setMethodParam(\"_m\");\n        return methodFilter;\n    }\n```\n\n","tags":["框架学习"]},{"title":"机器人的运动范围","url":"/2020/12/27/机器人的运动范围/","content":"\n# 机器人的运动范围\n\n地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？\n\n## 审题：\n\n可以看出应该用dfs解题，但犯了两个错误：\n\n1. 忘记标记已经遍历过的格子，导致无限循环。\n2. 把行r和列c调换了位置，导致数组下标溢出异常。\n\n## 查看答案后:\n\n答案的中心思想和我一样，但我依旧做了很多无用功！\n\n1. **这是一个有规律的方阵**，关键的条件“行坐标和列坐标的数位之和”是一个依次递增的，其实不用向四个方向查询，只需要向下，和向右查询就可以。\n\n![image-20201225155726090](C:%5CUsers%5CPowerwenwh%5CDocuments%5C_posts%5C%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4.assets%5Cimage-20201225155726090.png)\n\n这个特性也让我想起了之前做的另外一题———二维数组的查找，两者有同工异曲之妙。 \n\n2. 找规律的能力还要提升。\n\n","tags":["Leetcode"]},{"title":"矩阵中的路径","url":"/2020/12/24/矩阵中的路径/","content":"\n# **矩阵中的路径**\n\n请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。\n路径可以从矩阵中的任意一格开始，每一步可以在矩阵中向左、右、上、下移动一格。\n如果一条路径经过了矩阵的某一格，那么该路径不能再次进入该格子。\n例如，在下面的3×4的矩阵中包含一条字符串“bfce”的路径（路径中的字母用加粗标出）。\n\n        [[\"a\",\"b\",\"c\",\"e\"],\n        [\"s\",\"f\",\"c\",\"s\"],\n        [\"a\",\"d\",\"e\",\"e\"]]\n\n但矩阵中不包含字符串“abfb”的路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入这个格子。\n\n\n\n**一开始做题思路偏差，想到的是递归，但没想到DFS，这道题和岛屿问题其实很像**\n\n调整思路：\n\n1. 双for循环遍历每一格，当匹配到与某字符串第一个字符相同的字符时开始DFS\n\n2. void DFS（char[][] board, String word，r，c，）：\n\n   + 判断该格是否在矩阵内，是否遍历过（定义一个二维数组记录）\n\n   + if（charAt！=current）{return ；}\n   + else if（最后一个字符）{set true；return； }\n   + else{四个方向遍历}\n\n查看答案后总结：\n\n1. 关于判断一个结点是否被访问过，我使用一个二维数组来做记录，需要自己控制它的回溯，不断传参，非常麻烦，答案用了一个非常巧妙的方法，遍历过后把那里的值设置为\"\\0\",先污染，代表访问过，在最后用`board[i][j] = word[k]`进行\"治理\"，以便下一次遍历可以正常使用。\n\n2. 每匹配到一个符合的char，需要记录是第几个char，我使用每次单独执行`word_current++`的方法，还放错了位置，其实只要每次传递的时候传递`word_current`的时候直接传`word_current++`，这样的写法减少了代码量，下次在递归里面写到判断相关的语句的时候都要仔细思考，什么时候判断，能不能用这种简洁方法判断！！\n\n3. 关于找到所有字符后，如何返回这个信息，我的方法是定义一个全局变量，找到之后修改这个全局变量，在DFS完了之后对这个变量进行判断，答案用的方法是“先污染”，我思考过，但想到“治理”的问题觉得麻烦----我设定的DFS是没有返回值的，所以没用，当时的想法是，有返回值的话不知道如何处理，但显然这个方法更便捷。 也学到了处理返回值的方法：\n\n   ```java\n   boolean res = DFS(board, word, r-1, c, w++)|| DFS(board, word, r+1, c, w++)||\n                       DFS(board, word, r, c-1, w++)|| DFS(board, word, r, c+1, w++);\n   board[r][c] = word.charAt(w++);\n   return res;\n   ```\n\n4. `w++`和`w+1`的区别：要注意，值传递的时候，一定要使用后者，使用前者就改变了w的值！\n5. 不断的修改使得代码乱得一塌糊涂，调试过程没有善用“运行到鼠标处”，运行的时候总想着一步一步执行，浪费了大量时间，应该直接运行到最后一部查看参数找出问题。\n\n回顾：\n\n其实解题的大致思路我是懂的，但是细节上仍然处理得不好。","tags":["Leetcode"]},{"title":"刷题学习记录","url":"/2020/12/23/Leetcode刷题/","content":"\n# 刷题学习记录\n\n#### 青蛙跳台阶\n\n有些题目正着想难，但从结果出发容易，看似复杂的题目，可以通过分解情况找规律。\n\n#### 旋转数组的最小数字\n\n遇到排好序的\n\n# 20-12-20\n\n### 01.在for循环中使用变量控制循环次数\n\n在做题“使用两个堆栈实现队列的时候用`stack1.size()`来控制for循环的次数，但每循环一次，`stack1.size()`的值都会减一，导致错误。\n\n# 2021-03-04\n\n### 01.删除链表的节点\n\n审题的时候没有看清题目，浪费了时间。\n\n### 02.不熟悉Java中引用的性质\n\n指针a指向c，令指针b等于a，则改变b，并不会改变指针a，也即全都是引用。\n\n### 03.忘记控制空指针\n\n在访问数组时没注意数组访问越界问题，在使用指针的时候没注意使用前判断指针是否为空。\n\n### 04.a的b次方\n\n`Math.pow(a,b)`返回类型时double\n\n# 0201-03-05\n\n## 正则表达式匹配\n\n### 01.选用嵌套for循环\n\n匹配的时候不一定是一一对应，有时候正则表达式里的一个字符可以匹配字符串里的多个字符，存在一对多的关系，应该使用一对多的方式\n\n# 2021-03-11\n\n## 双指针反转链表、找链表中倒数第k个节点\n\n### 01.continue关键字\n\n用于中止当前循环，直接进入下一次循环，常与if连用。\n\n### 02.3 Ways To Fix \"Illegal Start Of Expression\" Error In Java\n\n1. Missing curly braces\n2. Method inside Method\n3. Public, private or protected access modifier inside method\n\n### 03.Error - Found cycle in the ListNode\n\n链表中发现循环\n\n### 04.ArrayList的初始容量\n\nArrayList的初始容量现在为0，等到第一次add的时候再初始化为10。想查看容量capacity需要用到反射，size（）方法是查询元素数量。","tags":["Leetcode"]},{"title":"岛屿问题","url":"/2020/12/23/「岛屿问题」/","content":"\n## 岛屿类问题的通用解法、DFS 遍历框架\n\n我们所熟悉的 DFS（深度优先搜索）问题通常是在树或者图结构上进行的。而我们今天要讨论的 DFS 问题，是在一种「网格」结构中进行的。岛屿问题是这类网格 DFS 问题的典型代表。网格结构遍历起来要比二叉树复杂一些，如果没有掌握一定的方法，DFS 代码容易写得冗长繁杂。\n\n本文将以岛屿问题为例，展示网格类问题 DFS 通用思路，以及如何让代码变得简洁。\n\n**网格问题的基本概念**\n我们首先明确一下岛屿问题中的网格结构是如何定义的，以方便我们后面的讨论。\n\n网格问题是由m×n 个小方格组成一个网格，每个小方格与其上下左右四个方格认为是相邻的，要在这样的网格上进行某种搜索。\n\n岛屿问题是一类典型的网格问题。每个格子中的数字可能是 0 或者 1。我们把数字为 0 的格子看成海洋格子，数字为 1 的格子看成陆地格子，这样相邻的陆地格子就连接成一个岛屿。\n\n### DFS 的基本结构\n\n网格结构要比二叉树结构稍微复杂一些，它其实是一种简化版的图结构。要写好网格上的 DFS 遍历，我们首先要理解二叉树上的 DFS 遍历方法，再类比写出网格结构上的 DFS 遍历。我们写的二叉树 DFS 遍历一般是这样的：\n\n```java\nvoid traverse(TreeNode root) {\n    // 判断 base case\n    if (root == null) {\n        return;\n    }\n    // 访问两个相邻结点：左子结点、右子结点\n    traverse(root.left);\n    traverse(root.right);\n}\n```\n\n可以看到，二叉树的 DFS 有两个要素：「==访问相邻结点」和「判断 base case」==。\n\n第一个要素是访问相邻结点。二叉树的相邻结点非常简单，只有左子结点和右子结点两个。二叉树本身就是一个递归定义的结构：一棵二叉树，它的左子树和右子树也是一棵二叉树。那么我们的 DFS 遍历只需要递归调用左子树和右子树即可。\n\n第二个要素是 判断 base case。一般来说，二叉树遍历的 base case 是 root == null。这样一个条件判断其实有两个含义：一方面，这表示 root 指向的子树为空，不需要再往下遍历了。另一方面，在 root == null 的时候==及时返回==，可以让后面的 root.left 和 root.right 操作不会出现空指针异常。\n\n对于网格上的 DFS，我们完全可以参考二叉树的 DFS，写出网格 DFS 的两个要素：\n\n首先，网格结构中的格子有多少相邻结点？答案是上下左右四个。对于格子 (r, c) 来说（r 和 c 分别代表行坐标和列坐标），四个相邻的格子分别是 (r-1, c)、(r+1, c)、(r, c-1)、(r, c+1)。换句话说，==网格结构是「四叉」的。==\n\n其次，网格 DFS 中的 base case 是什么？从二叉树的 base case 对应过来，应该是网格中不需要继续遍历、grid[r][c] 会出现数组下标越界异常的格子，也就是那些超出网格范围的格子。\n\n这一点稍微有些反直觉，坐标竟然可以临时超出网格的范围？这种方法我称为==「先污染后治理」==—— 甭管当前是在哪个格子，先往四个方向走一步再说，如果发现走出了网格范围再赶紧返回。这跟二叉树的遍历方法是一样的，先递归调用，发现 root == null 再返回。\n\n这样，我们得到了网格 DFS 遍历的框架代码：\n\n```java\nvoid dfs(int[][] grid, int r, int c) {\n    // 判断 base case\n    // 如果坐标 (r, c) 超出了网格范围，直接返回\n    if (!inArea(grid, r, c)) {\n        return;\n    }\n    // 访问上、下、左、右四个相邻结点\n    dfs(grid, r - 1, c);\n    dfs(grid, r + 1, c);\n    dfs(grid, r, c - 1);\n    dfs(grid, r, c + 1);\n}\n\n// 判断坐标 (r, c) 是否在网格中\nboolean inArea(int[][] grid, int r, int c) {\n    return 0 <= r && r < grid.length \n        \t&& 0 <= c && c < grid[0].length;\n}\n```\n\n### 如何避免重复遍历\n\n网格结构的 DFS 与二叉树的 DFS 最大的不同之处在于，遍历中可能遇到遍历过的结点。这是因为，网格结构本质上是一个「图」，我们可以把每个格子看成图中的结点，每个结点有向上下左右的四条边。在图中遍历时，自然可能遇到重复遍历结点。\n\n这时候，DFS 可能会不停地「兜圈子」，永远停不下来。\n\n如何避免这样的重复遍历呢？答案是标记已经遍历过的格子。以岛屿问题为例，我们需要在所有值为 1 的陆地格子上做 DFS 遍历。每走过一个陆地格子，就把格子的值改为 2，这样当我们遇到 2 的时候，就知道这是遍历过的格子了。也就是说，每个格子可能取三个值：\n\n0 —— 海洋格子\n1 —— 陆地格子（未遍历过）\n2 —— 陆地格子（已遍历过）\n我们在框架代码中加入避免重复遍历的语句：\n\n```java\nvoid dfs(int[][] grid, int r, int c) {\n    // 判断 base case\n    if (!inArea(grid, r, c)) {\n        return;\n    }\n    // 如果这个格子不是岛屿，直接返回\n    if (grid[r][c] != 1) {\n        return;\n    }\n    grid[r][c] = 2; // 将格子标记为「已遍历过」\n    \n    // 访问上、下、左、右四个相邻结点\n    dfs(grid, r - 1, c);\n    dfs(grid, r + 1, c);\n    dfs(grid, r, c - 1);\n    dfs(grid, r, c + 1);\n}\n\n// 判断坐标 (r, c) 是否在网格中\nboolean inArea(int[][] grid, int r, int c) {\n    return 0 <= r && r < grid.length \n        \t&& 0 <= c && c < grid[0].length;\n}\n```\n\n这样，我们就得到了一个岛屿问题、乃至各种网格问题的通用 DFS 遍历方法。以下所讲的几个例题，其实都只需要在 DFS 遍历框架上稍加修改而已。\n\n>小贴士：\n\n> 在一些题解中，可能会把「已遍历过的陆地格子」标记为和海洋格子一样的 0，美其名曰「陆地沉没方法」，即遍历完一个陆地格子就让陆地「沉没」为海洋。这种方法看似很巧妙，但实际上有很大隐患，因为这样我们就无法区分「海洋格子」和「已遍历过的陆地格子」了。如果题目更复杂一点，这很容易出 bug。\n\n### 岛屿问题的解法\n\n#### 例题 1：岛屿的最大面积\n\n#### 例题 2：填海造陆问题\n\n#### 例题 3：岛屿的周长\n\n#### 例题 4：岛屿的数量\n\n给你一个由 '1'（陆地）和 '0'（水）组成的的二维网格，请你计算网格中岛屿的数量。\n\n岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。\n\n此外，你可以假设该网格的四条边均被水包围。\n\n ```java\nclass Solution {\n    void dfs(char[][] grid, int r, int c) {\n        int nr = grid.length;\n        int nc = grid[0].length;\n\n        if (r < 0 || c < 0 || r >= nr || c >= nc || grid[r][c] == '0') {\n            return;\n        }\n\n        grid[r][c] = '0';\n        dfs(grid, r - 1, c);\n        dfs(grid, r + 1, c);\n        dfs(grid, r, c - 1);\n        dfs(grid, r, c + 1);\n    }\n\n    public int numIslands(char[][] grid) {\n        if (grid == null || grid.length == 0) {\n            return 0;\n        }\n\n        int nr = grid.length;\n        int nc = grid[0].length;\n        int num_islands = 0;\n        for (int r = 0; r < nr; ++r) {\n            for (int c = 0; c < nc; ++c) {\n                if (grid[r][c] == '1') {\n                    ++num_islands;\n                    dfs(grid, c, r);\n                }\n            }\n        }\n\n        return num_islands;\n    }\n}\n ```\n\n**复杂度分析**\n\n+ 时间复杂度：O(MN)，其中 MM 和 NN 分别为行数和列数。\n\n+ 空间复杂度：O(MN)，在最坏情况下，整个网格均为陆地，深度优先搜索的深度达到 MN。\n\n\n\n> 作者：LeetCode\n> 链接：https://leetcode-cn.com/problems/number-of-islands/solution/dao-yu-shu-liang-by-leetcode/\n> 来源：力扣（LeetCode）\n> 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","tags":["Leetcode"]},{"title":"Mybatis","url":"/2020/12/12/Mybatis/","content":"\n# 基于代理Dao 实现CRUD 操作\n\n## 使用要求：\n\n1. 持久层接口和持久层接口的映射配置必须在相同的包下\n2. 持久层映射配置中mapper 标签的namespace 属性取值必须是持久层接口的全限定类名\n3. SQL 语句的配置标签<select>,<insert>,<delete>,<update>的id 属性必须和持久层接口的方法名相同。\n\n实例所用数据库user表结构：\n\n![image-20201212192704973](C:\\Users\\Powerwenwh\\Documents\\_posts\\Mybatisi.assets\\image-20201212192704973.png)\n\n## 1.根据ID 查询\n\n### 1.1在持久层接口中添加findById 方法\n\n```java\nUser findById(Integer userId);\n```\n\n\n\n### 1.2在用户的映射配置文件中配置\n\n```xml\n<!-- 根据id 查询 -->\n<select id=\"findById\" resultType=\"com.itheima.domain.User\" parameterType=\"int\">\nselect * from user where id = #{uid}\n</select>\n```\n\n\n\n细节：\n\n+ resultType 属性：\n      \t用于指定结果集的类型。\n+ parameterType 属性：\n      \t用于指定传入参数的类型。\n+ sql 语句中使用#{}字符：\n      \t它代表占位符，相当于原来jdbc 部分所学的?，都是用于执行语句时替换实际的数据。\n      \t具体的数据是由#{}里面的内容决定的。\n+ #{}中内容的写法：\n      \t由于数据类型是基本类型，所以此处可以随意写。\n\n### 1.3在测试类添加测试\n\n```java\npublic class MybastisCRUDTest {\n    private InputStream in;\n    private SqlSession sqlSession;\n    private IUserDao userDao;\n\n    @Before\n    public void init()throws Exception{\n        //1.读取配置文件，生成字节输入流\n        in = Resources.getResourceAsStream(\"SqlMapConfig.xml\");\n        //2.获取SqlSessionFactory\n        SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(in);\n        //3.获取SqlSession对象\n        sqlSession = factory.openSession();\n        //4.获取dao的代理对象\n        userDao = sqlSession.getMapper(IUserDao.class);\n    }\n\n    @After\n    public void destroy()throws Exception{\n        sqlSession.commit();\n        //6.释放资源\n        sqlSession.close();\n        in.close();\n    }\n    \n        @Test\n    public void testFindById(){\n        User user = userDao.findById(50);\n        System.out.println(user);\n    }\n}\n```\n\n\n\n## 2.保存操作\n\n### 2.1在持久层接口中添加新增方法\n\n```java\nvoid saveUser(User user);\n```\n\n### 2.2在用户的映射配置文件中配置\n\n```xml\n<!--保存用户-->\n<insert id=\"saveUser\" parameterType=\"com.wwh.domain.User\">\n\tinsert into user(username, address, sex, birthday)values(#{username},#{address},#{sex},#{birthday});\n</insert>\n```\n\n\n\n细节：\n\n+ parameterType 属性：\n  \t\t代表参数的类型，因为我们要传入的是一个类的对象，所以类型就写类的全名称。\n+ #{}中内容的写法：\n  \t\t由于我们保存方法的参数是 一个User 对象，此处要写User 对象中的属性名称。它用的是ognl 表达式。\n+ ognl 表达式：\n      \t它是apache 提供的一种表达式语言，全称是：\n      \t\tObject Graphic Navigation Language 对象图导航语言\n          它是按照一定的语法格式来获取数据的。\n          语法格式就是使用 #{对象.对象}的方式\n          #{user.username}它会先去找user 对象，然后在user 对象中找到username 属性，并调用\n          getUsername()方法把值取出来。但是我们在parameterType 属性上指定了实体类名称，所以可以省略user.而直接写username。\n\n### 2.3添加测试类中的测试方法\n\n```java\n@Test\npublic void testSave(){\n    User user = new User();\n    user.setAddress(\"地址1\");\n    user.setBirthday(new Date());\n    user.setUsername(\"姓名1\");\n    user.setSex(\"男\");\n\n    userDao.saveUser(user);\n}\n```\n\n\n\n细节：\n\n+ 保存后Mysql会自动添加id的值,id 是由数据库的自动增长来实现的。\n\n+ 执行后打开Mysql 数据库发现并没有添加任何记录，原因是什么？\n  这一点和jdbc 是一样的，我们在实现增删改时一定要去控制事务的提交，那么在mybatis 中如何控制事务提交呢？\n+ 可以使用:session.commit();来实现事务提交。加入事务提交后的代码如下：\n\n```java\n@After//在测试方法执行完成之后执行\npublic void destroy() throws Exception{\n    session.commit();\n    //7.释放资源\n    session.close();\n    in.close();\n}\n```\n\n\n\n#### 扩展：新增用户id 的返回值\n\n新增用户后，同时还要返回当前新增用户的id 值，因为id 是由数据库的自动增长来实现的，所以就相\n当于我们要在新增后将自动增长auto_increment 的值返回。\n\n```xml\n<insert id=\"saveUser\" parameterType=\"USER\">\n    <!-- 配置保存时获取插入的id -->\n    <selectKey keyColumn=\"id\" keyProperty=\"id\" resultType=\"int\">\n        select last_insert_id();\n    </selectKey>\n    insert into user(username,birthday,sex,address)\n    values(#{username},#{birthday},#{sex},#{address})\n</insert>\n```\n\n\n\n## 3.用户更新\n\n### 3.1在持久层接口中添加新增方法\n\n```java\nint updateUser(User user);\n```\n\n\n\n### 3.2在用户的映射配置文件中配置\n\n```xml\n<!-- 更新用户 -->\n<update id=\"updateUser\" parameterType=\"com.itheima.domain.User\">\n    update user set username=#{username},birthday=#{birthday},sex=#{sex},address=#{address} where id=#{id}\n</update>\n```\n\n\n\n### 3.3添加测试类中的测试方法\n\n```java\n@Test\npublic void testUpdateUser()throws Exception{\n    //1.根据id 查询\n    User user = userDao.findById(52);\n    //2.更新操作\n    user.setAddress(\"北京市顺义区\");\n    int res = userDao.updateUser(user);\n    System.out.println(res);\n}\n```\n\n\n\n## 4.用户删除\n\n### 4.1在持久层接口中添加新增方法\n\n```java\nint deleteUser(Integer userId);\n```\n\n\n\n### 4.2在用户的映射配置文件中配置\n\n```xml\n<!-- 删除用户 -->\n<delete id=\"deleteUser\" parameterType=\"java.lang.Integer\">\ndelete from user where id = #{uid}\n</delete>\n```\n\n\n\n### 4.3添加测试类中的测试方法\n\n```java\n@Test\npublic void testDeleteUser() throws Exception {\n    //6.执行操作\n    int res = userDao.deleteUser(52);\n    System.out.println(res);\n}\n```\n\n\n\n## 5.用户模糊查询\n\n### 5.1在持久层接口中添加新增方法\n\n```java\nList<User> findByName(String username);\n```\n\n\n\n### 5.2在用户的映射配置文件中配置\n\n```java\n<!-- 根据名称模糊查询 -->\n<select id=\"findByName\" resultType=\"com.itheima.domain.User\" parameterType=\"String\">\nselect * from user where username like #{username}\n</select>\n```\n\n\n\n### 5.3添加测试类中的测试方法\n\n```java\n@Test\npublic void testFindByName(){\n    //5.执行查询一个方法\n    List<User> users = userDao.findByName(\"%王%\");\n    for(User user : users){\n    \tSystem.out.println(user);\n    }\n}\n```\n\n![image-20201212205615436](C:\\Users\\Powerwenwh\\Documents\\_posts\\Mybatisi.assets\\image-20201212205615436.png)\n\n细节：\n\n+ 在配置文件中没有加入%来作为模糊查询的条件，所以在传入字符串实参时，就需要给定模糊查询的标识%。配置文件中的#{username}也只是一个占位符，所以SQL 语句显示为“？”\n\n## SqlMapConfig.xml配置文件","tags":["框架学习"]},{"title":"Springboot入门","url":"/2020/12/05/Springboot常用注解/","content":"# 一、Springboot入门\n\n## 1、Spring Boot简介\n\n> 简化Spring应用开发的一个框架；\n> 整个Spring技术栈的一个大整合；\n> J2EE开发的一站式解决方案；\n\n## 2、Spring Boot HelloWorld\n\n一个功能：浏览器发送hello请求，服务器接受请求并处理，响应Hello World字符串；\n\n### （1）、创建一个maven工程；（jar）\n\n### （2）、导入spring boot相关的依赖\n\n```xml\n<parent>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring‐boot‐starter‐parent</artifactId>\n<version>1.5.9.RELEASE</version>\n</parent>\n<dependencies>\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring‐boot‐starter‐web</artifactId>\n    </dependency>\n</dependencies>\n```\n\n### （3）、编写一个主程序；启动Spring Boot应用\n\n```java\n/**\n* @SpringBootApplication 来标注一个主程序类，说明这是一个Spring Boot应用\n*/\n@SpringBootApplication\npublic class HelloWorldMainApplication {\n    public static void main(String[] args) {\n        // Spring应用启动起来\n        SpringApplication.run(HelloWorldMainApplication.class,args);\n    }\n}\n```\n\n### （4）、编写相关的Controller、Service\n\n```java\n@Controller\npublic class HelloController {\n    @ResponseBody\n    @RequestMapping(\"/hello\")\n    public String hello(){\n    \treturn \"Hello World!\";\n    }\n}\n```\n\n### （5）、运行主程序测试\n\n### （6）、简化部署\n\n```xml\n<!‐‐ 这个插件，可以将应用打包成一个可执行的jar包；‐‐>\n<build>\n    <plugins>\n        <plugin>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring‐boot‐maven‐plugin</artifactId>\n        </plugin>\n    </plugins>\n</build>\n```\n\n将这个应用打成jar包，直接使用java -jar的命令进行执行；\n\n## 3、Hello World探究\n\n### （1）、POM文件\n\n+ **父项目**\n\n  ```xml\n  <parent>\n          <groupId>org.springframework.boot</groupId>\n          <version>1.5.9.RELEASE</version>\n          <artifactId>spring-boot-starter-parent</artifactId>\n      </parent>\n  \n  他的父项目是\n  <parent>\n  \t\t<groupId>org.springframework.boot</groupId>\n  \t\t<artifactId>spring-boot-dependencies</artifactId>\n  \t\t<version>1.5.9.RELEASE</version>\n  \t\t<relativePath>../../spring-boot-dependencies</relativePath>\n  \t</parent>\n  他来真正管理Spring Boot应用里面得所有版本；\n  ```\n\n  ![Snipaste_2020-11-25_16-50-12](Snipaste_2020-11-25_16-50-12.png)\n\n  Spring Boot的版本仲裁中心，以后导入依赖默认是不用写版本，除非是没有在dependencies里面管理的依赖。\n\n+ 启动器\n\n  ```xml\n      <dependencies>\n          <dependency>\n              <groupId>org.springframework.boot</groupId>\n              <artifactId>spring-boot-starter-web</artifactId>\n          </dependency>\n      </dependencies>\n  ```\n\n  **spring-boot-starter**-==web==：\n  spring-boot-starter：spring-boot场景启动器；帮我们导入了web模块正常运行所依赖的组件；\n  ==Spring Boot将所有的功能场景都抽取出来，做成一个个的starters（启动器），只需要在项目里面引入这些starter==\n  相关场景的所有依赖都会导入进来。要用什么功能就导入什么场景的启动器\n\n### （2）、主程序类，主入口类\n\n```java\n/**\n* @SpringBootApplication 来标注一个主程序类，说明这是一个Spring Boot应用\n*/\n@SpringBootApplication\npublic class HelloWorldMainApplication {\npublic static void main(String[] args) {\n// Spring应用启动起来\nSpringApplication.run(HelloWorldMainApplication.class,args);\n}\n}\n```\n\n**@SpringBootApplication：**Spring Boot应用标注在某个类上说明这个类是SpringBoot的主配置类，SpringBoot\n就应该运行这个类的main方法来启动SpringBoot应用；\n\n```java\n@Target(ElementType.TYPE)\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Inherited\n@SpringBootConfiguration\n@EnableAutoConfiguration\n@ComponentScan(excludeFilters = {\n@Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),\n@Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) })\npublic @interface SpringBootApplication {\n```\n\n**@SpringBootConfiguration:**Spring Boot的配置类；\n\n标注在某个类上，表示这是一个Spring Boot的配置类；\n\n**@Configuration:**配置类上来标注这个注解；\n\n配置类 ----- 配置文件；配置类也是容器中的一个组件；@Component\n\n**@EnableAutoConfiguration：**开启自动配置功能；\n\n以前我们需要配置的东西，Spring Boot帮我们自动配置；**@EnableAutoConfiguration**告诉SpringBoot开启自\n动配置功能；这样自动配置才能生效；\n\n```java\n@AutoConfigurationPackage\n@Import(EnableAutoConfigurationImportSelector.class)\npublic @interface EnableAutoConfiguration {\n```\n\n**@AutoConfigurationPackage：**自动配置包\n**@Import**(AutoConfigurationPackages.Registrar.class)：\nSpring的底层注解@Import，给容器中导入一个组件；导入的组件由\nAutoConfigurationPackages.Registrar.class；\n==将主配置类（@SpringBootApplication标注的类）的所在包及下面所有子包里面的所有组件扫描到Spring容器；==\n**@Import**(EnableAutoConfigurationImportSelector.class)；\n给容器中导入组件？\n**EnableAutoConfigurationImportSelector：**导入哪些组件的选择器；\n将所有需要导入的组件以全类名的方式返回；这些组件就会被添加到容器中；\n会给容器中导入非常多的自动配置类（xxxAutoConfiguration）；就是给容器中导入这个场景需要的所有组件，并配置好这些组件；\n\n有了自动配置类，免去了我们手动编写配置注入功能组件等的工作；\nSpringFactoriesLoader.loadFactoryNames(EnableAutoConfiguration.class,classLoader)；\n==Spring Boot在启动的时候从类路径下的META-INF/spring.factories中获取EnableAutoConfiguration指定的值，将==\n==这些值作为自动配置类导入到容器中，自动配置类就生效，帮我们进行自动配置工作；==以前我们需要自己配置的东西，自动配置类都帮我们；\nJ2EE的整体整合解决方案和自动配置都在spring-boot-autoconfigure-1.5.9.RELEASE.jar；\n\n## 4、使用Spring Initializer快速创建Spring Boot项目\n\nIDE都支持使用Spring的项目创建向导快速创建一个Spring Boot项目；\n选择我们需要的模块；向导会联网创建Spring Boot项目；\n默认生成的Spring Boot项目；\n\n+ 主程序已经生成好了，我们只需要我们自己的逻辑\n+ resources文件夹中目录结构\n  + static：保存所有的静态资源； js css images；\n  + templates：保存所有的模板页面；（Spring Boot默认jar包使用嵌入式的Tomcat，默认不支持JSP页面）；可以使用模板引擎（freemarker、thymeleaf）；\n  + application.properties：Spring Boot应用的配置文件；可以修改一些默认设置；\n\n# 二、配置文件\n\n## 1、配置文件\n\nSpringBoot使用一个全局的配置文件，配置文件名是固定的；\n\n+ application.properties\n+ application.yml\n\n  **配置文件的作用：**修改SpringBoot自动配置的默认值；SpringBoot在底层都给我们自动配置好；\n\nYAML（YAML Ain't Markup Language）\nYAML A Markup Language：是一个标记语言\nYAML isn't Markup Language：不是一个标记语言；\n标记语言：\n以前的配置文件；大多都使用的是 xxxx.xml文件；\nYAML：以数据为中心，比json、xml等更适合做配置文件；\n\nYAML：配置例子\n\n```yaml\nserver:\n\tport: 8081\n```\n\nXML：\t\t\n\n```xml\n<server>\n\t<port>8081</port>\n</server>\n```\n\n## 2、YAML语法：//TODO\n\n## 3、配置文件值注入\n\n#### ==1、@Value获取值和@ConfigurationProperties获取值比较==\n\n|                | @ConfigurationProperties | @Value     |\n| -------------- | ------------------------ | ---------- |\n| 功能           | 批量注入配置文件中的属性 | 一个个指定 |\n| 松散绑定       | 支持                     | 不支持     |\n| SpEL           | 不支持                   | 支持       |\n| JSR303数据校验 | 支持                     | 不支持     |\n| 复杂类型封装   | 支持                     | 不支持     |\n\n配置文件yml还是properties他们都能获取到值；\n如果说，我们只是在某个业务逻辑中需要获取一下配置文件中的某项值，使用@Value；\n如果说，我们专门编写了一个javaBean来和配置文件进行映射，我们就直接使用@ConfigurationProperties；\n\n#### 4、@PropertySource&@ImportResource&@Bean\n\n@PropertySource：加载指定的配置文件；\n\n@ImportResource：导入Spring的配置文件，让配置文件里面的内容生效；\nSpring Boot里面没有Spring的配置文件，我们自己编写的配置文件，也不能自动识别；\n想让Spring的配置文件生效，加载进来；@ImportResource标注在一个配置类上\n\n```java\n@ImportResource(locations = {\"classpath:beans.xml\"})\n导入Spring的配置文件让其生效\n```\n\n**==SpringBoot推荐给容器中添加组件的方式；推荐使用全注解的方式==**\n\n1. 配置类@Configuration------>Spring配置文件\n2. 使用@Bean给容器中添加组件\n\n```java\n/**\n* @Configuration：指明当前类是一个配置类；就是来替代之前的Spring配置文件\n*\n* 在配置文件中用<bean><bean/>标签添加组件\n*\n*/\n@Configuration\npublic class MyAppConfig {\n//将方法的返回值添加到容器中；容器中这个组件默认的id就是方法名\n    @Bean\n    public HelloService helloService02(){\n        System.out.println(\"配置类@Bean给容器中添加组件了...\");\n        return new HelloService();\n\t}\n}\n```\n\n","tags":["框架学习"]},{"title":"剪绳子","url":"/2020/12/03/剪绳子/","content":"\n给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n>1并且m>1），每段绳子的长度记为 k[0],k[1]...k[m-1] 。\n请问 k[0]*k[1]*...*k[m-1] 可能的最大乘积是多少？\n例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。\n\n答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。\n\n\n\n数学推导总体分为两步：① 当所有绳段长度相等时，乘积最大。② 最优的绳段长度为 3 。\n\n![image-20210203214432517](C:%5CUsers%5CPowerwenwh%5CDocuments%5C_posts%5Cimgs%5C%E5%89%AA%E7%BB%B3%E5%AD%90%5Cimage-20210203214432517.png)\n\n切分规则：\n\n1. 根据对函数进行求导等处理，得出每段绳子为3的时候最优，\n2. 当绳子长度不是3的倍数时，应该对余数进行处理：\n   1. 余数为1，和上一段合并分为`1+3<2×2`\n   2. 余数为2，保留。\n\n算法思路：\n\n1. 当 n≤3 时，按照规则应不切分，但由于题目要求必须剪成 m>1段，因此必须剪出一段长度为1的绳子，即返回 n - 1 。\n\n2. 当 n>3时，求 n 除以 3 的 整数部分 a 和 余数部分 b （即 n = 3a + b ），并分为以下三种情况：\n\n   + 当 b = 0 时，直接返回 3^a；\n   + 当 b = 1 时，要将一个 1 + 3转换为 2+2，因此返回 3^（a-1） ×4；\n   + 当 b = 2时，返回 3^a  ×2。\n\n   \n\n代码：\n\n```java\npublic class Solution {\n    public int cuttingRope(int n){\n        if (n<=3) {\n             return n-1;\n        }else {\n            //对余数分类讨论\n            int a = n / 3;\n            int b = n % 3;\n            if (b == 0) {\n                return (int) Math.pow(3, a);\n            }else if (b == 1) {\n                return (int) Math.pow(3, a-1)*4;\n            }else {\n                return (int) Math.pow(3, a)*2;\n            }\n        }\n    }\n}\n```\n\n\n\n+ Java中表示次方：`Math.pow(a, b)`=>a的b次方。\n\n+ Java中double类型转int类型： `int IntValue = (int) DoubleValue`。\n\n+ 大数求余解法：\n\n  + 大数越界： 当 a 增大时，最后返回的 3^a大小以指数级别增长，可能超出 int32 甚至 int64 的取值范围，导致返回值错误。\n\n  + 大数求余问题： 在仅使用 int32 类型存储的前提下，正确计算 x^a 对 p 求余的值。\n\n  + 解决方案： 循环求余 、 快速幂求余 ，其中后者的时间复杂度更低，两种方法均基于以下求余运算规则推出：\n\n    (xy)⊙p=[(x⊙p)(y⊙p)]⊙p\n\n","tags":["Leetcode"]},{"title":"栈和队列","url":"/2020/12/02/栈和队列/","content":"\n## 队列：先入先出的数据结构\n\n队列是典型的 FIFO 数据结构。插入（insert）操作也称作入队（enqueue），新元素始终被添加在队列的末尾。 删除（delete）操作也被称为出队（dequeue)。 你只能移除第一个元素。\n\n### 队列 - 实现\n\n使用动态数组和指向队列头部的索引。\n\n队列应支持两种操作：入队和出队。入队会向队列追加一个新元素，而出队会删除第一个元素。 所以我们==需要一个索引来指出起点==。\n\n```java\nclass MyQueue {\n    // store elements\n    private List<Integer> data;         \n    // a pointer to indicate the start position\n    private int p_start;            \n    public MyQueue() {\n        data = new ArrayList<Integer>();\n        p_start = 0;\n    }\n    /** Insert an element into the queue. Return true if the operation is successful. */\n    public boolean enQueue(int x) {\n        data.add(x);\n        return true;\n    };    \n    /** Delete an element from the queue. Return true if the operation is successful. */\n    public boolean deQueue() {\n        if (isEmpty() == true) {\n            return false;\n        }\n        p_start++;\n        return true;\n    }\n    /** Get the front item from the queue. */\n    public int Front() {\n        return data.get(p_start);\n    }\n    /** Checks whether the queue is empty or not. */\n    public boolean isEmpty() {\n        return p_start >= data.size();\n    }     \n};\n```\n\n缺點：简单但低效，随着起始指针的移动，浪费了越来越多的空间\n\n### 循环队列\n\n使用`固定大小的数组`和`两个指针`来指示起始位置和结束位置。 目的是`重用`之前提到的`被浪费的存储`。\n\n#### 数组实现\n\n```java\npublic class MyCircularQueue {\n    private int[] data;\n    private int capacity;//队列容量\n\n    private int p_start;\n    private int count;//队列目前元素个数\n\n    public MyCircularQueue(int k) {\n        this.data = new int[k];\n        this.p_start = 0;\n        this.count = 0;\n        this.capacity=k;\n    }\n\n    public int Front() {\n        if (this.count==0) {\n            return -1;\n        }else return this.data[this.p_start];\n    }\n\n    public int Rear() {\n        if(this.count==0) {\n            return -1;\n        }else return this.data[((this.p_start+this.count)-1)%this.capacity];\n    }\n\n    public boolean enQueue(int value) {\n        if (capacity==count) {\n            return false;\n        }else {\n            this.data[(this.p_start+this.count)%capacity] = value;\n            this.count++;\n            return true;\n        }\n    }\n\n    public boolean deQueue() {\n        if (this.isEmpty()) {\n            return false;\n        } else {\n            this.p_start = (p_start+1)%this.capacity;\n            count--;\n            return true;\n        }\n    }\n\n    public boolean isEmpty() {\n        return (this.count == 0);\n    }\n\n    public boolean isFull() {\n        return (this.count == this.capacity);\n    }\n}\n```\n\n**复杂度分析**\n\n+ 时间复杂度：O(1)。该数据结构中，所有方法都具有恒定的时间复杂度。\n\n+ 空间复杂度：O(N)，其中 N 是队列的预分配容量。循环队列的整个生命周期中，都持有该预分配的空间。\n\n**总结：**\n\n1. 队列容量这个变量可以用`data.length`来代替，可以使得属性数量减少，且更加高效。\n\n2. 构造函数不带返回类型。\n\n3. ==判断队满和队空==\n\n   + 方法一：约定以“队列头指针front在队尾指针rear的下一个位置上”作为队列“满”状态的标志。\n\n      队空时： front=rear\n      队满时： (rear+1)%maxsize=front\n\n   + 方法二：另设一个变量count记录队列内的元素个数，与队列总长度对比即可得出。\n\n#### 单链表实现\n\n单链表 和数组都是很常用的数据结构。\n\n> 与固定大小的数组相比，单链表不会为未使用的容量预分配内存，因此它的内存效率更高。\n\n单链表与数组实现方法的时间和空间复杂度相同，但是单链表的效率更高，因为这种方法不会预分配内存。\n\n**算法**\n\n列举循环队列中用到的所有属性，并解释其含义:\n\n+ capacity：循环队列可容纳的最大元素数量。\n\n+ head：队首元素索引。\n\n+ count：当前队列长度。该属性很重要，可以用来做边界检查。\n\n+ tail：队尾元素索引。与数组实现方式相比，如果不保存队尾索引，则需要花费O(N) 时间找到队尾元素。\n\n```java\nclass Node {\n  public int value;\n  public Node nextNode;\n\n  //单链表的结构要熟悉，这里为其添加一个含参数的构造函数比较合理。\n  public Node(int value) {\n    this.value = value;\n    this.nextNode = null;\n  }\n}\n\nclass MyCircularQueue {\n\n  private Node head, tail;\n  private int count;\n  private int capacity;\n\n  /** Initialize your data structure here. Set the size of the queue to be k. */\n  public MyCircularQueue(int k) {\n    this.capacity = k;\n  }\n\n  /** Insert an element into the circular queue. Return true if the operation is successful. */\n  public boolean enQueue(int value) {\n    if (this.count == this.capacity)\n      return false;\n\n    Node newNode = new Node(value);\n     //入队的时候，队列为空的话，头尾指针入队后都指向新节点，若队列不为空，只需要操作尾部指针就可以。\n    if (this.count == 0) {\n      head = tail = newNode;\n    } else {\n      tail.nextNode = newNode;\n      tail = newNode;\n    }\n    this.count += 1;\n    return true;\n  }\n\n  /** Delete an element from the circular queue. Return true if the operation is successful. */\n  public boolean deQueue() {\n    if (this.count == 0)\n      return false;\n    this.head = this.head.nextNode;\n    this.count -= 1;\n    return true;\n  }\n\n  /** Get the front item from the queue. */\n  public int Front() {\n    if (this.count == 0)\n      return -1;\n    else\n      return this.head.value;\n  }\n\n  /** Get the last item from the queue. */\n  public int Rear() {\n    if (this.count == 0)\n      return -1;\n    else\n      return this.tail.value;\n  }\n\n  /** Checks whether the circular queue is empty or not. */\n  public boolean isEmpty() {\n    return (this.count == 0);\n  }\n\n  /** Checks whether the circular queue is full or not. */\n  public boolean isFull() {\n    return (this.count == this.capacity);\n  }\n}\n```\n\n**复杂度分析**\n\n+ 时间复杂度：O(1)，所有方法都具有恒定的时间复杂度。\n\n+ 空间复杂度：O(N)，与数组实现相同。但是单链表实现f方式的内存效率更高。\n\n**总结**：\n\n1. 单链表的结构要熟悉，这里为其添加一个含参数的构造函数比较合理。\n2. 入队的时候，队列为空的话，头尾指针入队后都指向新节点，若队列不为空，只需要操作尾部指针就可以。\n\n### 内置队列库及其常见操作的一些示例：\n\n```java\n// \"static void main\" must be defined in a public class.\npublic class Main {\n    public static void main(String[] args) {\n        // 1. Initialize a queue.\n        Queue<Integer> q = new LinkedList();\n        // 2. Get the first element - return null if queue is empty.\n        System.out.println(\"The first element is: \" + q.peek());\n        // 3. Push new element.\n        q.offer(5);\n        q.offer(13);\n        q.offer(8);\n        q.offer(6);\n        // 4. Pop an element.\n        q.poll();\n        // 5. Get the first element.\n        System.out.println(\"The first element is: \" + q.peek());\n        // 7. Get the size of the queue.\n        System.out.println(\"The size is: \" + q.size());\n    }\n}\n```\n\n### 队列和广度优先搜索\n\n`广度优先搜索`（BFS）是一种`遍历或搜索`数据结构（如树或图）的算法。\n\n使用 BFS 的两个主要方案：`遍历`或`找出最短路径`。\n\n#### 广度优先搜索 - 模板\n\n#### 模板 I\n\n```java\n/**\n * Return the length of the shortest path between root and target node.\n */\nint BFS(Node root, Node target) {\n    Queue<Node> queue;  // store all nodes which are waiting to be processed\n    int step = 0;       // number of steps neeeded from root to current node\n    // initialize\n    add root to queue;\n    // BFS\n    while (queue is not empty) {\n        step = step + 1;\n        // iterate the nodes which are already in the queue\n        int size = queue.size();\n        for (int i = 0; i < size; ++i) {\n            Node cur = the first node in queue;\n            return step if cur is target;\n            for (Node next : the neighbors of cur) {\n                add next to queue;\n            }\n            remove the first node from queue;\n        }\n    }\n    return -1;          // there is no path from root to target\n}\n```\n\n1. 如代码所示，在每一轮中，队列中的结点是等待处理的结点。\n2. 在每个更外一层的 while 循环之后，我们距离根结点更远一步。变量 step 指示从根结点到我们正在访问的当前结点的距离。\n\n#### 模板 II\n\n有时，确保我们永远`不会访问一个结点两次`很重要。否则，我们可能陷入无限循环。如果是这样，我们可以在上面的代码中添加一个哈希集来解决这个问题。这是修改后的伪代码：\n\n```java\n/**\n * Return the length of the shortest path between root and target node.\n */\nint BFS(Node root, Node target) {\n    Queue<Node> queue;  // store all nodes which are waiting to be processed\n    Set<Node> used;     // store all the used nodes\n    int step = 0;       // number of steps neeeded from root to current node\n    // initialize\n    add root to queue;\n    add root to used;\n    // BFS\n    while (queue is not empty) {\n        step = step + 1;\n        // iterate the nodes which are already in the queue\n        int size = queue.size();\n        for (int i = 0; i < size; ++i) {\n            Node cur = the first node in queue;\n            return step if cur is target;\n            for (Node next : the neighbors of cur) {\n                if (next is not in used) {\n                    add next to queue;\n                    add next to used;\n                }\n            }\n            remove the first node from queue;\n        }\n    }\n    return -1;          // there is no path from root to target\n}\n```\n\n有两种情况你不需要使用哈希集：\n\n1. 你完全确定没有循环，例如，在树遍历中；\n2. 你确实希望多次将结点添加到队列中。\n\n## 栈：后入先出的数据结构\n\n在 LIFO 数据结构中，将`首先处理添加到队列`中的`最新元素`。\n\n### 实现 - 栈\n\n栈的实现比队列容易。`动态数组`足以实现堆栈结构：\n\n```java\n// \"static void main\" must be defined in a public class.\nclass MyStack {\n    private List<Integer> data;               // store elements\n    public MyStack() {\n        data = new ArrayList<>();\n    }\n    /** Insert an element into the stack. */\n    public void push(int x) {\n        data.add(x);\n    }\n    /** Checks whether the queue is empty or not. */\n    public boolean isEmpty() {\n        return data.isEmpty();\n    }\n    /** Get the top item from the queue. */\n        public int top() {\n        return data.get(data.size() - 1);\n    }\n    /** Delete an element from the queue. Return true if the operation is successful. */\n    public boolean pop() {\n        if (isEmpty()) {\n            return false;\n        }\n        data.remove(data.size() - 1);\n        return true;\n    }\n};\n\npublic class Main {\n    public static void main(String[] args) {\n        MyStack s = new MyStack();\n        s.push(1);\n        s.push(2);\n        s.push(3);\n        for (int i = 0; i < 4; ++i) {\n            if (!s.isEmpty()) {\n                System.out.println(s.top());\n            }\n            System.out.println(s.pop());\n        }\n    }\n}\n```\n\n大多数流行的语言都提供了内置的栈库，因此你不必重新发明轮子。除了初始化，我们还需要知道如何使用两个最重要的操作：入栈和退栈。除此之外，你应该能够从栈中获得顶部元素。下面是一些供你参考的代码示例：\n\n```java\n// \"static void main\" must be defined in a public class.\npublic class Main {\n    public static void main(String[] args) {\n        // 1. Initialize a stack.\n        Stack<Integer> s = new Stack<>();\n        // 2. Push new element.\n        s.push(5);\n        s.push(13);\n        s.push(8);\n        s.push(6);\n        // 3. Check if stack is empty.\n        if (s.empty() == true) {\n            System.out.println(\"Stack is empty!\");\n            return;\n        }\n        // 4. Pop an element.\n        s.pop();\n        // 5. Get the top element.\n        System.out.println(\"The top element is: \" + s.peek());\n        // 6. Get the size of the stack.\n        System.out.println(\"The size is: \" + s.size());\n    }\n}\n```\n\n当你想首先处理最后一个元素时，栈将是最合适的数据结构。\n\n### 最小栈\n\n设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。\n\npush(x) —— 将元素 x 推入栈中。\npop() —— 删除栈顶的元素。\ntop() —— 获取栈顶元素。\ngetMin() —— 检索栈中的最小元素。\n\n#### 方法一：辅助栈\n\n要做出这道题目，首先要理解栈结构先进后出的性质。\n\n对于栈来说，**如果一个元素 a 在入栈时，栈里有其它的元素 b, c, d，那么无论这个栈在之后经历了什么操作，只要 a 在栈中，b, c, d 就一定在栈中**，因为在 a 被弹出之前，b, c, d 不会被弹出。\n\n因此，在操作过程中的任意一个时刻，只要栈顶的元素是 a，那么我们就可以确定栈里面现在的元素一定是 a, b, c, d。\n\n那么，我们可以在每个元素 a 入栈时把当前栈的最小值 m 存储起来。在这之后无论何时，如果栈顶元素是 a，我们就可以直接返回存储的最小值 m。\n\n```java\nimport java.util.Stack;\n\n/**\n * Your MinStack object will be instantiated and called as such:\n * MinStack obj = new MinStack();\n * obj.push(x);\n * obj.pop();\n * int param_3 = obj.top();\n * int param_4 = obj.getMin();\n */\n\npublic class MinStack {\n    private Stack<Integer> stack;\n    private Stack<Integer> help_stack;\n\n    /**\n     * initialize your data structure here.\n     */\n    public MinStack() {\n        stack = new Stack<>();\n        help_stack = new Stack<>();\n    }\n\n    public void push(int x) {\n        stack.push(x);\n        if (help_stack.empty() || x < help_stack.peek()) {\n            help_stack.push(x);\n        } else {\n            help_stack.push(help_stack.peek());\n        }\n    }\n\n    public void pop() {\n        help_stack.pop();\n        stack.pop();\n    }\n\n    public int top() {\n        return stack.peek();\n    }\n\n    public int getMin() {\n        return help_stack.peek();\n    }\n}\n```\n\n**复杂度分析**\n\n+ **时间复杂度：**对于题目中的所有操作，时间复杂度均为O(1)。因为栈的插入、删除与读取操作都是 O(1)，我们定义的每个操作最多调用栈操作两次。\n+ **空间复杂度：**O(n)，其中 n 为总操作数。最坏情况下，我们会连续插入 n 个元素，此时两个栈占用的空间为 O(n)。\n\n#### 对于辅助栈的优化\n\n==当`push`的数据比当前最小值大的时候，我们可以不对辅助栈进行最小值的插入；如果小于或者等于最小值，就需要把最新的最小值`push`入栈minValue。（特别注意“小于等于”这个条件，等于也要入栈，不然有相同的几个值都为最小值的时候辅助栈会出现栈空的情况）==\n\n相应的，辅助栈pop()的条件也改变，如果栈顶元素等于当前最小值则出栈。\n\n```java\npublic void push(int x) {\n    stack.push(x);\n    if (help_stack.empty() || x <= help_stack.peek()) {\n        help_stack.push(x);\n    }\n}\n\npublic void pop() {\n    int temp = stack.pop();\n    if (temp == help_stack.peek()) {\n        help_stack.pop();\n    }\n}\n```\n\n#### **优化空间复杂度到O(1)**\n\n只用一个栈实现最小栈\n\n- 栈不能够只存储原始数据，应该存储差值。\n- 用一个变量来计算栈的最小值\n\ndiff栈的计算 = `data - min`\n\n`top` : 如何根据diff栈来恢复栈顶top的元素？\n\n根据diff的正负分情况讨论，`diff>=0`时，证明`data>=min`，此时`data=min+diff`\n\n`push` : 如何更新min最小值？\n\n入栈的时候根据`compare = x - minValue;`的正负来判断,`compare < 0 ? x : minValue`\n\n`pop` : 如何维护min的最小值？\n\n出栈的时候也要及时进行min的更新`top > 0 ? top + minValue : minValue`\n\n```java\npublic class MinStack3 {\n\tprivate Stack<Integer> diff = new Stack<Integer>();\n\tprivate int minValue;\n\n\tpublic void push(int x) {\n\t\tif (diff.isEmpty()) {\n\t\t\tminValue = x;\n\t\t\tdiff.push(0);\n\t\t} else {\n\t\t\tint compare = x - minValue;\n\t\t\tdiff.push(compare);\n\t\t\tminValue = compare < 0 ? x : minValue;\n\t\t}\n\t}\n    \n\tpublic void pop() {\n\t\tint top = diff.peek();\n\t\tminValue = top < 0 ? (minValue - top) : minValue;\n\t\tdiff.pop();\n\t}\n\n\tpublic int top() {\n\t\tint top = diff.peek();\n\t\treturn top > 0 ? top + minValue : minValue;\n\t}\n\n\tpublic int getMin() {\n\t\treturn minValue;\n\t}\n}\n```\n\n**总结：**\n\n+ 辅助栈的优化，和存储差值的思路可以对程序进行有效的优化。\n+ 合理运用三元表达式可以使代码更加简洁。\n+ 由辅助栈的优化可以知道，以后凡是有相同的步骤或者代码段，都应该思考能否进行优化。而不是机械式地运作。\n+ 由存储差值的方法启发，以后在存储数据的时候，可以考虑不用常规的思维存储数值本身，从与某个特殊值的的差值入手。","tags":["Leetcode"]},{"title":"Java中String为什么是不可变的？","url":"/2020/11/03/java中String类为什么不可变/","content":"\n    Java中String为什么是不可变的？ Java 9 对 String有什么优化吗？\n\n## 一、java将String设成不可变最大的原因是效率和安全。\n\n在面试中经常遇到这样的问题：什么是不可变对象。不可变对象有什么好处。在什么情景下使用它，或者更具体一点，java的String类为什么要设置成不可变类型？\n\n1. 不可变对象，顾名思义就是创建后的对象不可以改变，典型的例子有java中的String类型。\n\n2. 相比于可变对象，不可变对象有很多优势：\n\n\n## 1. 字符串常量池的需要\n\n不可变对象可以**提高String Pool(字符串常量池)的效率和安全性**。如果一个对象是不可变动 ，那么需要拷贝的对象的内容时就不用复制它本身而只是复制它的地址，复制地址(通常一个指针的大小)需要很小的内存，效率也很好。二对于其他引用同一个对象的其他变量也不会造成影响。\n\n字符串常量池是java堆内存中一个特殊的存储区域，当创建一个String对象，假如此字符串值已经存在于常量池中，则不会创建一个新的对象，而是引用已经存在的对象。\n\n代码如下：\n```java\n　　String s1 = \"ABC\";\n\n　　String s2 = \"ABC\";\n```\n\n在java中内存分为堆内存和栈内存，**堆内存存放的是对象，栈内存存储对象的引用**，字符串“ABC”存放在堆内存中，而s1,s2作为对象的引用则存放在栈内存中，原理如下：\n\n```\n　　　　 　 　堆内存      栈内存\n\n String对象  \"ABC\"______ s1  String变量的引用\n\n             　　      |______ s2\n```\n\n**假设：字符串对象允许改变，那么将会导致各种逻辑错误。比如改变一个对象却影响到另外一个独立的对象。**\n\n思考题：以下代码，s1和s2还会指向同一个对象吗？\n\n```java\n　　String s1 = \"AB\"+\"C\";\n\n　　String s2 = \"A\"+\"BC\";\n```\n\n现代编译器会进行常规的优化所以**他们都会指向常量池中的同一个对象**。\n\n## 2.运行String对象缓存HashCode\n\njava中String对象的哈希码被频繁的使用，比如在HashMap的容器中。\n\n字符串不变性保证了hash码的唯一性，因此可以放心的进行缓存，这也是一种性能优化手段，意味着不必每次都去计算新的哈希码，在String类的定义中有如下代码：\n\n```java\n　　private int hash;//用来缓存HashCode\n```\n\n## 3.安全性\n\nString被许多的Java类(库)用来当做参数,例如 网络连接地址URL,文件路径path,\n\n还有反射机制所需要的String参数等, 假若String不是固定不变的,将会引起各种安全隐患。\n\n如果字符串是可变的，那么会引起很严重的安全问题。譬如，数据库的用户名、密码都是以字符串的形式传入来获得数据库的连 接，或者在socket编程中，主机名和端口都是以字符串的形式传入。因为字符串是不可变的，所以它的值是不可改变的，否则黑客们可以钻到空子，改变字符串指向的对象的值，造成安全漏洞。\n\n总体来说, String不可变的原因包括**设计考虑,效率优化问题,以及安全性**这三大方面.\n\n事实上,这也是Java面试中的许多 \"为什么\" 的答案。\n\n## 4.不可变对象对于多线程是安全的\n\n在多线程同时进行的情况下，一个可变对象的值很可能被其他线程改变，这样会造成不可预期的结果，而使用不可变对象就可以避免这种情况出现。因为字符串是不可变的，所以是多线程安全的，同一个字符串实例可以被多个线程共享。这样便不用因为线程安全问题而使用同步。字符串自己便是线程安全的。\n\n## 5.字符串的处理速度要快过其它的键对象\n因为字符串是不可变的，所以在它创建的时候hashcode就被缓存了，不需要重新计算。这就使得字符串很适合作为Map中的键，字符串的处理速度要快过其它的键对象。这就是HashMap中的键往往都使用字符串的原因。\n\n## 二、是否不需要可变类型了呢？\n\n当然不是，当你需要向字符串插入或修改的时候，Sting不可变类型就显得足襟见肘，这时候就需要一个可变的字符串类型：`StringBuffer`。\n\n`StringBuffer`与`String`一样，都代表字符串，但是由于`StringBuffer`内部实现的方式和`String`不同，所以`StringBuffer`在处理字符串的时候不产生新的对象，在内存使用上优于String类。","tags":["数据结构"]},{"title":"什么时候该用List, Set, Map？","url":"/2020/11/03/什么时候该用List, Set, Map？/","content":"\n\n*集合包含Collection和map接口，而Collection又由两个字接口——List和Set构成，每个子接口又有自己不同的实现类…听起来晕晕的，初学者如何分辨和应用它们？*\n\n \n\n**List接口**\n\n​    List是有序的Collection，使用此接口能够精确的控制每个元素插入的位置。用户能够使用索引来访问List中的元素，类似数组。List**允许有相同的元素。**\n\n　　实现List接口的常用类有**LinkedList，ArrayList，Vector**。\n\n\n\n\n- **ArrayList类**\n\n​    ArrayList是最常用的List实现类，它实现了可变大小的数组。它允许所有元素，包括null。ArrayList没有同步。\n\nsize，isEmpty，get，set方法运行时间为常数。但是add方法开销为分摊的常数，添加n个元素需要O(n)的时间。其他的方法运行时间为线性。\n　　每个ArrayList实例都有一个容量（Capacity），即用于存储元素的数组的大小。这个容量可随着不断添加新元素而自动增加，但是增长算法并没有定义。当需要插入大量元素时，在插入前可以调用ensureCapacity方法来增加ArrayList的容量以提高插入效率。\n\n \n\n- **LinkedList类**\n\nLinkedList实现了List接口，允许null元素。此外LinkedList提供额外的get，remove，insert方法在 LinkedList的首部或尾部。这些操作使LinkedList可被用作堆栈（stack），队列（queue）或双向队列（deque）。\n\n \n\n- **Vector类**\n\n \n\nVector非常类似ArrayList，但是Vector是同步的。由Vector创建的Iterator，虽然和ArrayList创建的 Iterator是同一接口，但是，因为Vector是同步的，当一个Iterator被创建而且正在被使用，另一个线程改变了Vector的状态（例如，添加或删除了一些元素），这时调用Iterator的方法时将抛出ConcurrentModificationException，因此必须捕获该异常。\n\n \n\n**Set接口**\n\n　　Set是一种**不包含重复的元素的Collection**，即任意的两个元素e1和e2都有e1.equals(e2)=false，Set最多有一个null元素。很明显，Set的构造函数有一个约束条件，传入的Collection参数不能包含重复的元素。\n　　请注意：必须小心操作可变对象（Mutable Object）。如果一个Set中的可变元素改变了自身状态导致Object.equals(Object)=true将导致一些问题。\n\n \n\n**Map接口**\n\n　　  Map没有继承Collection接口，Map提供key到value的映射。一个Map中**不能包含相同的****key**，每个key只能映射一个value。Map接口提供3种集合的视图，Map的内容可以被当作一组key集合，一组value集合，或者一组key-value映射。\n\n\n\n\n-  **Hashtable类**\n\nHashtable继承Map接口，实现一个key-value映射的哈希表。任何非空（non-null）的对象都可作为key或者value。\n　　添加数据使用put(key, value)，取出数据使用get(key)，这两个基本操作的时间开销为常数。Hashtable是同步的。\n\n\n\n\n- **HashMap类**\n\nHashMap和Hashtable类似，不同之处在于HashMap是非同步的，并且允许null，即null value和null key。但是将HashMap视为Collection时（values()方法可返回Collection），其迭代子操作时间开销和HashMap 的容量成比例。因此，如果迭代操作的性能相当重要的话，不要将HashMap的初始化容量设得过高，或者load factor过低。\n\n \n\n**总结**\n\n　　\n\n \n\n1. **如果涉及到堆栈，队列等操作，应该考虑用List，对于需要快速插入，删除元素，应该使用LinkedList，如果需要快速随机访问元素，应该使用ArrayList。**\n2. **如果程序在单线程环境中，或者访问仅仅在一个线程中进行，考虑非同步的类，其效率较高，如果多个线程可能同时操作一个类，应该使用同步的类。**\n3. **要特别注意对哈希表的操作，作为key的对象要正确复写equals和hashCode方法。**\n4. **尽量返回接口而非实际的类型，如返回List而非ArrayList，这样如果以后需要将ArrayList换成LinkedList时，客户端代码不用改变。这就是Java面向对象编程中抽象和多态思维的体现。**\n\n\n\n待整理：\n\nhttps://blog.csdn.net/zhangqunshuai/article/details/80660974","tags":["数据结构"]},{"title":"spring5","url":"/2020/11/01/spring5/","content":"\n## 一、Spring 框架概述\n\n1、Spring 是轻量级的开源的 JavaEE 框架 \n\n2、Spring 可以解决企业应用开发的复杂性\n\n3、Spring 有两个核心部分：IOC 和 Aop \n\n==（1）IOC：控制反转，把创建对象过程交给 Spring 进行管理== \n\n==（2）Aop：面向切面，不修改源代码进行功能增强==\n\n4、Spring 特点 \n\n（1）方便解耦，简化开发\n\n （2）Aop 编程支持 \n\n（3）方便程序测试 \n\n（4）方便和其他框架进行整合 \n\n（5）方便进行事务操作 \n\n（6）降低 API 开发难度\n\n## 二、入门案例\n\n1、下载spring后创建Java工程并导入相关jar包\n\n![image-20210119110144781](C:%5CUsers%5CPowerwenwh%5CDocuments%5C_posts%5Cimgs%5Cspring5%5Cimage-20210119110144781.png)\n\n2、创建普通类，在这个类创建普通方法\n\n```java\npublic class User { \n    public void add() { \n        System.out.println(\"add......\");\n    } \n}\n```\n\n3、创建Spring配置文件，在配置文件配置创建的对象\n\nSpring配置文件使用xml格式\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?> \n<beans xmlns=\"http://www.springframework.org/schema/beans\" \n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n                           http://www.springframework.org/schema/beans/spring-beans.xsd\">\n    <!--配置User对象创建-->\n    <bean id=\"user\" class=\"com.atguigu.spring5.User\"></bean>\n</beans>\n```\n\n\n\n4、进行测试代码编写\n\n```java\n@Test \npublic void testAdd() { \n    //1 加载spring配置文件 \n    ApplicationContext context = new ClassPathXmlApplicationContext(\"bean1.xml\"); \n    //2 获取配置创建的对象 \n    User user = context.getBean(\"user\", User.class); \n    System.out.println(user);//输出全类名和地址 \n    user.add(); //add......\n}\n```\n\n## 三、IOC\n\n### 概念和原理\n\n1、什么是IOC\n（1）控制反转，把对象创建和对象之间的调用过程，交给Spring进行管理\n（2）使用IOC目的：==为了耦合度降低==\n（3）做入门案例就是IOC实现\n\n2、IOC底层原理\n（1）xml解析、工厂模式、反射\n\n3、画图讲解IOC底层原理\n![image-20210119105608434](C:%5CUsers%5CPowerwenwh%5CDocuments%5C_posts%5Cimgs%5Cspring5%5Cimage-20210119105608434.png)\n\n### BeanFactory接口\n\n1、IOC思想基于IOC容器完成，IOC容器底层就是对象工厂\n2、Spring提供IOC容器实现两种方式：（两个接口）\n（1）BeanFactory：IOC容器基本实现，是Spring内部的使用接口，不提供开发人员进行使用\n+ 加载配置文件时候不会创建对象，在获取对象（使用）才去创建对象\n\n（2）ApplicationContext：BeanFactory接口的子接口，提供更多更强大的功能，一般由开发人员进行使用\n\n+ 加载配置文件时候就会把在配置文件对象进行创建\n\n3、ApplicationContext接口有实现类\n![image-20210119112255505](C:%5CUsers%5CPowerwenwh%5CDocuments%5C_posts%5Cimgs%5Cspring5%5Cimage-20210119112255505.png)\n\n### IOC操作 Bean管理（概念） \n\n1、什么是Bean管理\n（0）Bean管理指的是两个操作\n\n+ Spring创建对象\n+ Spirng注入属性\n\n2、Bean管理操作有两种方式\n（1）基于xml配置文件方式实现\n（2）基于注解方式实现\n\n### IOC操作 Bean管理 (基于注解方式)\n\n1、 什么是注解\n（1）注解是代码特殊标记，格式：@注解名称(属性名称=属性值, 属性名称=属性值..)\n（2）使用注解，注解作用在类上面，方法上面，属性上面\n（3）使用注解目的：简化xml配置\n\n2、Spring针对Bean管理中创建对象提供注解\n（1）@Component\n（2）@Service\n（3）@Controller\n（4）@Repository\n\n+ 上面四个注解功能是一样的，都可以用来创建bean实例\n\n3、基于注解方式实现对象创建\n第一步 引入依赖\n\n![image-20210119174609094](C:%5CUsers%5CPowerwenwh%5CDocuments%5C_posts%5Cimgs%5Cspring5%5Cimage-20210119174609094.png)\n\n第二步 开启组件扫描 \n\n```xml\n<!--开启组件扫描 \n1 如果扫描多个包，多个包使用逗号隔开 \n2 扫描包上层目录 --> \n<context:component-scan base-package=\"com.atguigu\">/context:component-scan\n\n```\n\n第三步 创建类,在类上面添加创建对象注解\n\n```java\n//在注解里面value属性值可以省略不写， \n//默认值是类名称，首字母小写\n//UserService -- userService\n@Component(value = \"userService\") //<bean id=\"userService\" class=\"..\"/> \npublic class UserService { \n    public void add() { \n        System.out.println(\"service add.......\"); \n    } \n}\n```\n\n4、开启组件扫描细节配置\n\n```xml\n <!--示例1 \nuse-default-filters=\"false\" 表示现在不使用默认filter，自己配置filter \ncontext:include-filter ，设置扫描哪些内容 --> \n<context:component-scan base-package=\"com.atguigu\" use-default-filters=\"false\">\n    <context:include-filter type=\"annotation\" expression=\"org.springframework.stereotype.Controller\"/> </context:component-scan>\n    <!--示例2 \n下面配置扫描包所有内容 context:exclude-filter： 设置哪些内容不进行扫描 -->\n<context:component-scan base-package=\"com.atguigu\">\n    <context:exclude-filter type=\"annotation\" expression=\"org.springframework.stereotype.Controller\"/> </context:component-scan>\n```\n\n5、基于注解方式实现属性注入\n（1）@Autowired：根据属性类型进行自动装配\n第一步 把service和dao对象创建，在service和dao类添加创建对象注解\n第二步 在service注入dao对象，在service类添加dao类型属性，在属性上面使用注解\n\n```java\n@Service \npublic class UserService { \n    //定义dao类型属性 \n    //不需要添加set方法 \n    //添加注入属性注解\n    @Autowired \n    private UserDao userDao; \n    \n    public void add() { \n        System.out.println(\"service add.......\"); \n        userDao.add(); \n    }\n}\n```\n\n（2）@Qualifier：根据名称进行注入\n这个@Qualifier注解的使用，和上面@Autowired一起使用\n\n//定义dao类型属性 //不需要添加set方法//添加注入属性注解\n\n```java\n@Autowired //根据类型进行注入 \n@Qualifier(value = \"userDaoImpl1\") //根据名称进行注入 \nprivate UserDao userDao;\n```\n\n（3）@Resource：可以根据类型注入\n\n```java\n//@Resource //根据类型进行注入 \n@Resource(name = \"userDaoImpl1\") //根据名称进行注入\nprivate UserDao userDao;\n\n```\n\n（4）@Value：注入普通类型属性\n\n```java\n @Value(value = \"abc\")\nprivate String name;\n```\n\n6、完全注解开发 \n\n（1）创建配置类，替代xml配置文件 \n\n```java\n@Configuration //作为配置类，替代xml配置文件\n@ComponentScan(basePackages = {\"com.atguigu\"})\npublic class SpringConfig { \n} \n```\n\n\n\n（2）编写测试类 \n\n```java\n@Test \npublic void testService2() {\n    //加载配置类 \n    ApplicationContext context = new AnnotationConfigApplicationContext(SpringConfig.class); \n    UserService userService = context.getBean(\"userService\", UserService.class); \n    System.out.println(userService); \n    userService.add(); \n}\n```\n\n\n\n## 四、AOP\n\n### 概念\n\n1、什么是AOP \n\n（1）面向切面编程（方面），利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。\n（2）通俗描述：不通过修改源代码方式，在主干功能里面添加新功能\n（3）使用登录例子说明AOP\n\n![image-20210119180333459](C:%5CUsers%5CPowerwenwh%5CDocuments%5C_posts%5Cimgs%5Cspring5%5Cimage-20210119180333459.png)\n\n### AOP（底层原理）\n\n1、AOP底层使用动态代理\n\n（1）有两种情况动态代理\n\n第一种 有接口情况，使用JDK动态代理\n\n+ 创建接口实现类代理对象，增强类的方法\n\n  ![image-20210119203435084](C:%5CUsers%5CPowerwenwh%5CDocuments%5C_posts%5Cimgs%5Cspring5%5Cimage-20210119203435084.png)\n\n第二种 没有接口情况，使用CGLIB动态代理\n\n+ 创建子类的代理对象，增强类的方法\n  ![image-20210119203418805](C:%5CUsers%5CPowerwenwh%5CDocuments%5C_posts%5Cimgs%5Cspring5%5Cimage-20210119203418805.png)\n\n### JDK 动态代理\n\n1、使用JDK动态代理，使用Proxy类里面的方法创建代理对象\n\n![image-20210119204311177](C:%5CUsers%5CPowerwenwh%5CDocuments%5C_posts%5Cimgs%5Cspring5%5Cimage-20210119204311177.png)\n\n（1）调用newProxyInstance方法\n\n![image-20210119204324994](C:%5CUsers%5CPowerwenwh%5CDocuments%5C_posts%5Cimgs%5Cspring5%5Cimage-20210119204324994.png)\n\n方法有三个参数：\n第一参数，类加载器\n第二参数，增强方法所在的类，这个类实现的接口，支持多个接口\n第三参数，实现这个接口InvocationHandler，创建代理对象，写增强的部分\n\n2、编写JDK动态代理代码\n\n（1）创建接口，定义方法\n\n```java\n public interface UserDao { \n     public int add(int a,int b); \n     public String update(String id); \n }\n```\n\n\n（2）创建接口实现类，实现方法\n\n```java\n public class UserDaoImpl implements UserDao { \n     @Override \n     public int add(int a, int b) { \n         return a+b; \n     } \n     @Override public String update(String id) { \n         return id; \n     } \n }\n```\n\n（3）使用Proxy类创建接口代理对象\n\n```java\npublic class JDKProxy { \n    public static void main(String[] args){ \n    //创建接口实现类代理对象 \n    Class[] interfaces = {UserDao.class}; \n    // Proxy.newProxyInstance(JDKProxy.class.getClassLoader(), interfaces, new InvocationHandler() { \n    // @Override \n    // public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { \n    // return null; \n    // } \n    // });\n    UserDaoImpl userDao = new UserDaoImpl(); \n    UserDao dao = (UserDao)Proxy.newProxyInstance(JDKProxy.class.getClassLoader(), interfaces, new UserDaoProxy(userDao));\n    int result = dao.add(1, 2); System.out.println(\"result:\"+result); \n\t} \n}\n//创建代理对象代码 \nclass UserDaoProxy implements InvocationHandler { \n    //1 把创建的是谁的代理对象，把谁传递过来 \n    //有参数构造传递 \n    private Object obj; public UserDaoProxy(Object obj) { this.obj = obj; } \n    //增强的逻辑 \n    @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { \n        //方法之前 \n        System.out.println(\"方法之前执行....\"+method.getName()+\" :传递的参数...\"+ Arrays.toString(args)); \n        //被增强的方法执行 \n        Object res = method.invoke(obj, args); \n        //方法之后 \n        System.out.println(\"方法之后执行....\"+obj); \n        return res; \n    }\n}\n```\n\n### 术语\n\n1、连接点\n\n+ 类里面可以增强的方法\n\n2、切入点\n\n+ 实际被增强的方法\n\n3、通知（增强）\n\n+ 实际增强的逻辑部分\n  + 前置通知\n  + 后置通知\n  + 环绕通知\n  + 异常通知\n  + 最终通知\n\n4、切面\n\n+ 是一个动作，把通知应用到切入点的过程","tags":["框架学习"]},{"title":"List接口","url":"/2020/10/20/List接口/","content":"## List的性质\n\n**有序的 collection（也称为序列）**。此接口的用户可以对列表中每个元素的插入位置进行精确地控制。用户可以根据元素的整数索引（在列表中的位置）访问元素，并搜索列表中的元素。\n\n与 set 不同，列表通常允许重复的元素。更确切地讲，列表通常允许满足 e1.equals(e2) 的元素对 e1 和 e2，并且如果列表本身允许 null 元素的话，通常它们允许多个 null 元素。难免有人希望通过在用户尝试插入重复元素时抛出运行时异常的方法来禁止重复的列表，但我们希望这种用法越少越好。\n\nList 接口提供了 4 种对列表元素进行定位（索引）访问方法。列表（像 Java 数组一样）是基于 0 的。注意，这些操作可能在和某些实现（例如 LinkedList 类）的索引值成比例的时间内执行。因此，如果调用者不知道实现，那么**在列表元素上迭代通常优于用索引遍历列表。**\n\nList 接口提供了两种搜索指定对象的方法。从性能的观点来看，应该小心使用这些方法。在很多实现中，它们将执行高开销的线性搜索。\n\nList 接口提供了两种在列表的任意位置高效插入和移除多个元素的方法。\n\n注意：尽管列表允许把自身作为元素包含在内，但建议要特别小心：在这样的列表上，equals 和 hashCode 方法不再是定义良好的。 \n\n某些列表实现对列表可能包含的元素有限制。例如，某些实现禁止 null 元素，而某些实现则对元素的类型有限制。试图添加不合格的元素会抛出未经检查的异常，通常是 NullPointerException 或 ClassCastException。试图查询不合格的元素是否存在可能会抛出异常，也可能简单地返回 false；某些实现会采用前一种行为，而某些则采用后者。概括地说，试图对不合格元素执行操作时，如果完成该操作后不会导致在列表中插入不合格的元素，则该操作可能抛出一个异常，也可能成功，这取决于实现的选择。此接口的规范中将这样的异常标记为“可选”。 \n\n## Java 中初始化 List 的五种方法\n\n在 Java 中初始化 List 的五种方法\n\n1. 构造 List 后使用 List.add 初始化\n2. 使用`{{}}`双括号语法\n3. 使用 Arrays.asList\n4. 使用 Stream (JDK8)\n5. 使用 Lists （JDK9）\n\n### 1.构造 `List` 后使用 `List.add` 初始化\n\n```java\nList<String> stringList = new LinkedList<>();\nstringList.add(\"a\");\nstringList.add(\"b\");\nstringList.add(\"c\");\n```\n\n### 2.使用 `{{}}` 双括号语法\n\n```java\nList<String> stringList = new LinkedList<String>(){{\n    add(\"a\");\n    add(\"b\");\n    add(\"c\");\n}};\n```\n\n外层的 `{}` 定义了一个 LinkedList 的匿名内部类。内层的 `{}` 的定义了一个实例初始化代码块。 这个代码块在初始化内部类时执行。所以这里相当于定义了一个匿名内部类，并使用 `add` 添加元素来初始化。\n\n这种方式有几个缺点：\n\n- 使用匿名内部类，会有效率上的损失。当然在大多数情况下，这点效率都是可接受的。\n- 静态内部类持有所在外部类的引用。如果需要将 List 返回给到其他地方使用，可能造成内存泄漏。\n\n### 3.使用 `Arrays.asList`\n\n```java\nList<String> stringList = Arrays.asList(\"a\", \"b\", \"c\");\n```\n\n这种方式使用了 `java.util.Arrays` 的静态方法。写法上比之前的两种都更简洁，也没有构造匿名内部类的效率问题。\n\n但也有几点需要注意：\n\n- `Arrays.asList` 返回的是 `Arrays` 的静态内部类（静态内部类不持有所在外部类的引用）。\n\n这个内部类继承自 `AbstractList`，实现了 `RandomAccess`，内部使用了一个数组来存储元素。但是不支持增删元素。这点需要注意。如果只是使用 `Arrays.asList` 来初始化常量，那么这点就不算什么问题了。\n\n- `Arrays.asList` 的参数如果是基本类型的数组时，需要留意返回值可能和你预期的不同。\n\n```java\nint[] intArray = new int[]{1, 2, 3};\nInteger[] integerArray = new Integer[]{1, 2, 3};\n \nList<int[] > intArrayList = Arrays.asList(intArray);\nList<Integer> integerList = Arrays.asList(integerArray);\nList<Integer> integerList2 = Arrays.asList(1, 2, 3);\n```\n\n这里 `Arrays.asList(intArray)` 的返回值是 `List<int[]>` 而不是 `List<Integer>`。这一点也算不上问题，只是使用时需要留意。如果能在 Java 中做到尽量使用 List 和 Integer，尽量避免使用 int 等基本类型和 `[]` 这种较为底层的数据结构即可避免。\n\n### 4. 使用 `Stream` (JDK8)\n\n```java\nList<String> list = Stream.of(\"a\", \"b\", \"c\").collect(Collectors.toList());\n```\n\n使用了 JDK8 的 Stream 来初始化。 单纯初始化 List，使用 Stream 有点大材小用了。\n\n### 5. 使用 `Lists` （JDK9）\n\n```java\nList<String> list = Lists.newArrayList(\"a\", \"b\", \"c\");\n```\n\n这个和 `Arrays.asList` 一样简洁清晰。\n\n\n\n## 方法摘要\n\n**add**\n\nboolean add(E e)  \n向列表的尾部添加指定的元素（可选操作）。  \n\n参数：  \ne - 要添加到列表的元素   \n\n\n返回：  \ntrue（根据 Collection.add(E) 的规定） \n\n\n**add**  \nvoid add(int index, E element)  \n在列表的指定位置插入指定元素（可选操作）。将当前处于该位置的元素（如果有的话）和所有后续元素向右移动（在其索引中加 1）。 \n\n参数：  \nindex - 要在其中插入指定元素处的索引\nelement - 要插入的元素 \n","tags":["数据结构"]},{"title":"递归和迭代的区别、联系、优缺点及实例对比","url":"/2020/10/17/递归和迭代的区别、联系、优缺点/","content":"\n## 1.概念区分\n\n### 递归\n\n程序调用自身的编程技巧称为递归,是函数自己调用自己\n\n一个函数在其定义中直接或间接调用自身的一种方法,它通常把一个大型的复杂的问题转化为一个与原问题相似的规模较小的问题来解决,可以极大的减少代码量.递归的能力在于用有限的语句来定义对象的无限集合\n\n使用递归要注意的有两点:\n\n1. 递归就是在过程或函数里面调用自身\n\n2. 在使用递归时,必须有一个明确的递归结束条件,称为**递归出口**\n\n递归分为两个阶段:\n\n1)递推:把复杂的问题的求解推到比原问题简单一些的问题的求解;\n\n2)回归:当获得最简单的情况后,逐步返回,依次得到复杂的解.\n\n利用递归可以解决很多问题:如背包问题,汉诺塔问题,...等.\n\n斐波那契数列为:0,1,1,2,3,5...\n\n**由于递归引起一系列的函数调用,并且有可能会有一系列的重复计算,递归算法的执行效率相对较低.**\n\n### 迭代\n\n利用变量的原值推算出变量的一个新值,如果递归是自己调用自己的话,迭代就是A不停的调用B\n\n## 2.辩证看递归和迭代\n\n递归的使用可以使代码更简洁清晰，可读性更好，但由于递归需要系统堆栈，所以空间消耗要比非递归代码要大很多，而且，如果递归深度太大，可能系统资源会不够用。\n\n**往往有这样的观点：能不用递归就不用递归，递归都可以用迭代来代替。**\n\n在理论上，递归和迭代在时间复杂度方面是等价的（在不考虑函数调用开销和函数调用产生的堆栈开销），但实际上递归确实效率比迭代低，递归没有任何优势，是不是就没有使用递归的必要了，那递归的存在有何意义呢？\n\n从算法结构来说，递归声明的结构并不总能够转换为迭代结构，原因在于结构的引申本身属于递归的概念，**用迭代的方法在设计初期根本无法实现**。这也是为什么在结构设计时，通常采用递归的方式而不是采用迭代的方式的原因，一个极典型的例子类似于链表，使用递归定义及其简单，但对于内存定义(数组方式)其定义及调用处理说明就变得很晦涩，尤其是在遇到环链、图、网格等问题时，使用迭代方式从描述到实现上都变得不现实。因而可以从实际上说，所有的迭代可以转换为递归，但递归不一定可以转换为迭代。\n\n递归其实是方便了程序员难为了机器，递归可以通过数学公式很方便的转换为程序。其优点就是易理解，容易编程。但**递归是用栈机制实现的，每深入一层，都要占去一块栈数据区域，对嵌套层数深的一些算法，递归会力不从心，空间上会以内存崩溃而告终，而且递归也带来了大量的函数调用，这也有许多额外的时间开销。所以在深度大时，它的时空性就不好了。**\n\n而迭代虽然效率高，运行时间只因循环次数增加而增加，没什么额外开销，空间上也没有什么增加，但缺点就是不容易理解，编写复杂问题时困难。\n\n\n## 3.总结\n\n-|定义|优点|缺点\n---|:---|:---|:---\n递归|程序调用自身的编程技巧称为递归|1）大问题化为小问题,可以极大的减少代码量；<br>2）用有限的语句来定义对象的无限集合<br>3）代码更简洁清晰，可读性更好|1）递归调用函数,浪费空间<br>2）递归太深容易造成堆栈的溢出；\n迭代|利用变量的原值推算出变量的一个新值，迭代就是A不停的调用B|1）迭代效率高，运行时间只因循环次数增加而增加<br>2）没什么额外开销，空间上也没有什么增加，|1） 不容易理解<br>2） 代码不如递归简洁<br>3） 编写复杂问题时困难。\n\n**二者关系**\n\n1. 递归中一定有迭代,但是迭代中不一定有递归,大部分可以相互转换\n\n2. 能用迭代的不用递归,递归调用函数,浪费空间,并且递归太深容易造成堆栈的溢出\n\n","tags":["操作系统、计网、算法、数据结构、数据库"]},{"title":"RequestMapping注解","url":"/2020/10/17/springmvc三个重要注解/","content":"\n## RequestMapping注解\n\n**作用：** 用于建立请求URL和处理请求方法之间的对应关系。  \n**出现位置：**  \n\n+ **类上：**  \n请求URL的第一级访问目录。此处不写的话，就相当于应用的根目录。写的话需要以/开头。 它出现的目的是为了使我们的URL可以按照模块化管理:  \n  + 例如：  \n账户模块：  \n*/account/*add  \n        */account/*update  \n        */account/*delete ...  \n订单模块:  \n */order/*add  \n*/order/*update  \n*/order/*delete  \n*/.../*的部分就是把RequsetMappding写在类上，使我们的URL更加精细。  \n\n+ **方法上：**  \n请求URL的第二级访问目录。\n\n**属性：**  \n\n+ value：用于指定请求的URL。它和path属性的作用是一样的。\n+ method：用于指定请求的方式。(eg:get请求/post请求)\n+ params：用于指定限制请求参数的条件。它支持简单的表达式。要求请求参数的key和value必须和配置的**一模一样!!!**  \n  + 例如：  \nparams = {\"accountName\"}，表示请求参数必须有accountName  \nparams = {\"moeny!100\"}，表示请求参数中money不能是100。\n+ headers：用于指定限制请求消息头的条件。  \n注意： 以上四个属性只要出现2个或以上时，他们的关系是与的关系。\n\n**使用示例：**\n\n+ 出现位置的示例：\n\n```java\n/**\n*RequestMapping 注解出现的位置\n*/\n@Controller(\"accountController\") @RequestMapping(\"/account\")//RequestMapping作用于类上\npublic class AccountController {\n@RequestMapping(\"/findAccount\")//RequestMapping作用于方法上\npublic String findAccount() { \n        System.out.println(\"查询了账户。。。。\");\n        return \"success\";\n}\n```\n\n```html\njsp 中的代码：\n<%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%>\n<!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\">\n<html>\n<head>\n<meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\">\n<title>requestmapping 的使用</title>\n</head>\n<body>\n<!-- 第一种访问方式 -->\n<a href=\"${pageContext.request.contextPath}/account/findAccount\">查询账户</a>\n<br/>\n<!-- 第二种访问方式 -->\n<a href=\"account/findAccount\">查询账户</a>\n</body>\n</html>\n注意：\n当我们使用此种方式配置时，在 jsp 中第二种写法时，不要在访问 URL 前面加/，否则无法找到资源。\n```\n\n+ method 属性的示例：\n\n```java\n控制器代码：\n/**\n*保存账户\n*@return\n*/\n@RequestMapping(value=\"/saveAccount\",method=RequestMethod.POST) \npublic String saveAccount() {\n        System.out.println(\"保存了账户\");\n        return \"success\";\n}\n```\n\n```html\njsp 代码：\n<!-- 请求方式的示例 -->\n<a href=\"account/saveAccount\">保存账户，get 请求</a>\n<br/>\n<form action=\"account/saveAccount\" method=\"post\">\n<input type=\"submit\" value=\"保存账户，post 请求\">\n</form>\n\n注意：\n当使用 get 请求时，提示错误信息是 405，信息是方法不支持 get 方式请求\n```\n\n+ params 属性的示例：\n\n```java\n控制器的代码：\n/**\n*\t删除账户\n*\t@return\n*/\n@RequestMapping(value=\"/removeAccount\",params= {\"accountName\",\"money>100\"})\npublic String removeAccount() { \n        System.out.println(\"删除了账户\"); \n        return \"success\";\n}\n```\n\n```html\njsp 中的代码：\n<!-- 请求参数的示例 -->\n<a href=\"account/removeAccount?accountName=aaa&money>100\">删除账户，金额 100</a>\n<br/>\n<a href=\"account/removeAccount?accountName=aaa&money>150\">删除账户，金额 150</a>\n注意：\n当我们点击第一个超链接时,可以访问成功。\n当我们点击第二个超链接时，提示错误信息是 400,无法访问。\n```\n\n## RequestParam\n\n**作用：**\n把请求中指定名称的参数给控制器中的形参赋值。  \n**属性：**\n\n+ value：请求参数中的名称。\n+ required：请求参数中是否必须提供此参数。默认值：true。表示必须提供，如果不提供将报错。  \n\n**使用示例：**\n\n```html\njsp 中的代码：\n<!-- requestParams 注解的使用 -->\n<a href=\"springmvc/useRequestParam?name=test\">requestParam 注解</a> \n```\n\n```java\n控制器中的代码：\n/**\n*requestParams 注解的使用\n*@param username\n*@return\n*/\n@RequestMapping(\"/useRequestParam\")\npublic String useRequestParam(@RequestParam(\"name\")String username,\n@RequestParam(value=\"age\",required=false)Integer age){ \n        System.out.println(username+\",\"+age);\n        return \"success\";\n}\n```\n\n## RequestBody\n\n**作用：** 用于获取请求体内容。直接使用得到是 key=value&key=value...结构的数据。get 请求方式不适用。  \n**属性：**  \n\n+ required：是否必须有请求体。默认值是:true。当取值为 true 时,get 请求方式会报错。如果取值为 false，get 请求得到是 null。\n\n**使用示例：**\n\n```html\npost 请求 jsp 代码：\n<!-- request body 注解 -->\n<form action=\"springmvc/useRequestBody\" method=\"post\">\n用户名称：<input type=\"text\" name=\"username\" ><br/>\n用户密码：<input type=\"password\" name=\"password\" ><br/>\n用户年龄：<input type=\"text\" name=\"age\" ><br/>\n<input type=\"submit\" value=\"保存\">\n</form>\nget 请求 jsp 代码：（得到是空）\n<a href=\"springmvc/use\nRequestBody?body=test\">requestBody 注解 get 请求</a>\n```\n\n```java\n控制器代码：\n/**\n*RequestBody 注解\n*@param user\n*@return\n*/ @RequestMapping(\"/useRequestBody\")\npublic String useRequestBody(@RequestBody(required=false) String body) { \n        System.out.println(body);\n        return \"success\";\n}\n```\n\n## PathVaribale\n\n**作用：** 用于绑定 url 中的占位符。\n\n+ 例如：请求 url 中 /delete/{id}，这个{id}就是 url 占位符。url 支持占位符是 spring3.0 之后加入的。是 springmvc 支持 rest 风格 URL 的一个重要标志。  \n\n**属性：**\n\n+ value：用于指定 url 中占位符名称。\n+ required：是否必须提供占位符。\n\n**使用示例:**  \n\n```html\njsp 代码：\n<!-- PathVariable 注解 -->\n<a href=\"springmvc/usePathVariable/100\">pathVariable 注解</a> \n```\n\n```java\n控制器代码：\n/**\n*PathVariable 注解\n*@param user\n* @return\n*/ @RequestMapping(\"/usePathVariable/{id}\")\npublic String\tusePathVariable(@PathVariable(\"id\") Integer id) {\n        System.out.println(id);\n        return \"success\";\n}\n","tags":["框架学习"]},{"title":"static关键字","url":"/2020/10/17/static关键字/","content":"\n**概念**\n\nstatic有三种用法：static变量，static方法，static代码块\n\n## static变量\n在类中，使用 static 修饰符修饰的属性（成员变量）称为静态变量，也可以称为类变量，常量称为静态常量，方法称为静态方法或类方法，它们统称为静态成员，归整个类所有。\n\n静态成员不依赖于类的特定实例，被类的所有实例共享，就是说 static 修饰的方法或者变量不需要依赖于对象来进行访问，只要这个类被加载，Java 虚拟机就可以根据类名找到它们。\n\n调用静态成员的语法形式如下：\n类名.静态成员\n注意：\nstatic 修饰的成员变量和方法，从属于类。\n普通变量和方法从属于对象。\n静态方法不能调用非静态成员，编译会报错。\n\n静态变量\n类的成员变量可以分为以下两种：\n静态变量（或称为类变量），指被 static 修饰的成员变量。\n实例变量，指没有被 static 修饰的成员变量。\n\n静态变量与实例变量的区别如下：\n\n1）静态变量\n运行时，Java 虚拟机只为静态变量分配一次内存，在加载类的过程中完成静态变量的内存分配。\n在类的内部，可以在任何方法内直接访问静态变量。\n在其他类中，可以通过类名访问该类中的静态变量。\n\n2）实例变量\n每创建一个实例，Java 虚拟机就会为实例变量分配一次内存。\n在类的内部，可以在非静态方法中直接访问实例变量。\n在本类的静态方法或其他类中则需要通过类的实例对象进行访问。\n\n静态变量在类中的作用如下：\n**静态变量可以被类的所有实例共享，因此静态变量可以作为实例之间的共享数据，增加实例之间的交互性。**  \n如果类的所有实例都包含一个相同的常量属性，则可以把这个属性定义为静态常量类型，从而**节省内存空间**。例如，在类中定义一个静态常量 PI。\n\n从运行结果可以看出，在类中定义静态的属性（成员变量），在 main() 方法中可以直接访问，也可以通过类名访问，还可以通过类的实例对象来访问。\n\n注意：静态变量是被多个实例所共享的。\n\n静态方法\n与成员变量类似，成员方法也可以分为以下两种：\n静态方法（或称为类方法），指被 static 修饰的成员方法。\n实例方法，指没有被 static 修饰的成员方法。\n\n静态方法与实例方法的区别如下：\n**静态方法不需要通过它所属的类的任何实例就可以被调用**，因此在静态方法中**不能使用 this 关键字**，**也不能直接访问所属类的实例变量和实例方法**，但是可以直接访问所属类的静态变量和静态方法。另外，和 this 关键字一样，super 关键字也与类的特定实例相关，所以在静态方法中也**不能使用 super 关键字。**\n在实例方法中可以直接访问所属类的静态变量、静态方法、实例变量和实例方法。\n\n\n\njava中的static关键字主要用于内存管理。我们可以应用java static关键字在变量，方法，块和嵌套类中。 static关键字属于类，而不是类的实例。\n静态(static)可以是：\n\n变量(也称为类变量)方法(也称为类方法)代码块嵌套类\n1. Java静态变量如果将一个变量声明为static，它就是所谓的静态变量了。\n\n静态变量可以用于引用所有对象的公共属性(对于每个对象不是唯一的)。如：员工公司名称，学生所在的大学名称。\n静态变量的优点：\n\n它能使程序存储器高效(即它节省内存)。\n理解不使用静态变量的问题\nclass Student{  \n     int rollno;  \n     String name;  \n     String college=\"ITS\";  \n}\nJava\n假设在一所学校有500名学生，现在所有实例数据成员将在每次创建对象时获取内存。所有学生都有其唯一的注册ID：rollno和　name ，因此实例数据成员没有什么问题。college 指的是所有对象的共同属性。如果使它静态化(使用static关键字修饲)，这个字段将只获得内存一次。\n\nJava静态属性被共享给所有对象。\n\n静态变量的示例\n//Program of static variable  \n\nclass Student8 {\n    int rollno;\n    String name;\n    static String college = \"ITS\";\n\n    Student8(int r, String n) {\n        rollno = r;\n        name = n;\n    }\n    \n    void display() {\n        System.out.println(rollno + \" \" + name + \" \" + college);\n    }\n    \n    public static void main(String args[]) {\n        Student8 s1 = new Student8(111, \"Karan\");\n        Student8 s2 = new Student8(222, \"Aryan\");\n    \n        s1.display();\n        s2.display();\n    }\n}\nJava\n上面代码执行结果如下 -\n111 Karan ITS\n222 Aryan ITS\nJava\n创建对象示例图如下所示 -\n\n不使用静态变量的计数器程序\n在这个例子中，我们创建了一个名为count的实例变量用来统计创建对象的数目，它在构造函数中执行递增。 由于实例变量在创建对象时要获取内存，每个对象都将具有实例变量的副本，如果它被递增了，它也不会反映到其他对象中。所以每个对象在count变量中的值还是1。\nclass Counter {\n    int count = 0;// will get memory when instance is created\n\n    Counter() {\n        count++;\n        System.out.println(count);\n    }\n    \n    public static void main(String args[]) {\n    \n        Counter c1 = new Counter();\n        Counter c2 = new Counter();\n        Counter c3 = new Counter();\n    \n    }\n}\nJava\n上面代码执行结果如下 -\n1\n1\n1\nJava\n计数器静态变量的程序如上所述，静态变量将只获取一次内存，如果任何对象更改静态变量的值，它将保留其值，所有实例均可访问同一变量值。\nclass Counter2 {\n    static int count = 0;// will get memory only once and retain its value\n\n    Counter2() {\n        count++;\n        System.out.println(count);\n    }\n    \n    public static void main(String args[]) {\n    \n        Counter2 c1 = new Counter2();\n        Counter2 c2 = new Counter2();\n        Counter2 c3 = new Counter2();\n    \n    }\n}\nJava\n上面代码执行结果如下 -\n1\n2\n3\nJava\n2. Java静态方法如果在任何方法上应用static关键字，此方法称为静态方法。\n\n静态方法属于类，而不属于类的对象。可以直接调用静态方法，而无需创建类的实例。静态方法可以访问静态数据成员，并可以更改静态数据成员的值。\n静态方法的示例\n//Program of changing the common property of all objects(static field).  \n\nclass Student9 {\n    int rollno;\n    String name;\n    static String college = \"ITS\";\n\n    static void change() {\n        college = \"BBDIT\";\n    }\n    \n    Student9(int r, String n) {\n        rollno = r;\n        name = n;\n    }\n    \n    void display() {\n        System.out.println(rollno + \" \" + name + \" \" + college);\n    }\n    \n    public static void main(String args[]) {\n        Student9.change();\n    \n        Student9 s1 = new Student9(111, \"Karan\");\n        Student9 s2 = new Student9(222, \"Aryan\");\n        Student9 s3 = new Student9(333, \"Sonoo\");\n    \n        s1.display();\n        s2.display();\n        s3.display();\n    }\n}\nJava\n上面代码执行输出以下结果 - \n111 Karan BBDIT\n222 Aryan BBDIT\n333 Sonoo BBDIT\nJava\n执行正常计算的静态方法的另一个示例:\n//Program to get cube of a given number by static method  \n\nclass Calculate {\n    static int cube(int x) {\n        return x * x * x;\n    }\n\n    public static void main(String args[]) {\n        int result = Calculate.cube(5);\n        System.out.println(result);\n    }\n}\nJava\n上面代码执行输出以下结果 - \n125\nJava\n静态方法的限制\n静态方法有两个主要限制。它们分别是：\n\n静态方法不能直接使用非静态数据成员或调用非静态方法。this和super两个关键字不能在静态上下文中使用。\nclass A {\n    int a = 40;// non static\n\n    public static void main(String args[]) {\n        System.out.println(a);\n    }\n}\nJava\n上面代码执行输出以下结果 - \n[编译错误！]Compile Time Error\nJava\n为什么java main方法是静态的？\n这是因为对象不需要调用静态方法，如果它是非静态方法，jvm首先要创建对象，然后调用main()方法，这将导致额外的内存分配的问题。\n3. Java静态块Java中的静态块主要有两个作用：\n\n用于初始化静态数据成员。它在类加载时在main方法之前执行。\n静态块的示例\nclass A2 {\n    static {\n        System.out.println(\"static block is invoked\");\n    }\n\n    public static void main(String args[]) {\n        System.out.println(\"Hello main\");\n    }\n}\nJava\n上面代码执行输出以下结果 - \nstatic block is invoked\nHello main\nJava\n可以执行程序没有main()方法吗？答：是的，一种方式是静态块，但在以前旧的JDK版本中，不是在JDK 1.7。\nclass A3 {\n    static {\n        System.out.println(\"static block is invoked\");\n        System.exit(0);\n    }\n}\nJava\n上面代码执行输出以下结果 - \nstatic block is invoked\nJava\n在JDK7及以上版本中，输出将为：\n错误: 在类 Main 中找不到 main 方法, 请将 main 方法定义为:\n   public static void main(String[] args)//原文出自【易百教程】，商业转载请联系作者获得授权，非商业请保留原文链接：https://www.yiibai.com/java/static-keyword-in-java.html\n\n\n\n\n\n\n\n\n\n\n\n\nJava中的static关键字解析\n\n　　static关键字是很多朋友在编写代码和阅读代码时碰到的比较难以理解的一个关键字，也是各大公司的面试官喜欢在面试时问到的知识点之一。下面就先讲述一下static关键字的用法和平常容易误解的地方，最后列举了一些面试笔试中常见的关于static的考题。以下是本文的目录大纲：\n\n　　一.static关键字的用途\n\n　　二.static关键字的误区\n\n　　三.常见的笔试面试题\n\n　　若有不正之处，希望谅解并欢迎批评指正。\n\n　　请尊重作者劳动成果，转载请标明原文链接：\n\n　　http://www.cnblogs.com/dolphin0520/p/3799052.html\n\n一.static关键字的用途\n　　在《Java编程思想》P86页有这样一段话：\n\n　　“static方法就是没有this的方法。在static方法内部不能调用非静态方法，反过来是可以的。而且可以在没有创建任何对象的前提下，仅仅通过类本身来调用static方法。这实际上正是static方法的主要用途。”\n\n　　这段话虽然只是说明了static方法的特殊之处，但是可以看出static关键字的基本作用，简而言之，一句话来描述就是：\n\n　　方便在没有创建对象的情况下来进行调用（方法/变量）。\n\n　　很显然，被static关键字修饰的方法或者变量不需要依赖于对象来进行访问，只要类被加载了，就可以通过类名去进行访问。\n\n　　static可以用来修饰类的成员方法、类的成员变量，另外可以编写static代码块来优化程序性能。\n\n1）static方法\n\n　　static方法一般称作静态方法，由于静态方法不依赖于任何对象就可以进行访问，因此对于静态方法来说，是没有this的，因为它不依附于任何对象，既然都没有对象，就谈不上this了。并且由于这个特性，在静态方法中不能访问类的非静态成员变量和非静态成员方法，因为非静态成员方法/变量都是必须依赖具体的对象才能够被调用。\n\n　　但是要注意的是，虽然在静态方法中不能访问非静态成员方法和非静态成员变量，但是在非静态成员方法中是可以访问静态成员方法/变量的。举个简单的例子：\n\n\n\n　　在上面的代码中，由于print2方法是独立于对象存在的，可以直接用过类名调用。假如说可以在静态方法中访问非静态方法/变量的话，那么如果在main方法中有下面一条语句：\n\n　　MyObject.print2();\n\n　　此时对象都没有，str2根本就不存在，所以就会产生矛盾了。同样对于方法也是一样，由于你无法预知在print1方法中是否访问了非静态成员变量，所以也禁止在静态成员方法中访问非静态成员方法。\n\n　　而对于非静态成员方法，它访问静态成员方法/变量显然是毫无限制的。\n\n　　因此，如果说想在不创建对象的情况下调用某个方法，就可以将这个方法设置为static。我们最常见的static方法就是main方法，至于为什么main方法必须是static的，现在就很清楚了。因为程序在执行main方法的时候没有创建任何对象，因此只有通过类名来访问。\n\n　　另外记住，关于构造器是否是static方法可参考：http://blog.csdn.net/qq_17864929/article/details/48006835\n\n2）static变量\n\n　　static变量也称作静态变量，静态变量和非静态变量的区别是：静态变量被所有的对象所共享，在内存中只有一个副本，它当且仅当在类初次加载时会被初始化。而非静态变量是对象所拥有的，在创建对象的时候被初始化，存在多个副本，各个对象拥有的副本互不影响。\n\n　　static成员变量的初始化顺序按照定义的顺序进行初始化。\n\n3）static代码块\n\n　　static关键字还有一个比较关键的作用就是 用来形成静态代码块以优化程序性能。static块可以置于类中的任何地方，类中可以有多个static块。在类初次被加载的时候，会按照static块的顺序来执行每个static块，并且只会执行一次。\n\n　　为什么说static块可以用来优化程序性能，是因为它的特性:只会在类加载的时候执行一次。下面看个例子:\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\nclass Person{\n    private Date birthDate;\n     \n    public Person(Date birthDate) {\n        this.birthDate = birthDate;\n    }\n     \n    boolean isBornBoomer() {\n        Date startDate = Date.valueOf(\"1946\");\n        Date endDate = Date.valueOf(\"1964\");\n        return birthDate.compareTo(startDate)>=0 && birthDate.compareTo(endDate) < 0;\n    }\n}\n　　isBornBoomer是用来这个人是否是1946-1964年出生的，而每次isBornBoomer被调用的时候，都会生成startDate和birthDate两个对象，造成了空间浪费，如果改成这样效率会更好：\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\nclass Person{\n    private Date birthDate;\n    private static Date startDate,endDate;\n    static{\n        startDate = Date.valueOf(\"1946\");\n        endDate = Date.valueOf(\"1964\");\n    }\n     \n    public Person(Date birthDate) {\n        this.birthDate = birthDate;\n    }\n     \n    boolean isBornBoomer() {\n        return birthDate.compareTo(startDate)>=0 && birthDate.compareTo(endDate) < 0;\n    }\n}\n　　因此，很多时候会将一些只需要进行一次的初始化操作都放在static代码块中进行。\n\n二.static关键字的误区\n1.static关键字会改变类中成员的访问权限吗？\n\n　　有些初学的朋友会将java中的static与C/C++中的static关键字的功能混淆了。在这里只需要记住一点：与C/C++中的static不同，Java中的static关键字不会影响到变量或者方法的作用域。在Java中能够影响到访问权限的只有private、public、protected（包括包访问权限）这几个关键字。看下面的例子就明白了：\n\n\n\n　　提示错误\"Person.age 不可视\"，这说明static关键字并不会改变变量和方法的访问权限。\n\n2.能通过this访问静态成员变量吗？\n\n　　虽然对于静态方法来说没有this，那么在非静态方法中能够通过this访问静态成员变量吗？先看下面的一个例子，这段代码输出的结果是什么？\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\npublic class Main {　　\n    static int value = 33;\n\n    public static void main(String[] args) throws Exception{\n        new Main().printValue();\n    }\n     \n    private void printValue(){\n        int value = 3;\n        System.out.println(this.value);\n    }\n}\n\n\n\n33\n　　这里面主要考察队this和static的理解。this代表什么？this代表当前对象，那么通过new Main()来调用printValue的话，当前对象就是通过new Main()生成的对象。而static变量是被对象所享有的，因此在printValue中的this.value的值毫无疑问是33。在printValue方法内部的value是局部变量，根本不可能与this关联，所以输出结果是33。在这里永远要记住一点：静态成员变量虽然独立于对象，但是不代表不可以通过对象去访问，所有的静态方法和静态变量都可以通过对象访问（只要访问权限足够）。\n\n3.static能作用于局部变量么？\n\n　　在C/C++中static是可以作用域局部变量的，但是在Java中切记：static是不允许用来修饰局部变量。不要问为什么，这是Java语法的规定。\n\n　　具体原因可以参考这篇博文的讨论：http://www.debugease.com/j2se/178932.html\n\n三.常见的笔试面试题\n　　下面列举一些面试笔试中经常遇到的关于static关键字的题目，仅供参考，如有补充欢迎下方留言。\n\n1.下面这段代码的输出结果是什么？\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\npublic class Test extends Base{\n\n    static{\n        System.out.println(\"test static\");\n    }\n     \n    public Test(){\n        System.out.println(\"test constructor\");\n    }\n     \n    public static void main(String[] args) {\n        new Test();\n    }\n}\n\nclass Base{\n     \n    static{\n        System.out.println(\"base static\");\n    }\n     \n    public Base(){\n        System.out.println(\"base constructor\");\n    }\n}\n\nbase static\ntest static\nbase constructor\ntest constructor\n　　至于为什么是这个结果，我们先不讨论，先来想一下这段代码具体的执行过程，在执行开始，先要寻找到main方法，因为main方法是程序的入口，但是在执行main方法之前，必须先加载Test类，而在加载Test类的时候发现Test类继承自Base类，因此会转去先加载Base类，在加载Base类的时候，发现有static块，便执行了static块。在Base类加载完成之后，便继续加载Test类，然后发现Test类中也有static块，便执行static块。在加载完所需的类之后，便开始执行main方法。在main方法中执行new Test()的时候会先调用父类的构造器，然后再调用自身的构造器。因此，便出现了上面的输出结果。\n\n2.这段代码的输出结果是什么？\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\npublic class Test {\n    Person person = new Person(\"Test\");\n    static{\n        System.out.println(\"test static\");\n    }\n     \n    public Test() {\n        System.out.println(\"test constructor\");\n    }\n     \n    public static void main(String[] args) {\n        new MyClass();\n    }\n}\n\nclass Person{\n    static{\n        System.out.println(\"person static\");\n    }\n    public Person(String str) {\n        System.out.println(\"person \"+str);\n    }\n}\n\n\nclass MyClass extends Test {\n    Person person = new Person(\"MyClass\");\n    static{\n        System.out.println(\"myclass static\");\n    }\n     \n    public MyClass() {\n        System.out.println(\"myclass constructor\");\n    }\n}\n View Code\n　　类似地，我们还是来想一下这段代码的具体执行过程。首先加载Test类，因此会执行Test类中的static块。接着执行new MyClass()，而MyClass类还没有被加载，因此需要加载MyClass类。在加载MyClass类的时候，发现MyClass类继承自Test类，但是由于Test类已经被加载了，所以只需要加载MyClass类，那么就会执行MyClass类的中的static块。在加载完之后，就通过构造器来生成对象。而在生成对象的时候，必须先初始化父类的成员变量，因此会执行Test中的Person person = new Person()，而Person类还没有被加载过，因此会先加载Person类并执行Person类中的static块，接着执行父类的构造器，完成了父类的初始化，然后就来初始化自身了，因此会接着执行MyClass中的Person person = new Person()，最后执行MyClass的构造器。\n\n3.这段代码的输出结果是什么？\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\npublic class Test {\n     \n    static{\n        System.out.println(\"test static 1\");\n    }\n    public static void main(String[] args) {\n         \n    }\n     \n    static{\n        System.out.println(\"test static 2\");\n    }\n}\n\ntest static 1\ntest static 2\n　　虽然在main方法中没有任何语句，但是还是会输出，原因上面已经讲述过了。另外，static块可以出现类中的任何地方（只要不是方法内部，记住，任何方法内部都不行），并且执行是按照static块的顺序执行的。","tags":["Java"]},{"title":"Java的值传递机制","url":"/2020/10/16/Java的值传递机制/","content":"\n和C语言一样，Java中也是采用“值传递”，即传递的是原参数的复印件，并不会影响原参数  \n\n\n## 概念\n形参：方法声明时，方法小括号内的参数  \n实参：调用方法时，实际传入的参数的值\n\n## 规则：java中的参数传递机制：值传递机制\n1. 形参是基本数据类型的：将实参的值传递给形参的基本数据类型的变量\n2. 形参是引用数据类型的：将实参的引用类型变量的值（对应的堆空间的对象实体的首地址值）传递给形参的引用类型变量。\n\n**代码演示：**  \n基本类型的实例变量的传值机制\n```java\npackage Java的值传递问题;\n\npublic class Test {\n    // 定义一个学生类，里面有基本类型引用类型的实例变量方便测试\n    public static class Stu{\n        int age = 18;\n        String name = \"wenhuan\";\n    }\n    //构造一个changeAge方法\n    public static void changeAge(int s){\n        s = 0;\n    }\n    //构造一个changeName方法\n    public static void changeName(String s){\n        s = \"null\";\n    }\n\n    public static void main(String[] args) {\n        Stu s = new Stu();\n        //调用changeAge方法来改变stu的age\n        System.out.println(\"尝试改变前的s的age：\"+s.age);//尝试改变前的s的age：18\n        changeAge(s.age);\n        System.out.println(\"尝试改变后的s的age：\"+s.age);//尝试改变后的s的age：18\n        //age的值没有改变，猜想传入方法中的参数只是age的一个副本而不是age本身。\n    }\n}\n```\n在main方法中直接更改age\n```java\nSystem.out.println(\"尝试改变前的s的age：\"+s.age);//尝试改变前的s的age：18\n//        changeAge(s.age);\n        s.age = 0;\n        System.out.println(\"尝试改变后的s的age：\"+s.age);//尝试改变后的s的age：0\n```\n\nage发生了改变，证明是传入时出了问题，传的是副本。\n\n引用类型的实例变量的传值机制\n\n尝试将引用类型实例变量name当做参数传入方法，在方法内实例化一个新的对象并将该对象的地址传给参数,从而修改name的指向\n\n```java\n    System.out.println(\"尝试改变前的s的name：\"+s.name);//尝试改变前的s的name：wenhuan\n    changeName(s.name);\n    System.out.println(\"尝试改变后的s的name：\"+s.name);//尝试改变前的s的name：wenhuan\n```\n\n发现name并没有改变，指向的仍旧是原来的那个对象，猜想传入方法的参数不是name本身而是name的一个副本（也就是地址的一个副本）。\n\n在main方法中直接更改name\n\n```java\n    System.out.println(\"尝试改变前的s的name：\"+s.name);//尝试改变前的s的name：wenhuan\n    s.name = \"null\";\n    System.out.println(\"尝试改变后的s的name：\"+s.name);//尝试改变前的s的name：null\n```\n\nname发生了改变，证明是传入时出了问题，传的是地址的一个副本。\n\n**总结**\n\n　　以上所有操作只说明一个结果：Java中传参是值传递，**传入方法的只是一个copy**。传基本类型的变量时传的是数据的一个copy，传引用类型的变量时传的是地址的一个copy。此时注意引用类型的变量承载的只是对象的地址而不是对象本身!","tags":["Java"]},{"title":"二叉树","url":"/2020/10/15/二叉树/","content":"\n树是一种经常用到的数据结构，用来模拟具有树状结构性质的数据集合。\n\n树里的每一个节点有一个值和一个包含所有子节点的列表。从图的观点来看，树也可视为一个拥有N 个节点和N-1 条边的一个有向无环图。\n\n二叉树是一种更为典型的树状结构。如它名字所描述的那样，二叉树是每个节点最多有两个子树的树结构，通常子树被称作“左子树”和“右子树”。\n\n**知识点：**  \n1. 树的节点结构\n2. 深度优先搜索（DFS）：树的前序遍历，中序遍历，后续遍历的解法\n   + 递归\n   + 迭代\n3. 层序顺序遍历（使用队列）\n4. 运用递归解决树的相关问题\n   + “自顶而下”和“自底而上”的解题思路\n   + 二叉树的最大深度\n   + 对称二叉树\n   + 路径总和\n5. 总结\n\n## 1. 数的节点结构\n\n```java\npublic class Node {  \n    private int data;  \n    private Node leftNode;  \n    private Node rightNode;  \n\n    TreeNode(int val) {\n        this.val = val;\n    }\n\n    public Node(int data, Node leftNode, Node rightNode){  \n        this.data = data;  \n        this.leftNode = leftNode;  \n        this.rightNode = rightNode;  \n    }  \n  \n    public int getData() {  \n        return data;  \n    }  \n\n    public void setData(int data) {  \n        this.data = data;  \n    }  \n\n    public Node getLeftNode() {  \n        return leftNode;  \n    }  \n\n    public void setLeftNode(Node leftNode) {  \n        this.leftNode = leftNode;  \n    }  \n\n    public Node getRightNode() {  \n        return rightNode;  \n    }  \n\n    public void setRightNode(Node rightNode) {  \n        this.rightNode = rightNode;  \n    }  \n}  \n```\n\n创建二叉树的时候注意必须逆序建立，先建立子节点，再逆序往上建立，因为非叶子结点会使用到下面的节点，而初始化是按顺序初始化的，不逆序建立会报错 。\n\n## 2. 树的前序遍历，中序遍历，后续遍历的解法\n\n树的前序遍历，中序遍历，后续遍历的解法有递归和迭代两种\n\n### 递归解法\n\n```java\n public void theFirstTraversal(Node root) {  //先序遍历  \n        printNode(root);  \n        if (root.getLeftNode() != null) {  //使用递归进行遍历左孩子  \n            theFirstTraversal(root.getLeftNode());  \n        }  \n        if (root.getRightNode() != null) {  //递归遍历右孩子  \n            theFirstTraversal(root.getRightNode());  \n        }  \n    }  \n\npublic void theInOrderTraversal(Node root) {  //中序遍历  \n    if (root.getLeftNode() != null) {  \n        theInOrderTraversal(root.getLeftNode());  \n    }  \n    printNode(root);  \n    if (root.getRightNode() != null) {  \n        theInOrderTraversal(root.getRightNode());  \n    }  \n}\n    \npublic void thePostOrderTraversal(Node root) {  //后序遍历  \n    if (root.getLeftNode() != null) {  \n        thePostOrderTraversal(root.getLeftNode());  \n    }  \n    if(root.getRightNode() != null) {  \n        thePostOrderTraversal(root.getRightNode());  \n    }  \n    printNode(root);  \n}  \n```\n\n### 迭代解法\n\n#### 前序遍历\n```java\npublic static List<Integer> preorderTraversal(TreeNode root) {\n    //创建两个链接列表对象，指定TreeNode类型的作为栈来使用，Integer类型的用作存储排好序的数据\n    LinkedList<TreeNode> stack = new LinkedList<>();\n    LinkedList<Integer> output = new LinkedList<>();\n    //判断传进来的参数是否为空，空的话返回空链表\n    if(root == null){\n        return output;\n    }\n    //把头节点存入栈\n    stack.add(root);\n    //while循环的条件很关键，\n    while(!stack.isEmpty()){\n        //设置一个临时变量Node,用于操作栈，把栈中的值存入output中，出栈，按先序遍历顺序入栈\n        TreeNode node = new TreeNode();\n        //pollLast方法在出栈的同时还可以返回出栈的元素，非常方便\n        node = stack.pollLast();\n        output.addLast(node.val);\n        //判断节点是否为空很重要\n        if(node.right != null){\n            stack.add(node.right);\n        }\n        if(node.left != null){\n            stack.add(node.left);\n        }\n    }\n    return output;\n}\n```\n\n**总结**  \n迭代是自己创建并操作一个栈，按照先序遍历的特点，要注意，根结点是个例外，提前入栈，while循环做的第一件事是出栈并记录出栈的val，**然后是右子树入栈**，最后是左子树入栈，然后左子树出栈，其右左子树分别入栈，左子树全部出栈后，右子树出栈，其右左子树分别入栈，以此类推。因为栈是一种先进后出的结构。\n\n入栈的顺序需要注意，栈是先进后出的结构，我们需要先读左子树，所以左子树反而要后入栈。\n\n#### 中序遍历\n\n```java\npublic class Solution {\n    public List<Integer> inorderTraversal(TreeNode root) {\n        // 创建LinkedList对象stack用来作为栈使用，output用来存储按中序遍历排号顺序的元素\n        LinkedList<TreeNode> stack = new LinkedList<>();\n        LinkedList<Integer> output = new LinkedList<>();\n\n        while (root != null || !stack.isEmpty()) {\n            while (root != null) {\n                stack.add(root);\n                root = root.left;\n            }\n            root = stack.pollLast();\n            output.add(root.val);\n            root = root.right;\n        }\n        return output;\n    }\n}\n```\n\n**总结**  \n中序遍历和前序遍历不一样，中序遍历是从根结点开始先遍历到最左边的子树，依次入栈，而后出栈，然后`root = root.right;`检查该节点是否有右节点，有的话按前边的步骤再走一遍。\n\n做了两道迭代遍历之后，其实有一个难点十分相似——**右子树的处理**，前序遍历和中序遍历都有一个向左边不断走的趋向，区别是前序遍历是每到一个节点先遍历本身，而中序遍历是找到最左的子树才开始出栈。两者对右子树的处理不相同，中续遍历是左子树出栈后，立刻其检查右子树，而前序遍历是按右左的顺序依次入栈。这是由其自身的逻辑特点决定的，有一定难度。\n\n#### 后续遍历\n\n```java\nclass Solution {\n    public List<Integer> postorderTraversal(TreeNode root) {\n        List<Integer> res = new ArrayList<Integer>();\n        if (root == null) {\n            return res;\n        }\n\n        Deque<TreeNode> stack = new LinkedList<TreeNode>();\n        TreeNode prev = null;\n        // 循环开始的条件是root不为空，或者栈不为空，这点和中序遍历一样。\n        while (root != null || !stack.isEmpty()) {\n            while (root != null) {\n                stack.push(root);\n                root = root.left;\n            }\n            root = stack.pop();\n            // res入栈的条件很难理解，先决条件是最左的元素，然后要满足栈顶节点的右子树为空或者为之前遍历过的才可以入栈\n            // 为空很容易理解，由左右中的顺序，右为空的话可以直接跳过，开始遍历根结点\n            // 同理，之前遍历过了的话则直接遍历根结点。\n            if (root.right == null || root.right == prev) {\n                // res入栈之后立刻记录入栈的节点prev，置root为空，使得其不用执行寻找最右节点的步骤，\n                res.add(root.val);\n                prev = root;\n                root = null;\n            } else {\n                // 不满足条件的节点重新入栈，并把root置为该节点的右节点，\n                // 这时该节点不为空且未被遍历。\n                stack.push(root);\n                root = root.right;\n            }\n        }\n        return res;\n    }\n}\n```\n\n\n\n后序遍历的迭代做法是三种里面最难的一种，左右中里面“右”这个点很难处理，这里关联到了后面“中”的处理，最左边的子树很好找，和前面两种方法一样。但要注意的是，找到最左节点之后还需要确认其右节点是否为空，是否被遍历过，也就是在以该节点为根结点的子树里面“左右中”的顺序依然生效，但其变为了根结点。\n\n综上所述，最关键还是右节点的处理，在一棵最简单的子树里面有四种遍历可能：①左右中、②右中、③左中、④中，如何识别和遍历？\n\n方法：在找到最左节点的时候，根据右节点的情况，判断它是哪一种情况。右节点已经被遍历过了（需要记录上一个遍历的节点做对比）为情况①或②，右节点为空为情况③或④，这些情况都可以直接遍历该节点，如果不符合这两个条件的话，则右节点不为空且还没被遍历，需要把右节点入栈，进行遍历。\n\n## 3.层序顺序遍历\n\n```java\npublic class Solution {\n    Map<Integer, TreeNode> ancestor = new Hashtable<>();\n    Set<Integer> p_ancestor = new HashSet<Integer>();\n\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\n        preorderTraversal(root);\n        // 寻找p的所有父节点,存入数组\n        // LinkedList<TreeNode> p_ancestor = new LinkedList<>();\n        while(p!=null){\n            p_ancestor.add(p.val);\n            p = ancestor.get(p.val);\n        }\n\n        // 寻找q的祖先并和p的祖先对比，相同则结束，\n        while (q!=null){\n            if (p_ancestor.contains(q.val)) return q;\n            q = ancestor.get(q.val);\n        }\n        return null;\n\n    }\n\n    // 用哈希表存储所有子树的父节点\n    public void preorderTraversal(TreeNode root) {\n        //while (root != null) {\n            if (root.left != null) {\n                ancestor.put(root.left.val, root);\n                preorderTraversal(root.left);\n            }\n            if (root.right!=null) {\n                ancestor.put(root.right.val, root);\n                preorderTraversal(root.right);\n            }\n        //}\n    }\n}\n```\n\n\n\n层序遍历的思路是首先把所有节点的父节点都用哈希表记录下来，然后在里面把p的所有祖先找出来（包括p），再开始找q的祖先，当出现一样的节点，即找到。\n\nQ1：哈希表的key和vale的类型\n\n可以两个都选择TreeNode类型，也可以选择<Integer, TreeNode>的形式，这个关系到程序运行的开销。两个都选择TreeNode类型，程序运行开销比<Integer, TreeNode>的形式大，操作基本数据类型开销小。\n\nQ2：寻找祖先节点的条件判断\n\n```java\n        while(p!=null){\n            p_ancestor.add(p.val);\n            p = ancestor.get(p.val);\n        }\n```\n\n直接使用p！=null，**不需要新建临时存储的数据，直接使用传进来的p引用**，**不需要使用`contains(key)`方法**通过获取的值不存在时get()返回的null值作为结束的条件，减少代码量。\n\nQ3：数据类型的选择\n\n这个解法中，使用Hashtable类继承Map接口创建存储子节点和父节点一一对应的哈希表，使用Hashset类继承Set接口创建存储p节点所有祖先的集合。\n\n## 4.运用递归解决树的相关问题\n\n递归是解决树相关问题的最有效和最常用的方法之一，这里记录两种典型的递归方法。\n\n树可以以递归的方式定义为一个节点（根节点），它包括一个值和一个指向其他节点指针的列表。 递归是树的特性之一。 因此，许多树问题可以通过递归的方式来解决。 对于每个递归层级，我们只能关注单个节点内的问题，并通过递归调用函数来解决其子节点问题。\n\n### “自顶而下”和“自底而上”的解题思路\n\n#### Part1.“自顶向下” 的解决方案\n\n“自顶向下” 意味着在每个递归层级，我们将首先访问节点来计算一些值，并在递归调用函数时将这些值传递到子节点。 所以 “自顶向下” 的解决方案可以被认为是一种前序遍历。 具体来说，递归函数 top_down(root, params) 的原理是这样的：\n\n```java\n1. return specific value for null node\n2. update the answer if needed                      // anwer <-- params\n3. left_ans = top_down(root.left, left_params)\t\t// left_params <-- root.val, params\n4. right_ans = top_down(root.right, right_params)\t// right_params <-- root.val, params\n5. return the answer if needed                      // answer <-- left_ans, right_ans\n```\n\n例如，思考这样一个问题：给定一个二叉树，请寻找它的最大深度。\n\n我们知道根节点的深度是1。 **对于每个节点，如果我们知道某节点的深度，那我们将知道它子节点的深度。 因此，在调用递归函数的时候，将节点的深度传递为一个参数，那么所有的节点都知道它们自身的深度。 而对于叶节点，我们可以通过更新深度从而获取最终答案。** 这里是递归函数 maximum_depth(root, depth) 的伪代码：\n\n```java\n1. return if root is null\n2. if root is a leaf node:\n3. \t\tanswer = max(answer, depth)         // update the answer if needed\n4. maximum_depth(root.left, depth + 1)      // call the function recursively for left child\n5. maximum_depth(root.right, depth + 1)\t\t// call the function recursively for right child\n```\n\njava代码如下：\n```java\nprivate int answer;\t\t// don't forget to initialize answer before call maximum_depth\nprivate void maximum_depth(TreeNode root, int depth) {\n    if (root == null) {\n        return;\n    }\n    if (root.left == null && root.right == null) {\n        answer = Math.max(answer, depth);\n    }\n    maximum_depth(root.left, depth + 1);\n    maximum_depth(root.right, depth + 1);\n}\n```\n\n#### Part2.“自底向上” 的解决方案\n\n“自底向上” 是另一种递归方法。 **在每个递归层次上，我们首先对所有子节点递归地调用函数，然后根据返回值和根节点本身的值得到答案。** 这个过程可以看作是后序遍历的一种。 通常， “自底向上” 的递归函数 bottom_up(root) 为如下所示：\n\n```java\n1. return specific value for null node\n2. left_ans = bottom_up(root.left)\t\t\t// call function recursively for left child\n3. right_ans = bottom_up(root.right)\t\t// call function recursively for right child\n4. return answers                           // answer <-- left_ans, right_ans, root.val\n```\n\n继续讨论前面关于树的最大深度的问题，但是使用不同的思维方式：**对于树的单个节点，以节点自身为根的子树的最大深度x是多少？**\n\n如果我们知道一个根节点，以其左子节点为根的最大深度为l和以其右子节点为根的最大深度为r，我们是否可以回答前面的问题？ 当然可以，我们可以选择它们之间的最大值，再加上1来获得根节点所在的子树的最大深度。 那就是 x = max（l，r）+ 1。\n\n这意味着对于每一个节点来说，我们都可以在解决它子节点的问题之后得到答案。 因此，我们可以使用“自底向上“的方法。下面是递归函数 maximum_depth(root) 的伪代码：\n\n```java\n1. return 0 if root is null                 // return 0 for null node\n2. left_depth = maximum_depth(root.left)\n3. right_depth = maximum_depth(root.right)\n4. return max(left_depth, right_depth) + 1\t// return depth of the subtree rooted at root\n```\n\njava代码如下：\n```java\npublic int maximum_depth(TreeNode root) {\n\tif (root == null) {\n\t\treturn 0;                                   // return 0 for null node\n\t}\n\tint left_depth = maximum_depth(root.left);\n\tint right_depth = maximum_depth(root.right);\n\treturn Math.max(left_depth, right_depth) + 1;\t// return depth of the subtree rooted at root\n}\n```\n\n**总结**  \n了解递归并利用递归解决问题并不容易。\n\n当遇到树问题时，请先思考一下两个问题：\n\n1. 你能确定一些参数，从该节点自身解决出发寻找答案吗？  \n2. 你可以**使用这些参数和节点本身的值来决定什么应该是传递给它子节点的参数**吗？  \n如果答案都是肯定的，那么请尝试使用 “自顶向下” 的递归来解决此问题。\n\n或者你可以这样思考：对于树中的任意一个节点，如果你知道它子节点的答案，你能计算出该节点的答案吗？ 如果答案是肯定的，那么 “自底向上” 的递归可能是一个不错的解决方法。\n\n在接下来提供几个经典例题，以帮助你更好地理解树的结构和递归。\n\n### 经典例题一：二叉树的最大深度\n\n给定一个二叉树，找出其最大深度。\n\n二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。\n\n说明: 叶子节点是指没有子节点的节点。\n\n示例：\n给定二叉树 [3,9,20,null,null,15,7]，\n\n         3\n        / \\\n       9   20\n          /  \\\n         15   7\n返回它的最大深度 3 。\n\n思路一：自顶而下的思想\n    从根节点开始，设深度为1，每下一层+1，下到最底层的时候选取两个子节点中层数多的那个+1作为最大深度(top_down(root))  \n\n自己设计的伪代码如下：\n        \n        top_down(root){\n            if(root==null){\n                return 0;\n            }\n            depth=1\n            if(depth.right!=null){\n                depth+=1;\n                top_down(depth.right)\n            }\n            if(depth.left!=null){\n                depth+=1;\n                top_down(depth.left)\n            }\n            return depth;\n        }\n\n运行后发现问题：  \n问题一：`depth=1`这个设计还是陷在原来的非递归思维，这样设置的话每一次循环都会重置`depth`的值，所以不可行。正确的方法应该是不设置`depth`,而是利用一下代码\n```java\n    if(root==null){\n        return 0;\n    }\n```\n每迭代一次+1就可以达到目的。\n```java\npublic class Solution {\n    public static int maxDepth(TreeNode root){\n        if(root == null){\n            return 0;\n        }else{\n            int leftHeight = maxDepth(root.left);\n            int rightHeight = maxDepth(root.right);\n            return Math.max(leftHeight, rightHeight) + 1;\n        }\n/*\n错误解法：\n        int depth = 1;\n        if(root.left != null){\n            depth++;\n            maxDepth(root.left);\n        }\n        if(root.right != null){\n            depth++;\n            maxDepth(root.right);\n        }\n        return depth;*/\n    }\n}\n```\n**小技巧**：善用`math.max()`函数可以减少代码量，非常方便。\n\n### ★经典例题二：对称二叉树\n\n给定一个二叉树，检查它是否是镜像对称的。\n\n        例如，二叉树[1,2,2,3,4,4,3] 是对称的。\n    \n        1\n        / \\\n        2   2\n        / \\ / \\\n        3  4 4  3\n        \n        但是下面这个[1,2,2,null,3,null,3] 则不是镜像对称的:\n    \n          1\n         / \\\n        2   2\n         \\   \\\n          3    3\n        \n        进阶：你可以运用递归和迭代两种方法解决这个问题吗？*/\n\n#### 方法一：递归\n如果一个树的左子树与右子树镜像对称，那么这个树是对称的。  \n因此，该问题可以转化为：两个树在什么情况下互为镜像？\n\n如果同时满足下面的条件，两个树互为镜像：\n1. 它们的两个根结点具有相同的值\n2. 每个树的右子树都与另一个树的左子树镜像对称\n\n我们可以实现这样一个递归函数，通***过「同步移动」两个指针的方法***来遍历这棵树，p 指针和 q 指针一开始都指向这棵树的根，随后 p 右移时，q 左移，p 左移时，q 右移。每次检查当前 p 和 q 节点的值是否相等，如果相等再判断左右子树是否对称。\n\n代码如下：\n```java\nclass Solution {\n    public boolean isSymmetric(TreeNode root) {\n        return check(root, root);\n    }\n\n    public boolean check(TreeNode p, TreeNode q) {\n        if (p == null && q == null) {\n            return true;\n        }\n        if (p == null || q == null) {\n            return false;\n        }\n        return p.val == q.val && check(p.left, q.right) && check(p.right, q.left);\n    }\n}\n```\n\n**复杂度分析**\n\n假设树上一共 nn 个节点。\n\n+ 时间复杂度：这里遍历了这棵树，渐进时间复杂度为 O(n)。\n+ 空间复杂度：这里的空间复杂度和递归使用的栈空间有关，这里递归层数不超过 n，故渐进空间复杂度为 O(n)。\n\n\n#### 方法二：迭代\n\n「方法一」中我们用递归的方法实现了对称性的判断，那么如何用迭代的方法实现呢？首先我们引入一个队列，这是把递归程序改写成迭代程序的常用方法。初始化时我们把根节点入队两次。每次提取两个结点并比较它们的值（队列中每两个连续的结点应该是相等的，而且它们的子树互为镜像），然后将两个结点的左右子结点按相反的顺序插入队列中。当队列为空时，或者我们检测到树不对称（即从队列中取出两个不相等的连续结点）时，该算法结束。\n\n```java\nclass Solution {\n    public boolean isSymmetric(TreeNode root) {\n        return check(root, root);\n    }\n\n    public boolean check(TreeNode u, TreeNode v) {\n        Queue<TreeNode> q = new LinkedList<TreeNode>();\n        q.offer(u);\n        q.offer(v);\n        while (!q.isEmpty()) {\n            u = q.poll();\n            v = q.poll();\n            if (u == null && v == null) {\n                continue;\n            }\n            if ((u == null || v == null) || (u.val != v.val)) {\n                return false;\n            }\n\n            q.offer(u.left);\n            q.offer(v.right);\n\n            q.offer(u.right);\n            q.offer(v.left);\n        }\n        return true;\n    }\n}\n```\n\n**复杂度分析**\n\n+ 时间复杂度：O(n)O(n)，同「方法一」。\n+ 空间复杂度：这里需要用一个队列来维护节点，每个节点最多进队一次，出队一次，队列中最多不会超过 nn 个点，故渐进空间复杂度为 O(n)O(n)。\n\n#### 方法三：递归2\n\n+ 递归的方法是可以中途退出的。处理好各种情况的return顺序。\n+ **终止条件**\n  + L.val=R.val ：即此两对称节点值相等。\n  + L.left.val=R.right.val ：即 L 的 左子节点 和 R 的 右子节点 对称；\n  + *L*.right.val*=*R*.left*.val ：即 L 的 右子节点 和 R 的 左子节点 对称。\n+ 特例处理：root == null，\n\n```java\npublic class Solution {\n    public boolean isSymmetric(TreeNode root) {\n        return root == null || recursion(root.left, root.right);\n    }\n\n    public boolean recursion(TreeNode l, TreeNode r){\n        if (l == null & r == null)return true;\n        if (l == null || r == null || l.val !=r.val)return false;\n        return recursion(l.left, r.right) && recursion(l.right, r.left);\n    }\n}\n```\n\n\n\n### ★经典例题三：路径总和\n\n给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。\n\n        说明:叶子节点是指没有子节点的节点。\n    \n        示例:\n        给定如下二叉树，以及目标和 sum = 22，\n    \n                 5\n                / \\\n               4   8\n              /   / \\\n            11  13   4\n           /  \\       \\\n           7    2      1\n        返回 true, 因为存在目标和为 22 的根节点到叶子节点的路径 5->4->11->2。*/\n\n解答：\n\n```java\nclass Solution {\n    public boolean hasPathSum(TreeNode root, int sum) {\n        if(root == null){\n            return false;\n        }\n        sum -= root.val;\n        if(sum == 0 && root.right == null && root.left == null){\n            return true;\n        }\n        return hasPathSum(root.left, sum) || hasPathSum(root.right, sum);\n    }\n}\n```\n\n**做题总结**：   \n一开始的时候思路是按前序遍历的思路做，和前序遍历不同的地方是这道题目每遍历一个节点都要把他从sum减掉，一开始的解决方法是想设一个标记之类的，但后来发现由于Java的值传递机制，根本不需要。 \n\n细节一：sum减到零的时候要确保他是叶子节点，而不是中间节点才符合题意。\n\n### ★经典例题四：从中序与后序遍历序列构造二叉树\n\n    根据一棵树的中序遍历与后序遍历构造二叉树。\n    \n        注意:你可以假设树中没有重复的元素。\n    \n        例如，给出\n    \n        中序遍历 inorder =[9,3,15,20,7]\n        后序遍历 postorder = [9,15,7,20,3]\n        返回如下的二叉树：\n    \n         3\n        / \\\n       9   20\n          /  \\\n         15   7\n\n**利用后序遍历和中序遍历的特点解题**  \n\n后续遍历的顺序是：左右中  \n中序遍历的顺序是：左中右\n\n关键点1：后续遍历的最后一个元素为根结点  \n关键点2：找出根结点后可以在中序遍历中划分左右子树  \n关键点3：利用1、2点通过递归的方法解决问题\n\n**自己的思考方向：**\n\n1. 由于要经常查找根节点元素在中序遍历数组中的下标，数据结构应该用`hashtable`比较高效。\n2. 大概的递归流程：\n\n        后.last为根，获取index\n        中.[0,index-1]为左子树\n        中.[index+1,last]为右子树\n\n3. 遇到的问题及之后看答案求解：\n   + 递归到叶子节点的情况做什么：创建节点，返回节点\n   + 如何连接节点：直接定义root.right和root.left\n   + 定义递归函数时，哪里是递归入口，传什么参数，返回什么类型的值：用index作为参数，返回节点类型的值。\n\nJava代码如下：\n\n```java\n\nimport java.util.Hashtable;\n\npublic class Solution {\n    // 定义全局变量，方便递归函数操作\n    int post_idx;// post_idx\n    int[] postorder;\n    int[] inorder;\n    Hashtable<Integer, Integer> table = new Hashtable<>();\n\n    public TreeNode buildTree(int[] inorder, int[] postorder) {\n        this.inorder = inorder;\n        this.postorder = postorder;\n        for (int i = 0; i < inorder.length; i++) {\n            table.put(inorder[i], i);\n        }\n        post_idx = postorder.length - 1;\n        return helper(0, post_idx);\n    }\n\n    public TreeNode helper(int in_left, int in_right) {\n        if (in_left > in_right) {\n            return null;\n        }\n\n        // 选择 post_idx 位置的元素作为当前子树根节点\n        int root_val = postorder[post_idx];\n        TreeNode root = new TreeNode(root_val);\n\n        // 根据 root 所在位置分成左右两棵子树\n        int index = table.get(root_val);\n\n        // 下标减一\n        post_idx--;\n\n        // 构建左右子树,理解这里参数in_right和in_left有难度\n        root.right = helper(index + 1, in_right);\n        root.left = helper(in_left, index - 1);\n        return root;    \n    }\n}\n```\n\n**关于运用递归解决二叉树问题的一些总结**\n   + 递归函数里的第一步都是判断是否递归到叶子节点的子节点，如果是就结束，但怎么判断这个是叶子节点的子节点要根据递归函数的参数来判断，比如这道题目，传的参数是数组的下标，那么根据左边不可能比右边大为条件写if条件\n   + 递归函数最后的返回值一般都是节点。\n   + 在递归的过程有一些变量是每次递归都需要的，可这些变量是一直不变的，可以用全局变量来达到目的，避免多次传参。还可以直接把要传进去的参数先用全局变量定义好，再在方法里面使用传进来的参数进行初始化。适用于方法里面要用到传参，可又不方便定义。比如这道题目，递归函数里不方便进行定义和引用，用传参的方法每次都要copy一样的值，花销应该会比较大，代码量也会增加。\n   + 这道题题还有一个注意点是左右子树的创建顺序是不能随意互换的，一定要先创建右子树，这是由于后序遍历的特点——“左右中”的顺序，我们根节点的选取是从最后面开始的，所以要先创建右子树。而下面的题目则正好相反。\n\n### ★经典例题五：从前序与中序遍历序列构造二叉树\n\n    根据一棵树的前序遍历与中序遍历构造二叉树。\n    \n        注意:\n        你可以假设树中没有重复的元素。\n    \n        例如，给出\n    \n        前序遍历 preorder = [3,9,20,15,7]\n        中序遍历 inorder = [9,3,15,20,7]\n        返回如下的二叉树：\n    \n         3\n        / \\\n       9   20\n          /  \\\n         15   7\n\nJava代码如下：\n\n```java\n\nimport java.util.Hashtable;\n\npublic class Solution {\n    //定义全局变量\n    int first_index;\n    int[] preorder;\n    int[] inorder;\n    Hashtable<Integer, Integer> idx_map = new Hashtable<>();\n\n    public TreeNode buildTree(int[] preorder, int[] inorder) {\n        this.preorder = preorder;\n        this.inorder = inorder;\n        for (int i = 0; i < preorder.length; i++) {\n            idx_map.put(inorder[i], i);\n        }\n\n        first_index = 0;\n\n        return helper(0, inorder.length-1);\n\n    }\n    //递归函数\n    public TreeNode helper(int in_left, int in_right){\n        if(in_left > in_right){\n            return null;\n        }\n\n        //分开左右子树\n        int index = idx_map.get(preorder[first_index]);\n\n        //创建根节点\n        int root_val = preorder[first_index];\n        first_index++;\n        TreeNode root = new TreeNode(root_val);\n\n        // 理解这里参数in_right和in_left有难度,这两个参数分别保证在子树划分之后，左子树的最右边界，和右子树的最左边界在正确的位置\n        root.left = helper(in_left, index - 1);\n        root.right = helper(index + 1, in_right);\n\n        return root;\n    }\n}\n```\n\n这道题目的解法和上一道题目大同小异，只需要更改根结点的下标和左右子树的创建顺序就可以。\n\n### 例题六：填充每个节点的下一个右侧节点指针\n    给定一个完美二叉树，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：\n    \n        struct Node {\n        int val;\n        Node *left;\n        Node *right;\n        Node *next;\n        }\n        填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。\n    \n        初始状态下，所有next 指针都被设置为 NULL。\n#### 方法一：使用已建立的 next 指针\n\n**思路**\n\n一棵树中，存在两种类型的 next 指针。\n\n1.第一种情况是连接同一个父节点的两个子节点。它们可以通过同一个节点直接访问到，因此执行下面操作即可完成连接。\n\n```Java\nnode.left.next = node.right\n```\n\n2.第二种情况在不同父亲的子节点之间建立连接，这种情况不能直接连接。\n\n如果每个节点有指向父节点的指针，可以通过该指针找到 next 节点。如果不存在该指针，则按照下面思路建立连接：\n>第 N 层节点之间建立 next 指针后，再建立第 N+1 层节点的 next 指针。可\n>以通过 next 指针访问同一层的所有节点，因此可以使用第 N 层的 next 指\n>针，为第 N+1 层节点建立 next 指针。\n\n算法\n\n从根节点开始，由于第 00 层只有一个节点，所以不需要连接，直接为第 11 层节点建立 next 指针即可。该算法中需要注意的一点是，当我们为第 NN 层节点建立 next 指针时，处于第 N-1N−1 层。当第 NN 层节点的 next 指针全部建立完成后，移至第 NN 层，建立第 N+1N+1 层节点的 next 指针。\n\n遍历某一层的节点时，这层节点的 next 指针已经建立。因此我们只需要知道这一层的最左节点，就可以按照链表方式遍历，不需要使用队列。\n\n上面思路的伪代码如下：  \n\n\n```java\nleftmost = root\nwhile (leftmost.left != null) {\n    head = leftmost\n    while (head.next != null) {\n        1) Establish Connection 1\n        2) Establish Connection 2 using next pointers\n        head = head.next\n    }\n    leftmost = leftmost.left\n}\n```\n\n\nJava代码如下:\n\n\n**迭代做法**\n\n```java\nclass Solution {\n    public Node connect(Node root) {\n        if (root == null) {\n            return root;\n        }\n        \n        // 从根节点开始\n        Node leftmost = root;\n        \n        while (leftmost.left != null) {\n            \n            // ★遍历这一层节点组织成的链表，为下一层的节点更新 next 指针\n            // 新建的head是用来做每一层的遍历，而原来的leftmost则用来控制换层\n            Node head = leftmost;\n            while (head != null) {\n                \n                // CONNECTION 1\n                head.left.next = head.right;\n                \n                // CONNECTION 2\n                if (head.next != null) {\n                    head.right.next = head.next.left;\n                }\n                \n                // 指针向后移动\n                head = head.next;\n            }\n            \n            // 去下一层的最左的节点\n            leftmost = leftmost.left;\n        }\n```\n\n复杂度分析\n\n+ 时间复杂度：O(N)，每个节点只访问一次。\n\n+ 空间复杂度：O(1)，不需要存储额外的节点。\n\n**自己的总结**\n\n+ 迭代的方法解题，一般写法都是两个while循环嵌套\n+ 这道题有一个隐藏知识可以使用，创建对象时如果没有赋值，会默认进行赋值，可以看作最左侧的节点的next都是设定好了为null，只需要把剩下的节点弄好就可以\n+ 层序遍历只需要使用两个变量来控制，一个是从根节点不断转到下一层的最左边的节点，另一个则是最左节点的复制，用来做每一层的遍历。\n\n**递归做法**\n\n```java\nclass Solution {\n    public TreeNode connect(TreeNode root) {\n        if (root == null) {\n            return null;\n        }\n        if (root.left != null) {\n            root.left.next = root.right;\n            root.right.next = root.next != null ? root.next.left : null;\n            /*if (root.next != null) {\n                root.right.next = root.next.left;\n            } else {\n                root.right.next = null;\n            }*/\n            connect(root.left);\n            connect(root.right);\n        }\n        return root;\n    }\n}\n```\n\n### 例题七：填充每个节点的下一个右侧节点指针 II\n\n\n给定一个二叉树\n\n        struct Node {\n            int val;\n            Node *left;\n            Node *right;\n            Node *next;\n        }\n        填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，\n        则将 next 指针设置为 NULL。\n    \n        初始状态下，所有next 指针都被设置为 NULL。\n    \n        进阶：\n            你只能使用常量级额外空间。\n            使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。\n\n\n\n```java\nclass Solution {\n    public Node connect(Node root) {\n        if (root == null) {\n            return null;\n        }\n        Node leftmost = root;\n        while (leftmost != null) {\n            Node head = leftmost;\n            while (head != null) {\n                // connection1：head存在左右子树，左子树直接连接\n                if (head.left != null && head.right != null) {\n                    head.left.next = head.right;\n                    head.right = connectDifTree(head,head.right);\n                }\n                // connection2：head存在左子树，但不存在右子树\n                else if(head.left != null){\n                    head.left = connectDifTree(head,head.left);\n                }\n                // connection3:head不存在左子树，存在右子树\n                else if (head.right != null){\n                    head.right = connectDifTree(head, head.right);\n                }\n                head = head.next;\n            }\n            leftmost = fineLeftMost(leftmost);\n        }\n        return root;\n    }\n    public Node connectDifTree(Node head,Node child) {\n        //非同父节点子树间的连接\n        Node tempN = head.next;\n        if (tempN == null) {\n            child.next = null;\n            return child;\n        }\n        if (tempN.left != null) {\n            child.next = tempN.left;\n            return child;\n        } else if (tempN.right != null) {\n            child.next = tempN.right;\n            return child;\n        }\n        else return connectDifTree(head.next,child);\n    }\n    public Node fineLeftMost(Node l){\n        while(l != null){\n            if (l.left != null){\n                return l.left;\n            }else if(l.right != null){\n                return l.right;\n            }\n            l = l.next;\n        }\n        return null;\n    }\n}\n```\n\n**个人总结**\n1. 这一道题和上道题的思路和算法和上一道题很像，但这道题要复杂很多。依旧是使用层序遍历的思想来解题，但由于题中二叉树不是完全二叉树，子树的情况不可预测，需要比第一道题多很多的判断条件。\n2. 寻找一层当中的最左子树，即层序遍历的起点，要注意遍历该层的所有子树。\n3. 虽然比上道题复杂，但整体来说并不难，我在解题的过程由于受到上一道题目的定势思维影响，很多情况都没有考虑妥当，采用了和上一题一样的解法，导致做题花费时间非常多。这道题做完我最大的收获可能是“做题要顾整体而言”，就是做题的时候，要清楚整体的思路，不要在某个条件的判断里面陷进去，做题之前最好在脑海里面走一遍伪代码，写条件的时候要细心仔细，拿出测试软件的劲设想好所有会出现的情况，其中要留意哪几种情况可以合并，哪些情况可以简化。\n\n\n\n### 例题八：填充每个节点的下一个右侧节点指针 \n\n        给定一个完美二叉树，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：\n        struct Node {\n            int val;\n            Node *left;\n            Node *right;\n            Node *next;\n        }\n        填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。\n    \n        初始状态下，所有next 指针都被设置为 NULL。\n\n\n**递归解法**\n\n```java\nclass Solution {\n    public TreeNode connect(TreeNode root) {\n        if (root == null) {\n            return null;\n        }\n        if (root.left != null) {\n            root.left.next = root.right;\n            root.right.next = root.next != null ? root.next.left : null;\n            /*if (root.next != null) {\n                root.right.next = root.next.left;\n            } else {\n                root.right.next = null;\n            }*/\n            connect(root.left);\n            connect(root.right);\n        }\n        return root;\n    }\n}\n```\n\n**迭代解法**\n\n```java\nclass Solution {\n    public Node connect(Node root) {\n        if (root == null) {\n            return null;\n        }\n        Node leftmost = root;\n        while (leftmost != null) {\n            Node head = leftmost;\n            while (head != null) {\n\n                // connection1：head存在左右子树，左子树直接连接\n                if (head.left != null && head.right != null) {\n                    head.left.next = head.right;\n                    head.right = connectDifTree(head,head.right);\n                }\n                // connection2：head存在左子树，但不存在右子树，左子树连接head.next的子树或者为null\n                else if(head.left != null){\n                    head.left = connectDifTree(head,head.left);\n                }\n/*                else if(head.left!=null){\n                    Node tempN = head.next;\n                    if (tempN==null){\n                        head.left.next = null;\n                    }else if (tempN.left!=null){\n                        head.left.next = tempN.left;\n                    }else(tempN.right!=null){\n                        head.left.next = tempN.right;\n                    }\n                }\n                */\n                // connection3:head不存在左子树，存在右子树\n                else if (head.right != null){\n                    head.right = connectDifTree(head, head.right);\n                }\n/*                else (head.right!=null){\n                    Node tempN1 = head.next;\n                    if (tempN1==null){\n                        head.right.next = null;\n                    }else if (tempN1.left!=null){\n                        head.right.next = tempN1.left;\n                    }else(tempN1.right!=null){\n                        head.right.next = tempN1.right;\n                    }\n                }*/\n                // 尝试合并connection2和3\n/*                else if (head.left!=null||head.right!=null){\n                    Node temp;\n                    if(head.left!=null){\n                        temp=head.left;\n                    }else temp = head.right;\n\n                }*/\n                head = head.next;\n            }\n            leftmost = fineLeftMost(leftmost);\n        }\n        return root;\n    }\n    public Node connectDifTree(Node head,Node child) {\n        //非同父节点子树间的连接\n        Node tempN = head.next;\n        if (tempN == null) {\n            child.next = null;\n            return child;\n        }\n        if (tempN.left != null) {\n            child.next = tempN.left;\n            return child;\n        } else if (tempN.right != null) {\n            child.next = tempN.right;\n            return child;\n        }\n        else return connectDifTree(head.next,child);\n    }\n    public Node fineLeftMost(Node l){\n\n        while(l != null){\n            if (l.left != null){\n                return l.left;\n            }else if(l.right != null){\n                return l.right;\n            }\n            l = l.next;\n        }\n        return null;\n    }\n}\n```","tags":["数据结构"]},{"title":"替换空格","url":"/2020/10/13/替换空格/","content":"\n请实现一个函数，把字符串 s 中的每个空格替换成\"%20\"。\n\n    示例 1：\n\n    输入：s = \"We are happy.\"\n    输出：\"We%20are%20happy.\"\n\n    限制：    0 <= s 的长度 <= 10000\n \n\n**解题思路：** \n1. 暴力方法，把输入的对象存到数组，遍历替换\n2. 利用String类的replace方法\n\n\n**Java 中的字符串是不变的，所以直接替换是不行的。**\n\n```java\nclass Solution {\n    public String replaceSpace(String s) {\n        // 统计出字符串中空格的数目\n        int count = 0;\n        for (int i=0; i< s.length(); i++){\n            if (s.charAt(i) == ' '){ // charAt()方法用于返回指定索引处的字符\n                count++;\n            }\n        }\n        // 新建一个字符数组，长度为原来字符串的长度+空格数⽬*2\n        char[] ch = new char[s.length()+ count*2];\n        // 定义两个指针，分别指向原始字符串的末尾、替换之后的字符串的末尾\n        int p1 = s.length() -1;\n        int p2 = ch.length -1;\n        while (p1 >=0 && p2 >= 0){\n            // 若碰到空格，把p1向前移动一格，在p2之前插入字符串“%20”，然后把p2向前移动三格\n            if (s.charAt(p1) == ' '){ \n                ch[p2] = '0';\n                ch[p2-1] = '2';\n                ch[p2-2] = '%';\n                p1 -= 1;\n                p2 -= 3;\n            }\n            // 否则，逐个把p1指向的字符复制到P2指向的位置\n            else{\n                ch[p2] = s.charAt(p1);\n                p1 -= 1;\n                p2 -= 1;\n            }\n        }\n        /*\n        char数组转成字符串的方法有两种：\n            一种是直接将字符数组作为参数，通过new()构造String对象;\n            另一种是使用String的valueOf()方法\n        */\n        // return new String(ch);\n        return String.valueOf(ch);\n    }\n}\n```\n### 总结\n\n1. 接触了String的方法charAt()，用于返回指定索引处的字符\n2. 复习String的知识，Java 中的字符串是不变的，还有char数组转成字符串的两种方法  \n3. 双引号与单引号的区别，Java中，单引号(' ')引的是char类型；双引号（\" \"）引的是String类型。\n4. 获取字符串长度的是方法，带括号（```s.length()```），而数组则不用(```ch.length```)，一个是方法，一个是变量。","tags":["leetcode刷题"]},{"title":"二维数组的查找","url":"/2020/10/13/二维数组中的查找/","content":"在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。\n\n        示例:\n    \n        现有矩阵 matrix 如下：\n    \n        [\n        [1,   4,  7, 11, 15],\n        [2,   5,  8, 12, 19],\n        [3,   6,  9, 16, 22],\n        [10, 13, 14, 17, 24],\n        [18, 21, 23, 26, 30]\n        ]\n        给定 target = 5，返回 true。\n    \n        给定 target = 20，返回 false。\n    \n        限制：\n    \n        0 <= n <= 1000\n    \n        0 <= m <= 1000\n\n\n**问题一**：如何创建并初始化二维数组\n```java\nint[][] matrix = {{1, 4, 7, 11, 15},\n            {2,  5, 8,  12, 19},\n            {3,  6, 9,  16, 22},\n            {10,  13, 14, 17, 24},\n            {18,  21, 23, 26, 30}};\n```\n\n★利用有序性从数组右上方开始查询：只可以从左下角或者右上角开始！\n+ 若数组为空，返回 false  \n+  初始化行下标为 0，列下标为二维数组的列数减 1\n+ 重复下列步骤，直到行下标或列下标超出边界  \n   +  获得当前下标位置的元素 num\n   + 如果 num 和 target 相等，返回 true\n   + 如果 num 大于 target，列下标减 1\n   + 如果 num 小于 target，行下标加 1\n+ 循环体执行完毕仍未找到元素等于 target ，说明不存在这样的元素，返回 false\n\n```java\npackage 二维数组中的查找;\n\npublic class Solution {\n    public static void main(String[] args) {\n        int[][] matrix = {{1, 4, 7, 11, 15},\n                {2,  5, 8,  12, 19},\n                {3,  6, 9,  16, 22},\n                {10,  13, 14, 17, 24},\n                {18,  21, 23, 26, 30}};\n        int target = -5;\n        System.out.println(findNumberIn2DArray(matrix,target));\n    }\n    public static boolean findNumberIn2DArray(int[][] matrix, int target) {\n        //1、在使用数组前一定要判断数组是否为空\n        //2、二维数组的判断方法特殊\n        if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {\n            return false;\n        }\n        int i = 0;\n        int j = matrix[0].length - 1;// 如果传入数组为空时,会发生数组索引超出范围异常\n        while(i < matrix.length && j >= 0){\n            if(matrix[i][j] == target){\n                return true;\n            }\n            else if(matrix[i][j] > target){\n                j--;\n            }\n            else if(matrix[i][j] < target){\n                i++;\n            }\n        }\n        return false;\n    }\n}\n```\n\n## 总结\n\n**犯错一**：忽略空数组的情况\n\n**新问题一**：如何判断二维数组为空\n```java\nif (matrix == null || matrix.length == 0 || matrix[0].length == 0) {\n    return false;\n}\n```\n\n**犯错二**：当target在matrix[0][0]到[4][4]之间的时候可以用最长路径来划定最多比较次数，但当target超出matrix的范围时，这种做法会导致```ArrayIndexOutOfBoundsException```错误\n\n**新问题二**：如何限定比较的条件，避免ArrayIndexOutOfBoundsException错误\n\n    使用while循环语句\n\n**犯错三**：没有考虑输入数组为{[-5]}的情况,这个二维数组只有一行一列，\n\n解决办法：所有涉及数组长度的变量都用length方法获取得到。\n\n获取行数： ```int rowLength = array.length;```\n\n获取列数： ```int colLength = array[0].length;```\n\n**犯错四**：输入空数组时在```int j = matrix[0].length - 1```出现ArrayIndexOutOfBoundsException错误，二维数组实质上只是每个元素都为一个数组的一维数组，当要读取数组长度时应该先判断数组是否为空。\n\n\n","tags":["leetcode刷题"]},{"title":"找出数组中重复的数字","url":"/2020/10/12/03_数组中重复的数字/","content":"\n在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。\n\n示例 1\n\n输入：\n[2, 3, 1, 0, 2, 5, 3]\n输出：2 或 3 \n \n\n限制：\n2 <= n <= 100000\n\n\n```java\nimport java.util.HashSet;\nimport java.util.Set;\n\npublic class solution {\n    public static void main(String[] args) {\n        int[] nums = new int[]{2, 3, 1, 0, 2, 5, 3};\n        System.out.println(findRepeatNumber(nums));\n    }\n    public static int findRepeatNumber(int[] nums) {\n        Set set = new HashSet<Integer>();\n        int repeat = -1;\n        for(int num : nums){\n            if(!set.add(num)){\n                repeat = num;\n                break;\n            }\n        }\n        return repeat;\n    }\n    /*\n    第一次解题，超时！！\n    public static int findRepeatNumber(int[] nums) {\n        Hashtable<Integer, Integer> table = new Hashtable<Integer, Integer>();\n        for(int i = 0; i < nums.length; i++){\n            if(table.contains(nums[i])){\n                return nums[i];\n            }\n            table.put(i, nums[i]);\n        }\n        throw new IllegalArgumentException(\"No Repeat Number\");\n    }*/\n}\n```\n\n**问题一**：为什么用Hashtable超时，而HasSet不会。\n\n第一次解题超时并不是Hashtable的问题，使用Hashtable、HashMap都可以解题。超时的原因是<key, value>的设置，把数组里的元素设置成value就会发生超时，因为`contains(Object value)`的时间复杂度为O(n),而`containsKey(Object key) `的时间复杂度为O(1)\n\n+ `contains(Object value)`：需要一个一个对比遍历\n+ `containsKey(Object key) `：计算key对应的地址，如果地址不为空则代表存在。\n\n综上，在建立字典的时候应该仔细考虑什么存为key，什么存为value。\n\n**拓展**  \nHashSet源码几乎就是HashMap来做的，只是把元素存放在Key上，而完全没有用到map的Value，其他的所有操作都是几乎简单的调用了HashMap的。\n\n他们俩都必须计算哈希码，但要考虑HashMap的键的性质-它通常是一个简单的String甚至是一个数字。而String和Integer的计算哈希码的速度比整个对象的默认哈希码计算要快得多\n\n如果HashMap的键与存储在HashSet中的键是相同的对象，则性能将没有真正的区别。区别在于HashMap的键是哪种对象。\n\n**新知识**：Set类,HashSet类,foreach句式。\n\n**面试注意点**：它考察的是程序员的沟通能力，先问面试官要时间/空间需求！！！\n\n**总结**：解题利用了`HashSet`中不允许集合中有重复的值这个特点，依次把数组的元素加入集合中，当有重复的数字加入的时候，`add()`函数会返回false，这时候根据返回值可以判断是否为重复数字。\n\n","tags":["leetcode刷题"]},{"title":"java中的HashTable,HashMap和HashSet","url":"/2020/10/12/java中的HashTable,HashMap和HashSet/","content":"\n## HashTable和HashMap的区别\n\n` HashMap`和`Hashtable`都实现了Map接口，但决定用哪一个之前先要弄清楚它们之间的分别。**主要的区别有：线程安全性，同步(synchronization)，以及速度。**\n\n### 线程安全性，同步\n`HashMap`几乎可以等价于`Hashtable`，除了`HashMap`是**非synchronized的**，并**可以接受null**(HashMap allows one null key and any number of null values.，而Hashtable则不行)。这就是说，`HashMap`中如果在表中没有发现搜索键，或者如果发现了搜索键，但它是一个空的值，那么get()将返回null。如果有必要，*用containKey()方法来区别这两种情况。*\n\n**`HashMap`是非synchronized，而`Hashtable`是synchronized**，这意味着**Hashtable是线程安全的，多个线程可以共享一个Hashtable**；而如果没有正确的同步的话，多个线程是不能共享`HashMap`的。 即是说，在多线程应用程序中，不用专门的操作就安全地可以使用`Hashtable`了；而对于`HashMap`，则需要额外的同步机制。但`HashMap`的同步问题可通过Collections的一个静态方法得到解决：`Map Collections.synchronizedMap(Map m)`这个方法返回一个同步的Map，这个Map封装了底层的`HashMap`的所有方法，使得底层的`HashMap`即使是在多线程的环境中也是安全的。\n\n*另一个区别是`HashMap`的迭代器(Iterator)是fail-fast迭代器，而Hashtable的enumerator迭代器不是fail-fast的。*所以当有其它线程改变了`HashMap`的结构（增加或者移除元素），将会抛出`ConcurrentModificationException`，但迭代器本身的remove()方法移除元素则不会抛出`ConcurrentModificationException`异常。但这并不是一个一定发生的行为，要看JVM。这条同样也是Enumeration和Iterator的区别。\n\n### 速度\n由于`Hashtable`是线程安全的也是synchronized，所以**在单线程环境下它比HashMap要慢**。如果你不需要同步，只需要单一线程，那么使用`HashMap`性能要好过`Hashtable`。\n\n`HashMap`不能保证随着时间的推移Map中的元素次序是不变的。\n哈希值的使用不同，`HashTable`直接使用对象的hashCode，代码是这样的：\n```java\n      int hash = key.hashCode();\n      int index = (hash & 0x7FFFFFFF) % tab.length;\n```\n而`HashMap`重新计算hash值，而且用与代替求模：\n```java\nint hash = hash(k);\nint i = indexFor(hash, table.length);\n```\n\n要注意的一些重要术语：\n1) sychronized意味着在一次仅有一个线程能够更改`Hashtable`。就是说任何线程要更新`Hashtable`时要首先获得同步锁，其它线程要等到同步锁被释放之后才能再次获得同步锁更新`Hashtable`。\n\n2) Fail-safe和iterator迭代器相关。如果某个集合对象创建了Iterator或者ListIterator，然后其它的线程试图“结构上”更改集合对象，将会抛出ConcurrentModificationException异常。但其它是假如已经从结构上进行了更改，再调用set()方法，将会抛出IllegalArgumentException异常。\n\n3) 结构上的更改指的是删除或者插入一个元素，这样会影响到map的结构。\n\n## HashSet和HashMap的区别\n\n### 什么是HashSet？\nHashSet实现了Set接口，**它不允许集合中有重复的值**，当我们提到HashSet时，第一件事情就是在将对象存储在HashSet之前，要先确保对象重写equals()和hashCode()方法，这样才能比较对象的值是否相等，以确保set中没有储存相等的对象。如果我们没有重写这两个方法，将会使用这个方法的默认实现。详见《探索equals()和hashCode()方法》。\n\npublic boolean add(Object o)方法用来在Set中添加元素，当元素值重复时则会立即返回false，如果成功添加的话会返回true。\n\n\n\n**什么是HashMap？**  \nHashMap实现了Map接口，Map接口对键值对进行映射。**Map中不允许重复的键**。Map接口有两个基本的实现，HashMap和TreeMap。TreeMap保存了对象的排列次序，而HashMap则不能。HashMap允许键和值为null。HashMap是非synchronized的，但collection框架提供方法能保证HashMap synchronized，这样多个线程同时访问HashMap时，能保证只有一个线程更改Map。\n\n`public Object put(Object Key,Object value)`方法用来将元素添加到map中。\n\n**HashSet和HashMap的区别**  \nHashMap | HashSet\n---|---\nHashMap实现了Map接口 |HashSet实现了Set接口  \nHashMap储存键值对 |HashSet仅仅存储对象（且无重复对象）  \n使用put()方法将元素放入map中|使用add()方法将元素放入set中\nHashMap中使用键对象来计算hashcode值|HashSet使用成员对象来计算hashcode值，对于两个对象来说hashcode可能相同，所以equals()方法用来判断对象的相等性，如果两个对象不同的话，那么返回false\nHashMap比较快，因为是使用唯一的键来获取对象\t|HashSet较HashMap来说比较慢\n\n## HashMap工作原理\n\n待补充\n\n## HashSet工作原理\n\n待补充\n\n参考：https://blog.csdn.net/speedme/article/details/22485681","tags":["leetcode刷题"]},{"title":"idea常用的快捷键","url":"/2020/05/14/IDEA常用快捷键/","content":"\nAlt+回车 导入包,自动修正\n\nCtrl+N   查找类\n\nCtrl+Shift+N 查找文件\n\nCtrl+Alt+L  格式化代码\n\nCtrl+Alt+O 优化导入的类和包\n\nAlt+Insert 生成代码(如get,set方法,构造函数等)\n\nCtrl+E或者Alt+Shift+C  最近更改的代码\n\nCtrl+R 替换文本\n\nCtrl+F 查找文本\n\nCtrl+Shift+Space 自动补全代码\n\nCtrl+空格 代码提示\n\nCtrl+Alt+Space 类名或接口名提示\n\nCtrl+P 方法参数提示\n\nCtrl+Shift+Alt+N 查找类中的方法或变量\n\nAlt+Shift+C 对比最近修改的代码\n\nShift+F6  重构-重命名\n\nCtrl+Shift+先上键\n\nCtrl+X 删除行\n\nCtrl+D 复制行\n\nCtrl+/ 或 Ctrl+Shift+/  注释（// 或者/*...*/ ）\n\nCtrl+J  自动代码\n\nCtrl+E 最近打开的文件\n\nCtrl+H 显示类结构图\n\nCtrl+Q 显示注释文档\n\nAlt+F1 查找代码所在位置\n\nAlt+1 快速打开或隐藏工程面板\n\nCtrl+Alt+ left/right 返回至上次浏览的位置\n\nAlt+ left/right 切换代码视图\n\nAlt+ Up/Down 在方法间快速移动定位\n\nCtrl+Shift+Up/Down 代码向上/下移动。\n\nF2 或Shift+F2 高亮错误或警告快速定位\n\n代码标签输入完成后，按Tab，生成代码。\n\n选中文本，按Ctrl+Shift+F7 ，高亮显示所有该文本，按Esc高亮消失。\n\nCtrl+W 选中代码，连续按会有其他效果\n\n选中文本，按Alt+F3 ，逐个往下查找相同文本，并高亮显示。\n\nCtrl+Up/Down 光标跳转到第一行或最后一行下\n\nCtrl+B 快速打开光标处的类或方法 \n\nIntellij IDEA最常用快捷键\n\n1.Ctrl＋E，可以显示最近编辑的文件列表\n\n2.Shift＋Click可以关闭文件\n\n3.Ctrl＋[或]可以跳到大括号的开头结尾\n\n4.Ctrl＋Shift＋Backspace可以跳转到上次编辑的地方\n\n5.Ctrl＋F12，可以显示当前文件的结构\n\n6.Ctrl＋F7可以查询当前元素在当前文件中的引用，然后按F3可以选择\n\n7.Ctrl＋N，可以快速打开类\n\n8.Ctrl＋Shift＋N，可以快速打开文件\n\n9.Alt＋Q可以看到当前方法的声明\n\n10.Ctrl＋W可以选择单词继而语句继而行继而函数\n\n11.Alt＋F1可以将正在编辑的元素在各个面板中定位\n\n12.Ctrl＋P，可以显示参数信息\n\n13.Ctrl＋Shift＋Insert可以选择剪贴板内容并插入\n\n14.Alt＋Insert可以生成构造器/Getter/Setter等\n\n15.Ctrl＋Alt＋V 可以引入变量。例如把括号内的SQL赋成一个变量\n\n16.Ctrl＋Alt＋T可以把代码包在一块内，例如try/catch\n\n17.Alt＋Up and Alt＋Down可在方法间快速移动","tags":["其他"]},{"title":"hexo博客部署","url":"/2020/05/14/hexo博客部署/","content":"#### 搭建要求：\n\ngit——下载地址：https://git-scm.com/downloads\n\n安装及使用教程：https://www.runoob.com/git/git-tutorial.html\n\nNode.js——下载地址：https://nodejs.org/zh-cn/\n\n使用教程：https://www.runoob.com/nodejs/nodejs-tutorial.html\n\n#### 开始搭建：\n\n##### 1.检查环境\n\n```\nnode -v     #查看node版本\nnpm -v     #查看npm版本\nnpm无加速器下载资源较慢，这里建议改成淘宝的cnpm工具\nnpm install -g cnpm --registry=http://registry.npm.taobao.org #安装淘宝的管理器\ncnpm -v    #查看cnpm版本\n```\n\n##### 2.安装Hexo\n\n选择一个磁盘，新建一个用来保存hexo框架的文件夹\n\n`cnpm install -g hexo-cli    #安装hexo框架`\n\n`hexo init    #生成博客，初始化博客/注意   linux的用户需要加 sudo获取权限`\n\n##### 3.获取博客主题以aircloud为例\n\n在主题文件夹执行\n\n`git clone https://github.com/aircloud/hexo-theme-airclou`\n\n修改文件名为aircloud，修改_config.yml文件的主题参数为aircloud。\n\n搜索功能等插件在主题的github上有详细描述，不一一赘述。\n\n##### 4.让图片支持markdown相对路径格式\n\n参考https://cloud.tencent.com/developer/article/1600295\n\n- 修改`post_asset_folder: true`\n- 生成一篇新的博客 `hexo new blog-name`\n- 通过typora向博客中插入一张图片，此时可以到`source/_posts`目录下看图片是否拷贝到了对应的目录\n- `npm install hexo-image-link --save`安装插件\n- `hexo server -debug` 预览图片是否能正常显示\n\n##### 5.发布到gitee\n\n配置_config.yml中的关键参数\n\n```yaml\nurl: https://wenwenhuan.gitee.io\nroot: /\n\ndeploy:\n  type: git\n  repo: git@gitee.com:wenwenhuan/wenwenhuan.git\n  branch: master\n```\n\n输入命令`npm install hexo-deployer-git --save` 安装自动部署发布工具\n输入命令`hexo clean && hexo g && hexo d` 发布博客，首次发布需要在shell中输入账号和密码。","tags":["其他"]},{"title":"数值的整数次方","url":"/2020/03/02/数值的整数次方/","content":"\n实现函数double Power(double base, int exponent)，求base的exponent次方。不得使用库函数，同时不需要考虑大数问题。\n\n示例 1:\n\n输入: 2.00000, 10\n输出: 1024.00000\n\n示例 2:\n\n输入: 2.00000, -2\n输出: 0.25000\n解释: 2-2 = 1/22 = 1/4 = 0.25\n\n说明:\n\n-100.0 < x < 100.0\nn 是 32 位有符号整数，其数值范围是 [−231, 231 − 1] 。\n\n利用快速幂解题（二分法角度）： \n算法流程： \n\n1. 当 x = 0时：直接返回 0 （避免后续 x=1/x 操作报错）。\n2. 初始化 res = 1res=1 ；\n3. 当 n < 0n<0 时：把问题转化至 n \\geq 0n≥0 的范围内，即执行 x = 1/xx=1/x ，n = - nn=−n ；\n4. 循环计算：当 n=0 时跳出；\n   1. 当 n \\& 1 = 1 时：将当前 x 乘入 res（即 res∗=x ）；\n   2. 执行 x = x^2即 （x∗=x ）；\n   3. 执行 n 右移一位（即 n >>= 1）。\n\n5. 返回 res 。\n\nJava 代码中 int32 变量 n∈[−2147483648,2147483647] ，因此当 n = -2147483648时执行 n = -n 会因越界而赋值出错。解决方法是先将 n存入 long 变量 b ，后面用 b 操作即可。\n\n```java\nclass Solution {\n    public double myPow(double x, int n) {\n        if(x == 0) return 0;\n        long b = n;\n        double res = 1.0;\n        if(b < 0) {\n            x = 1 / x;\n            b = -b;\n        }\n        while(b > 0) {\n            if((b & 1) == 1) res *= x;\n            x *= x;\n            b >>= 1;\n        }\n        return res;\n    }\n}\n```\n\n知识扩展：\n\n+ 向下整除 n // 2 等价于位移运算的右移一位n>>1 ；\n\n  java中有三种移位运算符\n\n  <<    :   左移运算符，num << 1,相当于num乘以2\n\n  \\>>    :   右移运算符，num >> 1,相当于num除以2\n\n  \\>>>   :   无符号右移，忽略符号位，空位都以0补齐\n\n+ 取余数 n \\% 2 **等价于** 判断二进制最右一位值 n \\& 1 ；\n\n  位运算符&--两个为真才为真\n\n  &按位与的运算规则是将两边的数转换为二进制位，然后运算最终值，运算规则即(两个为真才为真)1&1=1 , 1&0=0 , 0&1=0 , 0&0=0\n\n  3的二进制位是0000 0011 ， 5的二进制位是0000 0101 ， 那么就是011 & 101，由按位与运算规则得知，001 & 101等于0000 0001，最终值为1\n\n  7的二进制位是0000 0111，那就是111 & 101等于101，也就是0000 0101，故值为5","tags":["Leetcode"]},{"title":"剪绳子","url":"/2020/02/04/大数求余解法/","content":"\n# 大数求余解法（例返回3^a）：\n\n### **大数越界**\n\n当 a 增大时，最后返回的 3^a大小以指数级别增长，可能超出 int32 甚至 int64 的取值范围，导致返回值错误。\n\n### **大数求余问题**\n\n在仅使用 int32 类型存储的前提下，正确计算 x^a 对 p 求余的值。\n\n### 关于对p求值\n\nint类型是32位，最大值为2^32 = 2 147 483 647，而10^9刚好也是10位，所以为了方便运算，一般p取1e9+7（1000000007），另外还有以下几个理由：\n\n1. 1000000007是一个质数\n2. int32位的最大值为2147483647，所以对于int32位来说1000000007足够大\n3. int64位的最大值为2^63-1，对于1000000007来说它的平方不会在int64中溢出\n\n![image-20210203225313162](C:%5CUsers%5CPowerwenwh%5CDocuments%5C_posts%5Cimgs%5C%E5%A4%A7%E6%95%B0%E6%B1%82%E4%BD%99%E8%A7%A3%E6%B3%95%5Cimage-20210203225313162.png)\n\n### **解决方案**\n\n循环求余 、 快速幂求余 ，其中后者的时间复杂度更低，两种方法均基于以下求余运算规则推出：\n\n(xy)%p=[(x%p)(y%p)]%p\n\n#### 1. 循环求余\n\n![image-20210203223021511](C:%5CUsers%5CPowerwenwh%5CDocuments%5C_posts%5Cimgs%5C%E5%A4%A7%E6%95%B0%E6%B1%82%E4%BD%99%E8%A7%A3%E6%B3%95%5Cimage-20210203223021511.png)\n\n#### 2. 快速幂求余\n\n![image-20210204073646858](C:%5CUsers%5CPowerwenwh%5CDocuments%5C_posts%5Cimgs%5C%E5%A4%A7%E6%95%B0%E6%B1%82%E4%BD%99%E8%A7%A3%E6%B3%95%5Cimage-20210204073646858.png)","tags":["Leetcode"]}]